<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lottyzhou.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第一篇 iOS 内存管理1 似乎每个人在学习 iOS 过程中都考虑过的问题 alloc retain release delloc 做了什么？ autoreleasepool 是怎样实现的？ __unsafe_unretained 是什么？ Block 是怎样实现的 什么时候会引起循环引用，什么时候不会引起循环引用？  所以我将在本篇博文中详细的从 ARC 解释到 iOS 的内存管理，以及 Blo">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS进阶——iOS（Objective-C） 内存管理&amp;Block">
<meta property="og:url" content="http://lottyzhou.com/2017/02/08/iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS-Memory-Block/index.html">
<meta property="og:site_name">
<meta property="og:description" content="第一篇 iOS 内存管理1 似乎每个人在学习 iOS 过程中都考虑过的问题 alloc retain release delloc 做了什么？ autoreleasepool 是怎样实现的？ __unsafe_unretained 是什么？ Block 是怎样实现的 什么时候会引起循环引用，什么时候不会引起循环引用？  所以我将在本篇博文中详细的从 ARC 解释到 iOS 的内存管理，以及 Blo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-01.png">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-02.png">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-03.png">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-04.png">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-05.png">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-06.png">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-07.png">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-08.png">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-12.png">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-09.png">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-10.png">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-05.png">
<meta property="article:published_time" content="2017-02-08T07:33:40.000Z">
<meta property="article:modified_time" content="2021-10-11T09:40:59.400Z">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="iOS进阶">
<meta property="article:tag" content="内存与引用">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-01.png">

<link rel="canonical" href="http://lottyzhou.com/2017/02/08/iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS-Memory-Block/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>iOS进阶——iOS（Objective-C） 内存管理&Block | </title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title"></h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lottyzhou.com/2017/02/08/iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS-Memory-Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOS进阶——iOS（Objective-C） 内存管理&Block
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-08 15:33:40" itemprop="dateCreated datePublished" datetime="2017-02-08T15:33:40+08:00">2017-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-11 17:40:59" itemprop="dateModified" datetime="2021-10-11T17:40:59+08:00">2021-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/iOS%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">iOS进阶</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第一篇-iOS-内存管理"><a href="#第一篇-iOS-内存管理" class="headerlink" title="第一篇 iOS 内存管理"></a>第一篇 iOS 内存管理</h1><h2 id="1-似乎每个人在学习-iOS-过程中都考虑过的问题"><a href="#1-似乎每个人在学习-iOS-过程中都考虑过的问题" class="headerlink" title="1 似乎每个人在学习 iOS 过程中都考虑过的问题"></a>1 似乎每个人在学习 iOS 过程中都考虑过的问题</h2><ol>
<li>alloc retain release delloc 做了什么？</li>
<li>autoreleasepool 是怎样实现的？</li>
<li>__unsafe_unretained 是什么？</li>
<li>Block 是怎样实现的</li>
<li>什么时候会引起循环引用，什么时候不会引起循环引用？</li>
</ol>
<p>所以我将在本篇博文中详细的从 ARC 解释到 iOS 的内存管理，以及 Block 相关的原理、源码。</p>
<h2 id="2-从-ARC-说起"><a href="#2-从-ARC-说起" class="headerlink" title="2 从 ARC 说起"></a>2 从 ARC 说起</h2><p>说 iOS 的内存管理，就不得不从 ARC（Automatic Reference Counting / 自动引用计数） 说起， ARC 是 WWDC2011 和 iOS5 引入的变化。ARC 是 LLVM 3.0 编译器的特性，用来自动管理内存。</p>
<p>与 Java 中 GC 不同，ARC 是编译器特性，而不是基于运行时的，所以 ARC 其实是在编译阶段自动帮开发者插入了管理内存的代码，而不是实时监控与回收内存。</p>
<span id="more"></span>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-01.png" alt="ARC 管理内存"></p>
<p>ARC 的内存管理规则可以简述为：</p>
<blockquote>
<ol>
<li>每个对象都有一个『被引用计数』</li>
<li>对象被持有，『被引用计数』+1</li>
<li>对象被放弃持有，『被引用计数』-1</li>
<li>『引用计数』=0，释放对象</li>
</ol>
</blockquote>
<h2 id="3-你需要知道"><a href="#3-你需要知道" class="headerlink" title="3 你需要知道"></a>3 你需要知道</h2><p><del>1. 包含 NSObject 类的 Foundation 框架并没有公开</del><br>（此处错误，感谢 <a target="_blank" rel="noopener" href="http://www.jianshu.com/u/486bf26e8dce">酷酷的哀殿</a> 的指出）</p>
<ol>
<li>Foundation 框架是非开源的，但是 NSObject 被包含在 <a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/objc4-706/runtime/NSObject.mm">obj4</a> 中，该库已开源。</li>
<li>Core Foundation 框架源代码，以及通过 NSObject 进行内存管理的部分源代码是公开的。</li>
<li>GNUstep 是 Foundation 框架的互换框架</li>
</ol>
<blockquote>
<p>GNUstep 也是 GNU 计划之一。将 Cocoa Objective-C 软件库以自由软件方式重新实现<br>某种意义上，GNUstep 和 Foundation 框架的实现是相似的<br>通过 GNUstep 的源码来分析 Foundation 的内存管理</p>
</blockquote>
<h2 id="4-alloc-retain-release-dealloc-的实现"><a href="#4-alloc-retain-release-dealloc-的实现" class="headerlink" title="4 alloc retain release dealloc 的实现"></a>4 alloc retain release dealloc 的实现</h2><h3 id="4-1-GNU-alloc"><a href="#4-1-GNU-alloc" class="headerlink" title="4.1 GNU - alloc"></a>4.1 GNU - alloc</h3><p>查看 GNUStep 中的 alloc 函数。</p>
<p><strong>GNUstep/modules/core/base/Source/NSObject.m alloc:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>) alloc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> allocWithZone: <span class="built_in">NSDefaultMallocZone</span>()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>) allocWithZone: (<span class="built_in">NSZone</span>*)z</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NSAllocateObject</span> (<span class="keyword">self</span>, <span class="number">0</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GNUstep/modules/core/base/Source/NSObject.m NSAllocateObject:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> obj_layout &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> retained;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSAllocateObject</span>(Class aClass, <span class="built_in">NSUInteger</span> extraBytes, <span class="built_in">NSZone</span> *zone)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>	size = 计算容纳对象所需内存大小;</span><br><span class="line">    <span class="keyword">id</span>	new = <span class="built_in">NSZoneCalloc</span>(zone, <span class="number">1</span>, size);</span><br><span class="line">    memset (new, <span class="number">0</span>, size);</span><br><span class="line">    new = (<span class="keyword">id</span>)&amp;((obj)new)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NSAllocateObject</code> 函数通过调用 <code>NSZoneCalloc</code> 函数来分配存放对象所需的空间，之后将该内存空间置为 nil，最后返回作为对象而使用的指针。</p>
<p>我们将上面的代码做简化整理：</p>
<p><strong>GNUstep/modules/core/base/Source/NSObject.m alloc 简化版本:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> obj_layout &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> retained;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>) alloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> obj_layout) + 对象大小;</span><br><span class="line">    <span class="keyword">struct</span> obj_layout *p = (<span class="keyword">struct</span> obj_layout *)calloc(<span class="number">1</span>, size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)(p+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> allocWithZone: <span class="built_in">NSDefaultMallocZone</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>alloc 类方法用 struct obj_layout 中的 <code>retained</code> 整数来保存引用计数，并将其写入对象的内存头部，该对象内存块全部置为 0 后返回。</p>
<p>一个对象的表示便如下图：</p>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-02.png" alt="GNU 中的对象存储空间"></p>
<h3 id="4-2-GNU-retain"><a href="#4-2-GNU-retain" class="headerlink" title="4.2 GNU - retain"></a>4.2 GNU - retain</h3><p><strong>GNUstep/modules/core/base/Source/NSObject.m retainCount:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>) retainCount</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">self</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">NSUInteger</span></span><br><span class="line"><span class="built_in">NSExtraRefCount</span>(<span class="keyword">id</span> anObject)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ((obj_layout)anObject)[<span class="number">-1</span>].retained;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GNUstep/modules/core/base/Source/NSObject.m retain:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) <span class="keyword">retain</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">self</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">id</span> anObject)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="built_in">UINT_MAX</span> - <span class="number">1</span>)</span><br><span class="line">    [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">      format: <span class="string">@&quot;NSIncrementExtraRefCount() asked to increment too far”];</span></span><br><span class="line"><span class="string">  ((obj_layout)anObject)[-1].retained++;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>以上代码中， <code>NSIncrementExtraRefCount</code> 方法首先写入了当 <code>retained</code> 变量超出最大值时发生异常的代码（因为 <code>retained</code> 是 NSUInteger 变量），然后进行 <code>retain ++</code> 代码。</p>
<h3 id="4-3-GNU-release"><a href="#4-3-GNU-release" class="headerlink" title="4.3 GNU - release"></a>4.3 GNU - release</h3><p>和 retain 相应的，release 方法做的就是 <code>retain --</code>。</p>
<p><strong>GNUstep/modules/core/base/Source/NSObject.m release</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>) release</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      [<span class="keyword">self</span> dealloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span></span><br><span class="line"><span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">id</span> anObject)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  ((obj)anObject)[<span class="number">-1</span>].retained--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-GNU-dealloc"><a href="#4-4-GNU-dealloc" class="headerlink" title="4.4 GNU - dealloc"></a>4.4 GNU - dealloc</h3><p>dealloc 将会对对象进行释放。</p>
<p><strong>GNUstep/modules/core/base/Source/NSObject.m dealloc:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) dealloc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSDeallocateObject</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">NSDeallocateObject</span>(<span class="keyword">id</span> anObject)</span><br><span class="line">&#123;</span><br><span class="line">  obj_layout o = &amp;((obj_layout)anObject)[<span class="number">-1</span>];</span><br><span class="line">  free(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-Apple-实现"><a href="#4-5-Apple-实现" class="headerlink" title="4.5 Apple 实现"></a>4.5 Apple 实现</h3><p>在 Xcode 中 设置 <code>Debug</code> -&gt; <code>Debug Workflow</code> -&gt; <code>Always Show Disassenbly</code> 打开。这样在打断点后，可以看到更详细的方法调用。</p>
<p>通过在 NSObject 类的 alloc 等方法上设置断点追踪可以看到几个方法内部分别调用了：</p>
<p><strong>retainCount</strong></p>
<blockquote>
<p>__CFdoExternRefOperation<br>CFBasicHashGetCountOfKey</p>
</blockquote>
<p><strong>retain</strong></p>
<blockquote>
<p>__CFdoExternRefOperation<br>CFBasicHashAddValue</p>
</blockquote>
<p><strong>release</strong></p>
<blockquote>
<p>__CFdoExternRefOperation<br>CFBasicHashRemoveValue</p>
</blockquote>
<p>可以看到他们都调用了一个共同的 <code>__CFdoExternRefOperation</code> 方法。</p>
<p>该方法从前缀可以看到是包含在 Core Foundation，在 CFRuntime.c 中可以找到，做简化后列出源码：</p>
<p><strong>CFRuntime.c __CFDoExternRefOperation:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __CFDoExternRefOperation(uintptr_t op, <span class="keyword">id</span> obj) &#123;</span><br><span class="line">    <span class="built_in">CFBasicHashRef</span> table = 取得对象的散列表(obj);</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> OPERATION_retainCount:</span><br><span class="line">        count = <span class="built_in">CFBasicHashGetCountOfKey</span>(table, obj);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OPERATION_retain:</span><br><span class="line">        count = <span class="built_in">CFBasicHashAddValue</span>(table, obj);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">        <span class="keyword">case</span> OPERATION_release:</span><br><span class="line">        count = <span class="built_in">CFBasicHashRemoveValue</span>(table, obj);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> == count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以 <code>__CFDoExternRefOperation</code> 是针对不同的操作，进行具体的方法调用，如果 op 是 <code>OPERATION_retain</code>，就去掉用具体实现 retain 的方法。</p>
<p>从 <code>BasicHash</code> 这样的方法名可以看出，其实引用计数表就是散列表。</p>
<p>key 为 hash(对象的地址) value 为 引用计数。</p>
<p>下图是 Apple 和 GNU 的实现对比：</p>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-03.png" alt="Apple 和 GNU 内存管理的实现对比"></p>
<h2 id="5-autorelease-和-autorelaesepool"><a href="#5-autorelease-和-autorelaesepool" class="headerlink" title="5 autorelease 和 autorelaesepool"></a>5 autorelease 和 autorelaesepool</h2><p>在苹果对于 NSAutoreleasePool 的<a target="_blank" rel="noopener" href="https://developer.apple.com/reference/foundation/nsautoreleasepool">文档</a>中表示：</p>
<blockquote>
<p>每个线程（包括主线程），都维护了一个管理 NSAutoreleasePool 的栈。当创先新的 Pool 时，他们会被添加到栈顶。当 Pool 被销毁时，他们会被从栈中移除。<br>autorelease 的对象会被添加到当前线程的栈顶的 Pool 中。当 Pool 被销毁，其中的对象也会被释放。<br>当线程结束时，所有的 Pool 被销毁释放。</p>
</blockquote>
<p>对 NSAutoreleasePool 类方法和 autorelease 方法打断点，查看其运行过程，可以看到调用了以下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="comment">// 等同于 objc_autoreleasePoolPush</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line"><span class="comment">//  等同于 objc_autorelease(obj)</span></span><br><span class="line">    </span><br><span class="line">[<span class="built_in">NSAutoreleasePool</span> showPools];</span><br><span class="line"><span class="comment">// 查看 NSAutoreleasePool 状况</span></span><br><span class="line">    </span><br><span class="line">[pool drain];</span><br><span class="line"><span class="comment">// 等同于 objc_autoreleasePoolPop(pool)</span></span><br></pre></td></tr></table></figure>
<p><code>[NSAutoreleasePool showPools]</code> 可以看到当前线程所有 pool 的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objc[21536]: ##############</span><br><span class="line">objc[21536]: AUTORELEASE POOLS for thread 0x10011e3c0</span><br><span class="line">objc[21536]: 2 releases pending.</span><br><span class="line">objc[21536]: [0x101802000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[21536]: [0x101802038]  ################  POOL 0x101802038</span><br><span class="line">objc[21536]: [0x101802040]       0x1003062e0  NSObject</span><br><span class="line">objc[21536]: ##############</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>在 <a target="_blank" rel="noopener" href="https://github.com/opensource-apple/objc4">objc4</a> 中可以查看到 AutoreleasePoolPage：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">objc4/<span class="built_in">NSObject</span>.mm AutoreleasePoolPage</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AutoreleasePoolPage </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push() </span><br><span class="line">    &#123;</span><br><span class="line">        生成或者持有 <span class="built_in">NSAutoreleasePool</span> 类对象</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> pop(<span class="keyword">void</span> *token) </span><br><span class="line">    &#123;</span><br><span class="line">        废弃 <span class="built_in">NSAutoreleasePool</span> 类对象</span><br><span class="line">        releaseAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">    &#123;</span><br><span class="line">        相当于 <span class="built_in">NSAutoreleasePool</span> 类的 addObject 类方法</span><br><span class="line">        AutoreleasePoolPage *page = 取得正在使用的 AutoreleasePoolPage 实例;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br><span class="line">    &#123;</span><br><span class="line">        将对象追加到内部数组</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> releaseAll() </span><br><span class="line">    &#123;</span><br><span class="line">        调用内部数组中对象的 release 方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AutoreleasePoolPage 以双向链表的形式组合而成（分别对应结构中的 parent 指针和 child 指针）。<br>thread 指针指向当前线程。<br>每个 AutoreleasePoolPage 对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址。<br>next 指针指向下一个 add 进来的 autorelease 的对象即将存放的位置。<br>一个 Page 的空间被占满时，会新建一个 AutoreleasePoolPage 对象，连接链表。</p>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-04.png" alt="AutoreleasePoolPage"></p>
<h2 id="6-unsafe-unretained"><a href="#6-unsafe-unretained" class="headerlink" title="6 __unsafe_unretained"></a>6 __unsafe_unretained</h2><p>有时候我们除了 <code>__weak</code> 和 <code>__strong</code> 之外也会用到 <code>__unsafe_unretained</code> 这个修饰符，那么我们对 <code>__unsafe_unretained</code> 了解多少？</p>
<p><code>__unsafe_unretained</code> 是不安全的所有权修饰符，尽管 ARC 的内存管理是编译器的工作，但附有 <code>__unsafe_unretained</code> 修饰符的变量不属于编译器的内存管理对象。<strong>赋值时即不获得强引用也不获得弱引用</strong>。</p>
<p>来运行一段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> obj1 = <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">            </span><br><span class="line">    obj1 = obj0;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;A: %@&quot;</span>, obj1);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;B: %@&quot;</span>, obj1);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-01-12 19:24:47.245220 __unsafe_unretained[55726:4408416] A: &lt;NSObject: 0x100304800&gt;</span><br><span class="line">2017-01-12 19:24:47.246670 __unsafe_unretained[55726:4408416] B: &lt;NSObject: 0x100304800&gt;</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>对代码进行详细分析：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> obj1 = <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自己生成并持有对象</span></span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 因为 obj0 变量为强引用，</span></span><br><span class="line">    <span class="comment">// 所以自己持有对象</span></span><br><span class="line">    obj1 = obj0;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 虽然 obj0 变量赋值给 obj1</span></span><br><span class="line">    <span class="comment">// 但是 obj1 变量既不持有对象的强引用，也不持有对象的弱引用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;A: %@&quot;</span>, obj1);</span><br><span class="line">    <span class="comment">// 输出 obj1 变量所表示的对象</span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;B: %@&quot;</span>, obj1);</span><br><span class="line">    <span class="comment">// 输出 obj1 变量所表示的对象</span></span><br><span class="line">    <span class="comment">// obj1 变量表示的对象已经被废弃</span></span><br><span class="line">    <span class="comment">// 所以此时获得的是悬垂指针</span></span><br><span class="line">    <span class="comment">// 错误访问</span></span><br></pre></td></tr></table></figure>
<p>所以，最后的 NSLog 只是碰巧正常运行，如果错误访问，会造成 crash<br>在使用 <code>__unsafe_unretained</code> 修饰符时，赋值给附有 <code>__strong</code> 修饰符变量时，要确保对象确实存在</p>
<h1 id="第二篇-Block"><a href="#第二篇-Block" class="headerlink" title="第二篇 Block"></a>第二篇 Block</h1><p>花几分钟时间看下面三个小题目，写下你的答案。</p>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-05.png" alt="Block 的三道测试题"></p>
<p>这个三个小题目，我在整理此片博文之前给了三位朋友去解答，最后的结果，除了一位朋友 3 题全部正确，其他两个朋友均只答中 1 题。</p>
<p>说明还是有很多 iOS 的朋友对于 Block 并没有透彻理解。本篇博文会对 Block 进行详细的解说。</p>
<h2 id="1-Block-使用的简单规则"><a href="#1-Block-使用的简单规则" class="headerlink" title="1 Block 使用的简单规则"></a>1 Block 使用的简单规则</h2><p>先了解简单规则，再去分析原理和实现：</p>
<blockquote>
<p>Block 中，Block <strong>表达式截获</strong>所使用的自动变量的值，即保存该自动变量的<strong>瞬间值</strong>。<br>修饰为 <code>__block</code> 的变量，在捕获时，获取的<strong>不再是瞬间值</strong>。</p>
</blockquote>
<p>至于 Why，后面将会继续说。</p>
<h2 id="2-Block-的实现"><a href="#2-Block-的实现" class="headerlink" title="2 Block 的实现"></a>2 Block 的实现</h2><p>Block 是带有自动变量（局部变量）的匿名函数。<br>Block 表达式很简单，总体可以描述为：『<code>^ 返回值类型 参数列表 表达式</code>』。<br>但是 Block 并不是 Objective-C 中才有的语法，这是怎么一回事？</p>
<p>clang 编译器提供给程序员了解 Objective-C 背后机制的方法，通过 clang 的转换可以看到 Block 的实现原理。</p>
<p>通过 <code>clang -rewrite-objc yourfile.m</code> clang 将会把 Objective-C 的代码转换成 C 语言的代码。</p>
<h3 id="2-1-Block-基本实现剖析"><a href="#2-1-Block-基本实现剖析" class="headerlink" title="2.1 Block 基本实现剖析"></a>2.1 Block 基本实现剖析</h3><p>用 Xcode 创建 Command Line 项目，写如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;Block&quot;</span>)&#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 clang 转换：</p>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-06.png" alt=""></p>
<p>以上是转换后的代码，不要方，一段一段看。</p>
<p>可以看到，Block 的实现内容，<strong>被转换成了一个普通的静态函数 <code>__main_func_0</code></strong>。</p>
<p>再看其他部分：</p>
<p><strong>main.cpp __block_impl:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>__block_impl</code> 结构体包括了一些标志、今后版本升级<strong>预留的变量</strong>、<strong>函数指针</strong>。</p>
<hr>
<p><strong>main.cpp __main_block_desc_0:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>
<p><code>__main_block_desc_0</code> 结构体包括了今后版本升级预留的变量、block 大小。</p>
<hr>
<p><strong>main.cpp __main_block_impl_0:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line"></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>__main_block_impl_0</code> 结构体含有两个成员变量，分别是 <code>__block_impl</code> 和 <code>__main_block_desc_0</code>实例变量。</p>
<p>此外，还含有一个构造方法。该构造方法在 main 函数中被如下调用：</p>
<p><strong>main.cpp __main_block_impl_0 构造函数的调用:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0,</span><br><span class="line">                                              &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure>
<p>去掉各种强制转换，做简化：</p>
<p><strong>main.cpp __main_block_impl_0 构造函数的调用 简化:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> <span class="title">tmp</span> =</span> __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> *<span class="title">blk</span> =</span> &amp;tmp;</span><br></pre></td></tr></table></figure>
<p>以上代码即：将 <code>__main_block_impl_0</code> 结构体实例的指针，赋值给 <code>__main_block_impl_0</code> 结构体指针类型的变量 <code>blk</code>。也就是我们最初的结构体定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;Block&quot;</span>);&#125;;</span><br></pre></td></tr></table></figure>
<p>另外，main 函数中还有另外一段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br></pre></td></tr></table></figure>
<p>去掉各种转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*blk-&gt;impl.FuncPtr)(blk);</span><br></pre></td></tr></table></figure>
<p>实际就是最初的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blk();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本节所有代码在 <a target="_blank" rel="noopener" href="https://github.com/summertian4/iOS-ObjectiveC/tree/master/ObjcMemory/ObjcMemory-Test-Code/block_implementation">block_implementation</a> 中</p>
</blockquote>
<h3 id="2-2-Block-截获外部变量瞬间值的实现剖析"><a href="#2-2-Block-截获外部变量瞬间值的实现剖析" class="headerlink" title="2.2 Block 截获外部变量瞬间值的实现剖析"></a>2.2 Block 截获外部变量瞬间值的实现剖析</h3><p>2.1 中对最简单的 <em>无参数 Block 声明、调用</em> 进行了 clang 转换。接下来再看一段『截获自动变量』的代码(可以使用命令 <code>clang -rewrite-objc -fobjc-arc -fobjc-runtime=macosx-10.7 main.m</code>)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">&quot;val = %d\n&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;printf(fmt, val);&#125;;</span><br><span class="line">    </span><br><span class="line">    val = <span class="number">2</span>;</span><br><span class="line">    fmt = <span class="string">&quot;These values were changed, val = %d\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clang 转换之后：</p>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-07.png" alt=""></p>
<p>和 2.1 节中的转换代码对比，可以发现多了一些代码。</p>
<p>首先，<code>__main_block_impl_0</code> 多了一个变量 <code>val</code>，并在构造函数的参数中加入了 <code>val</code> 的赋值：</p>
<p><strong>main.cpp __main_block_impl_0:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _val, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), val(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而在 main 函数中，对 Block 的声明变为此句：</p>
<p><strong>main.cpp __main_block_impl_0 构造函数的调用:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val));</span><br></pre></td></tr></table></figure>
<p>去掉转换：</p>
<p><strong>main.cpp __main_block_impl_0 构造函数的调用 简化:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 tmp = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, val);</span><br><span class="line">    <span class="keyword">struct</span> __main_block_impl_0 *blk = &amp;tmp;</span><br></pre></td></tr></table></figure>
<p>_<strong>所以，在 Block 被声明时，Block 已经将 <code>val</code> 作为 <code>__main_block_impl_0</code> 的内部变量保存下来了。无论在在声明之后怎样更改 val 的值，都不会影响，Block 调用时访问的内部 val 值。这就是 Block 捕获变量瞬间值的原理。</strong>_</p>
<blockquote>
<p>本节所有代码在 <a target="_blank" rel="noopener" href="https://github.com/summertian4/iOS-ObjectiveC/tree/master/ObjcMemory/ObjcMemory-Test-Code/EX05">EX05</a> 中</p>
</blockquote>
<h3 id="2-3-block-变量的访问实现剖析"><a href="#2-3-block-变量的访问实现剖析" class="headerlink" title="2.3 __block 变量的访问实现剖析"></a>2.3 __block 变量的访问实现剖析</h3><p>我们知道，Block 中能够读取，但是不能更改一个局部变量，如果去更改，Xcode 会提示你无法在 Block 内部更改变量。</p>
<p>Block 内部只是对局部变量只读，但是 Block 能读写以下几种变量：</p>
<ol>
<li>静态变量</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ol>
<p>也就是说以下代码是没有问题的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int global_val = 1;</span><br><span class="line">static int static_global_val = 2;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    static int static_val = 3;</span><br><span class="line">    </span><br><span class="line">    void (^blk)(void) = ^ &#123;</span><br><span class="line">        global_val = 1 * 2;</span><br><span class="line">        static_global_val = 2 * 2;</span><br><span class="line">        static_val = 3 * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想在 Block 内部写局部变量，需要对访问的局部变量增加 __block 修饰。</p>
<p>__block 修饰符其实类似于 C 语言中 static、auto、register 修饰符。用于指定将变量值设置到哪个存储域中。</p>
<p>具体 __block 之后究竟做了哪些变化我们可以写代码测试：</p>
<p><strong>EX07:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    __block int val = 10;</span><br><span class="line">    void (^blk)(void) = ^&#123;val = 1;&#125;;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clang 转换之后：</p>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-08.png" alt=""></p>
<p>跟 2.2 对比，似乎又加了非常代码。发现多了两个结构体。</p>
<p><strong>main.cpp __Block_byref_val_0:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很惊奇的发现，<strong>block 类型的 <code>val</code> 变成了结构体 `</strong>Block_byref_val_0<code>的实例。这个实例内，包含了</code><strong>isa<code>指针、一个标志位</code></strong>flags<code>、一个记录大小的</code><strong>size<code>。最最重要的，多了一个</code></strong>forwarding<code>指针和</code>val` 变量。这是怎么回事？</p>
<p>在 main 函数部分，实例化了该结构体：</p>
<p><strong>main.cpp main.m 部分:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__Block_byref_val_0 val = &#123;(void*)0,</span><br><span class="line">                            (__Block_byref_val_0 *)&amp;val,</span><br><span class="line">                            0,</span><br><span class="line">                            sizeof(__Block_byref_val_0),</span><br><span class="line">                            10&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看出该结构体对象初始化时：</p>
<ol>
<li><strong>__forwarding 指向了结构体实例本身在内存中的地址</strong></li>
<li>val = 10</li>
</ol>
<p>而在 main 函数中，<code>val = 1</code> 这句赋值语句变成了：</p>
<p><strong>main.cpp <code>val = 1;</code> 对应的函数:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(val-&gt;__forwarding-&gt;val) = 1;</span><br></pre></td></tr></table></figure>
<p>这里就可以看出其精髓，val = 1，实际上更改的是 <code>__Block_byref_val_0</code> 结构体实例 val 中的 <code>__forwarding</code> 指针（也就是本身）指向的 <code>val</code> 变量。</p>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-12.png" alt="__Block_byref_val_0 实例示意图"></p>
<p>而对 <code>val</code> 访问也是如此。你可以理解为通过取地址改变变量的值，这和 C 语言中取地址改变变量类似。</p>
<p>所以，声明 <strong>block 的变量可以被改变。至于 `</strong>forwarding` 的其他巨大作用，会继续分析。</p>
<blockquote>
<p>本节代码在 <a target="_blank" rel="noopener" href="https://github.com/summertian4/iOS-ObjectiveC/tree/master/ObjcMemory/ObjcMemory-Test-Code/EX07">EX05</a> 中</p>
</blockquote>
<h2 id="3-Block-的存储域"><a href="#3-Block-的存储域" class="headerlink" title="3 Block 的存储域"></a>3 Block 的存储域</h2><p>Block 有三种类型，分别是：</p>
<blockquote>
<ol>
<li>__NSConcreteStackBlock         ————————栈中</li>
<li>__NSConcreteGlobalBlock        ————————数据区域中</li>
<li>__NSConcreteMallocBlock        ————————堆中</li>
</ol>
</blockquote>
<p><strong>__NSConcreteGlobalBlock 出现的地方有：</strong></p>
<ol>
<li>设置全局变量的地方有 Block 语法时</li>
<li>Block 语法的表达式中不使用任何外部变量时</li>
</ol>
<p>设置在栈上的 Block，如果所属的变量作用域结束，Block 就会被废弃。如果其中用到了 <strong>block，</strong>block 所属的变量作用域结束也会被废弃。</p>
<p>为了解决这个问题，Block 在必要的时候就需要从栈中移到堆中。ARC 有效时，很多情况下，编译器会帮助完成 Block 的 copy，但很多情况下，我们需要手动 copy Block。</p>
<p>对不同存储域的 Block copy 时，影响如下：</p>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-09.png" alt="对不同存储域的 Block copy 影响"></p>
<p>copy 时，对访问到的 __block 类型对象影响如下：</p>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-10.png" alt="Block copy 时对 __block 对象的影响"></p>
<blockquote>
<p>此时可以看出 <code>__forwarding</code> 的巨大作用——无论 Block 此时在堆中还是在栈中，由于 <code>__forwarding</code> 指向局部变量转换成的结构体实例的真是地址，所以都能确保正确的访问。</p>
</blockquote>
<p>具体的来说：</p>
<ol>
<li>当 <strong>block 变量被一个 Block 使用时，Block 从栈复制到堆，</strong>block 变量也会被复制到，并被该 Block 持有。</li>
<li>在 <strong>block 变量被多个 Block 使用时，在任何一个 Block 从栈复制到堆时， </strong>block 变量也会被复制到堆，并被该 Block 持有。但由于 <code>__forwarding</code> 指针的存在，无论 <strong>block 变量和 Block 在不在同一个存储域，都可以正确的访问 </strong>block 变量。</li>
<li>如果堆上的 Block 被废弃，那么它所使用的 __block 变量也会被释放。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-11.png" alt=""></p>
<p>前面说到编译器会帮助完成一些 Block 的 copy，也有手动 copy Block。那么 Block 被复制到堆上的情况有（此段摘自于『Objective-C高级编程 iOS与OS X多线程和内存管理』）：</p>
<ol>
<li>调用 Block 的 copy 方法时</li>
<li>Block 作为返回值时</li>
<li>将 Block 赋值给附有 <code>__strong</code> 修饰符的成员变量时（id类型或 Block 类型）时</li>
<li>在方法名中含有 <code>usingBlock</code> 的 Cocoa 框架方法或 GCD 的 API 中传递 Block 时</li>
</ol>
<h2 id="4-Block-循环引用"><a href="#4-Block-循环引用" class="headerlink" title="4 Block 循环引用"></a>4 Block 循环引用</h2><p>Block 循环引用，是在编程中非常常见的问题，甚至很多时候，我们并不知道发生了循环引用，直到我们突然某一天发现『怎么这个对象没有调用 delloc』，才意识到有问题存在。</p>
<p>在『Block 存储域』中也说明了 Block 在 copy 后对 __block 对象会 retain 一次。</p>
<p>那么对于如下情况就会发生循环引用：</p>
<p><strong>block_retain_cycle:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) blk_t blk;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    _blk = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;self = %@&quot;</span>, <span class="keyword">self</span>);&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ dealloc&quot;</span>, <span class="keyword">self</span>.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">id</span> myobj = [[MyObject alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, myobj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 self -&gt; blk，blk -&gt; self，双方都无法释放。</p>
<p>但要注意的是，对于以下情况，同样会发生循环引用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">block_retain_cycle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) blk_t blk;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是多加的一句</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面是多加的一句</span></span><br><span class="line">    _blk = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;self = %@&quot;</span>, _obj);&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ dealloc&quot;</span>, <span class="keyword">self</span>.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">id</span> myobj = [[MyObject alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, myobj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是由于 self -&gt; obj，self -&gt; blk，blk -&gt; obj。这种情况是非常容易被忽视的。</p>
<h2 id="5-重审问题"><a href="#5-重审问题" class="headerlink" title="5 重审问题"></a>5 重审问题</h2><p>我们再来看看最初的几个小题目：</p>
<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-05.png" alt="Block 的三道测试题"></p>
<ol>
<li><p>第一题：</p>
<p>由于 Block 捕获瞬间值，所以输出为 <code>in block val = 0</code></p>
</li>
<li><p>第二题：</p>
<p>由于 <code>val</code> 为 __block，外部更改会影响到内部访问，所以输出为 <code>in block val = 1</code></p>
</li>
<li><p>第三题：</p>
<p>和第二题类似，<code>val = 1</code> 能影响到 Block 内部访问，所以先输出 <code>in block val = 1</code>，之后在     Block 内部更改 <code>val</code> 值，再次访问时输出 <code>after block val = 2</code>。</p>
</li>
</ol>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><p>我写这篇文章是在我阅读了『Objective-C高级编程 iOS与OS X多线程和内存管理』一书之后，博文中也有很内容源于『Objective-C高级编程 iOS与OS X多线程和内存管理』。</p>
<p>非常向大家推荐此书。这本书里记录了关于 iOS 内存管理的深入内容。但要注意的是，此书中的多处知识点并不是很详细，需要你以拓展的心态去学习。在有解释不详细的地方，自己主动去探索，去拓展，找更多的资料，最后，你会发现你对 iOS 内存管理有了更多的深入的理解。</p>
<p>对于文章中的测试代码，全部在<a target="_blank" rel="noopener" href="https://github.com/summertian4/iOS-ObjectiveC/tree/master/ObjcMemory">这里</a>。</p>
<hr>
<p>有什么问题都可以在博文后面留言，或者微博上私信我。</p>
<p>博主是 iOS 妹子一枚。</p>
<p>希望大家一起进步。</p>
<p>我的微博：<a target="_blank" rel="noopener" href="http://weibo.com/coderfish/">LottyLotty周小鱼</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/iOS%E8%BF%9B%E9%98%B6/" rel="tag"># iOS进阶</a>
              <a href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%BC%95%E7%94%A8/" rel="tag"># 内存与引用</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/02/07/%E6%89%BE%E5%9B%9E%E4%B8%A2%E5%A4%B1%E7%9A%84-Github-%E8%A1%80%E6%B3%AA%E5%8F%B2%EF%BC%88%E8%B0%A8%E6%85%8E%E4%BF%9D%E7%AE%A1-2FA-%E9%AA%8C%E8%AF%81%EF%BC%89/" rel="prev" title="找回丢失的 Github（谨慎保管 2FA 验证）">
      <i class="fa fa-chevron-left"></i> 找回丢失的 Github（谨慎保管 2FA 验证）
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/02/15/Advanced-iOS-Study-objc-Memory-2/" rel="next" title="iOS进阶——iOS（Objective-C）内存管理·二">
      iOS进阶——iOS（Objective-C）内存管理·二 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AF%87-iOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">第一篇 iOS 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BC%BC%E4%B9%8E%E6%AF%8F%E4%B8%AA%E4%BA%BA%E5%9C%A8%E5%AD%A6%E4%B9%A0-iOS-%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%83%BD%E8%80%83%E8%99%91%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.</span> <span class="nav-text">1 似乎每个人在学习 iOS 过程中都考虑过的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%8E-ARC-%E8%AF%B4%E8%B5%B7"><span class="nav-number">1.2.</span> <span class="nav-text">2 从 ARC 说起</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93"><span class="nav-number">1.3.</span> <span class="nav-text">3 你需要知道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-alloc-retain-release-dealloc-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.</span> <span class="nav-text">4 alloc retain release dealloc 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-GNU-alloc"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 GNU - alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-GNU-retain"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 GNU - retain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-GNU-release"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 GNU - release</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-GNU-dealloc"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 GNU - dealloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-Apple-%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5 Apple 实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-autorelease-%E5%92%8C-autorelaesepool"><span class="nav-number">1.5.</span> <span class="nav-text">5 autorelease 和 autorelaesepool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-unsafe-unretained"><span class="nav-number">1.6.</span> <span class="nav-text">6 __unsafe_unretained</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AF%87-Block"><span class="nav-number">2.</span> <span class="nav-text">第二篇 Block</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Block-%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%84%E5%88%99"><span class="nav-number">2.1.</span> <span class="nav-text">1 Block 使用的简单规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Block-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">2 Block 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Block-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1 Block 基本实现剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Block-%E6%88%AA%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E7%9E%AC%E9%97%B4%E5%80%BC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2 Block 截获外部变量瞬间值的实现剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-block-%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.3 __block 变量的访问实现剖析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Block-%E7%9A%84%E5%AD%98%E5%82%A8%E5%9F%9F"><span class="nav-number">2.3.</span> <span class="nav-text">3 Block 的存储域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Block-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="nav-number">2.4.</span> <span class="nav-text">4 Block 循环引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%87%8D%E5%AE%A1%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.</span> <span class="nav-text">5 重审问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Other"><span class="nav-number">3.</span> <span class="nav-text">Other</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Author"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://blog.imallen.wang" title="http://blog.imallen.wang" rel="noopener" target="_blank">王龙海の博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://mafei.me" title="http://mafei.me" rel="noopener" target="_blank">马飞の博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.jianshu.com/users/86344ec5bfe7/latest_articles" title="http://www.jianshu.com/users/86344ec5bfe7/latest_articles" rel="noopener" target="_blank">Afluyの博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://hyyy.me" title="http://hyyy.me" rel="noopener" target="_blank">yuanの博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.6ag.cn" title="https://blog.6ag.cn" rel="noopener" target="_blank">六阿哥の博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.eyrefree.org/" title="https://www.eyrefree.org/" rel="noopener" target="_blank">EyreFreeの博客</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">苏ICP备19008876号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Author</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
