<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  <icon>https://www.gravatar.com/avatar/2ee3f493659e4e96f60b76582c2e7874</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lottyzhou.com/"/>
  <updated>2021-10-11T09:40:59.402Z</updated>
  <id>http://lottyzhou.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一周阅读列表-2019</title>
    <link href="http://lottyzhou.com/2019/04/02/%E4%B8%80%E5%91%A8%E9%98%85%E8%AF%BB%E5%88%97%E8%A1%A8-2019/"/>
    <id>http://lottyzhou.com/2019/04/02/一周阅读列表-2019/</id>
    <published>2019-04-02T10:16:00.000Z</published>
    <updated>2021-10-11T09:40:59.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019-年-1-月"><a href="#2019-年-1-月" class="headerlink" title="2019 年 1 月"></a>2019 年 1 月</h1><p><del><a href="https://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">What is a meta-class in Objective-C?</a></del></p><span id="more"></span><p><del><a href="https://blog.cnbang.net/tech/3354/">iOS 开发技术栈与进阶</a></del></p><p><del><a href="https://github.com/CocoaPods/CocoaPods/blob/21f6830867cc9425bf0bac3284ff9535357fa177/lib/cocoapods/generator/file_list.rb">cocoapods Copy Pods Resources 部分源码</a></del></p><p><del><a href="https://towardsdatascience.com/how-to-write-python-command-line-interfaces-like-a-pro-f782450caf0d">How to Write Python Command-Line Interfaces like a Pro</a></del></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2019-年-1-月&quot;&gt;&lt;a href=&quot;#2019-年-1-月&quot; class=&quot;headerlink&quot; title=&quot;2019 年 1 月&quot;&gt;&lt;/a&gt;2019 年 1 月&lt;/h1&gt;&lt;p&gt;&lt;del&gt;&lt;a href=&quot;https://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html&quot;&gt;What is a meta-class in Objective-C?&lt;/a&gt;&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Other" scheme="http://lottyzhou.com/categories/Other/"/>
    
      <category term="阅读列表" scheme="http://lottyzhou.com/categories/Other/%E9%98%85%E8%AF%BB%E5%88%97%E8%A1%A8/"/>
    
    
      <category term="Other" scheme="http://lottyzhou.com/tags/Other/"/>
    
      <category term="ReadList" scheme="http://lottyzhou.com/tags/ReadList/"/>
    
  </entry>
  
  <entry>
    <title>iOS——隐形水印的实现和『颜色加深』算法</title>
    <link href="http://lottyzhou.com/2019/02/20/ios-invisible-watermark/"/>
    <id>http://lottyzhou.com/2019/02/20/ios-invisible-watermark/</id>
    <published>2019-02-20T09:17:23.000Z</published>
    <updated>2021-10-11T09:40:59.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS——隐形水印的算法和实现"><a href="#iOS——隐形水印的算法和实现" class="headerlink" title="iOS——隐形水印的算法和实现"></a>iOS——隐形水印的算法和实现</h1><p>很多 APP 都在敏感页面有水印，主要为了应对舆情时可以追踪图片来源，一般在水印上都会有员工或用户 ID 和昵称。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ios-invisible-watermark-01.png" alt=""></p><span id="more"></span><p>水印的用途总结有亮点：</p><ol><li>追踪来源</li><li>威慑作用</li></ol><p>威慑作用是指当用户看到水印时，会自觉避免违法传舆行为。</p><p>但是，当不需要威慑作用时，例如，为了保持应用或者图片的美观，显形的水印似乎不是那么必要，这时候可以考虑使用隐形水印。</p><p>最近在同事在知乎上看到一种水印。</p><p>如下图，表面似乎没有什么水印</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ios-invisible-watermark-02.png" alt=""></p><p>但通过 PS 的混色模式处理后，隐形水印就显示出来了</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ios-invisible-watermark-03.png" alt=""></p><p>具体处理方式是</p><ol><li>在原图上图层添加全黑图层</li><li>全黑图层选择『颜色加深』</li></ol><p>到此为止，我对 PS 的算法产生了好奇，混色模式是常用工具，但是以前没有注意过公式。</p><h2 id="颜色加深混色模式"><a href="#颜色加深混色模式" class="headerlink" title="颜色加深混色模式"></a>颜色加深混色模式</h2><p>PS 的混色模式，其实是底图和混色层的每个像素点，经过一系列计算后得到的结果层。</p><p>翻阅了一系列资料后我发现，现有的公式都是不正确的，有些热门文章里也不对。而 PS 官方文档只对几种混色模式进行了介绍，而并没有给出公式。</p><blockquote><p>查看每个通道中的颜色信息，并通过增加二者之间的对比度使基色变暗以反映出混合色。与白色混合后不产生变化。</p><p><a href="https://helpx.adobe.com/cn/photoshop/using/blending-modes.html">https://helpx.adobe.com/cn/photoshop/using/blending-modes.html</a></p></blockquote><p>比较多的是这套公式：</p><blockquote><p><strong>结果色 = 基色-[（255-基色）×（255-混合色）]/混合色</strong></p></blockquote><blockquote><p>公式中（255-基色）和（255-混合色）分别是基色和混合色的反相。 </p><ol><li>若混合色为0（黑色），（基色×混合色）为0，得到的数值为一相个负值，归为0，所以不论基色为何值均为0。</li><li>当混合色的色阶值是255（白色）时，混合色同基色。</li></ol></blockquote><p>基本查到的算法公式都有一个致命问题，公式都标明了，<strong>任何颜色和黑色混色结果为黑色，这显然与上文中 PS 处理结果不符合</strong>。如果按照这套理论，整个图片都应该黑了。</p><p>最后我试出来一个接近的方案是，</p><ol><li><strong>结果色 = 基色 —（基色反相×混合色反相）/ 混合色</strong></li><li><strong>如混色层为黑色，则认为 RGB 为 (255, 255, 255)，即非常深的灰色</strong></li></ol><p>这个公式可以基本实现 PS 中的颜色加深效果。<strong>可以将浅色变深，越浅越深</strong>。</p><h2 id="隐形水印的实现"><a href="#隐形水印的实现" class="headerlink" title="隐形水印的实现"></a>隐形水印的实现</h2><h3 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h3><p>首先介绍 iOS 中的基本图像处理方式：</p><ol><li>获取图片的所有像素点</li><li>改变指针指向的像素信息</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)addWatermark:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">                     text:(<span class="built_in">NSString</span> *)text &#123;</span><br><span class="line">    <span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *attributes = @&#123;<span class="built_in">NSFontAttributeName</span>: font,</span><br><span class="line">                                 <span class="built_in">NSForegroundColorAttributeName</span>: [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0</span></span><br><span class="line">                                                                                 green:<span class="number">0</span></span><br><span class="line">                                                                                  blue:<span class="number">0</span></span><br><span class="line">                                                                                 alpha:<span class="number">0.01</span>]&#125;;</span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = [image <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">CGFloat</span> x = <span class="number">0.0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> y = <span class="number">0.0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> idx0 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> idx1 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGSize</span> textSize = [text sizeWithAttributes:attributes];</span><br><span class="line">    <span class="keyword">while</span> (y &lt; image.size.height) &#123;</span><br><span class="line">        y = (textSize.height * <span class="number">2</span>) * idx1;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; image.size.width) &#123;</span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                x = (textSize.width * <span class="number">2</span>) * idx0;</span><br><span class="line">                newImage = [<span class="keyword">self</span> addWatermark:newImage</span><br><span class="line">                                         text:text</span><br><span class="line">                                    textPoint:<span class="built_in">CGPointMake</span>(x, y)</span><br><span class="line">                             attributedString:attributes];</span><br><span class="line">            &#125;</span><br><span class="line">            idx0 ++;</span><br><span class="line">        &#125;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        idx0 = <span class="number">0</span>;</span><br><span class="line">        idx1 ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)addWatermark:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">                     text:(<span class="built_in">NSString</span> *)text</span><br><span class="line">                textPoint:(<span class="built_in">CGPoint</span>)point</span><br><span class="line">         attributedString:(<span class="built_in">NSDictionary</span> *)attributes &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(image.size);</span><br><span class="line">    [image drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>, image.size.width, image.size.height)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGSize</span> textSize = [text sizeWithAttributes:attributes];</span><br><span class="line">    [text drawInRect:<span class="built_in">CGRectMake</span>(point.x, point.y, textSize.width, textSize.height) withAttributes:attributes];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示水印"><a href="#显示水印" class="headerlink" title="显示水印"></a>显示水印</h3><p>通过上文提到的公式，可以让水印显示。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)visibleWatermark:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="comment">// 1. Get the raw pixels of the image</span></span><br><span class="line">    <span class="comment">// 定义 32位整形指针 *inputPixels</span></span><br><span class="line">    <span class="built_in">UInt32</span> * inputPixels;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换图片为CGImageRef,获取参数：长宽高，每个像素的字节数（4），每个R的比特数</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> inputCGImage = [image <span class="built_in">CGImage</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputWidth = <span class="built_in">CGImageGetWidth</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputHeight = <span class="built_in">CGImageGetHeight</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每行字节数</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> inputBytesPerRow = bytesPerPixel * inputWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开辟内存区域,指向首像素地址</span></span><br><span class="line">    inputPixels = (<span class="built_in">UInt32</span> *)calloc(inputHeight * inputWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指针，前面的参数，创建像素层</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(inputPixels, inputWidth, inputHeight,</span><br><span class="line">                                                 bitsPerComponent, inputBytesPerRow, colorSpace,</span><br><span class="line">                                                 kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    <span class="comment">//根据目前像素在界面绘制图像</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, inputWidth, inputHeight), inputCGImage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 像素处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inputHeight; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputWidth; i++) &#123;</span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                <span class="built_in">UInt32</span> *currentPixel = inputPixels + (j * inputWidth) + i;</span><br><span class="line">                <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line">                <span class="built_in">UInt32</span> thisR,thisG,thisB,thisA;</span><br><span class="line">                <span class="comment">// 这里直接移位获得RBGA的值,以及输出写的非常好！</span></span><br><span class="line">                thisR = R(color);</span><br><span class="line">                thisG = G(color);</span><br><span class="line">                thisB = B(color);</span><br><span class="line">                thisA = A(color);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">UInt32</span> newR,newG,newB;</span><br><span class="line">                newR = [<span class="keyword">self</span> mixedCalculation:thisR];</span><br><span class="line">                newG = [<span class="keyword">self</span> mixedCalculation:thisG];</span><br><span class="line">                newB = [<span class="keyword">self</span> mixedCalculation:thisB];</span><br><span class="line"></span><br><span class="line">                *currentPixel = RGBAMake(newR,</span><br><span class="line">                                         newG,</span><br><span class="line">                                         newB,</span><br><span class="line">                                         thisA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新图</span></span><br><span class="line">    <span class="comment">// 4. Create a new UIImage</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> newCGImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="built_in">UIImage</span> * processedImage = [<span class="built_in">UIImage</span> imageWithCGImage:newCGImage];</span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="comment">// 5. Cleanup!</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    free(inputPixels);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processedImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">int</span>)mixedCalculation:(<span class="keyword">int</span>)originValue &#123;</span><br><span class="line">    <span class="comment">// 结果色 = 基色 —（基色反相×混合色反相）/ 混合色</span></span><br><span class="line">    <span class="keyword">int</span> mixValue = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> resultValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mixValue == <span class="number">0</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resultValue = originValue - (<span class="number">255</span> - originValue) * (<span class="number">255</span> - mixValue) / mixValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resultValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码和开源库"><a href="#代码和开源库" class="headerlink" title="代码和开源库"></a>代码和开源库</h2><p>为了方便使用，写了一个开源库，封装的很实用，附带 DEMO</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ios-invisible-watermark-04.gif" alt=""></p><p><a href="https://github.com/summertian4/ZLYInvisibleWatermark">ZLYInvisibleWatermark</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS——隐形水印的算法和实现&quot;&gt;&lt;a href=&quot;#iOS——隐形水印的算法和实现&quot; class=&quot;headerlink&quot; title=&quot;iOS——隐形水印的算法和实现&quot;&gt;&lt;/a&gt;iOS——隐形水印的算法和实现&lt;/h1&gt;&lt;p&gt;很多 APP 都在敏感页面有水印，主要为了应对舆情时可以追踪图片来源，一般在水印上都会有员工或用户 ID 和昵称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ios-invisible-watermark-01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://lottyzhou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://lottyzhou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>记一次删库到数据恢复</title>
    <link href="http://lottyzhou.com/2018/07/09/data-restoration/"/>
    <id>http://lottyzhou.com/2018/07/09/data-restoration/</id>
    <published>2018-07-09T07:17:11.000Z</published>
    <updated>2021-10-11T09:40:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次删库到数据恢复"><a href="#记一次删库到数据恢复" class="headerlink" title="记一次删库到数据恢复"></a>记一次删库到数据恢复</h1><p>熟悉的朋友可能知道，进入架构组后，今年一直在为团队做各种开发辅助工具，其中包括一个服务器。</p><p>最近这个服务器也上线有三月多了，也不断收集了很多数据，包括用户的各种行为操作、API 调用数据等等。</p><p>在最近的一次升级中，我调整了源码的目录结构，脑子一抽删除了数据库。</p><span id="more"></span><p>于是就开始为期一天的数据恢复过程，最后的结果是很悲剧，好在影响不大，可以放到后面讲。</p><h2 id="文件找回"><a href="#文件找回" class="headerlink" title="文件找回"></a>文件找回</h2><p>需要说明的是，因为是小微服务，采用的是最简单的 SQLite 数据库。SQLite 区分其他的数据库的明显地方是，它只提供最基本的数据服务，但并不启用端口监听，可以简单的认为这就是个文件，如果删除了，就和普通文件从系统中消失是一样的。所以通常如果使用 SQLite 保存数据需要自行定期备份。</p><p>所以这次的博文虽然叫『删库』，但实际上可以简单的理解成<strong>文件找回</strong>。</p><h2 id="rm-rf"><a href="#rm-rf" class="headerlink" title="rm -rf"></a>rm -rf</h2><p>我在误删时，是使用 rm -rf 命令，这当然是个耳熟能详的恶名远扬的命令（以至于我当时请教后端大佬的时候，后端大佬的反应是『哦，你也终于删一次库啦』）</p><p>rm 是 linux 系统的用于『删除文件或目录』的命令</p><p><code>-f</code> 标识表示 force，即：</p><blockquote><p>在除去有写保护的文件前不提示。</p></blockquote><p><code>-r</code> 标识表示：</p><blockquote><p>当 File 参数为目录时允许循环的删除目录及其内容</p></blockquote><p><strong>FYI</strong>: <a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_71/com.ibm.aix.cmds4/rm.htm">更多参考</a></p><h2 id="extundelete-与磁盘存储"><a href="#extundelete-与磁盘存储" class="headerlink" title="extundelete 与磁盘存储"></a>extundelete 与磁盘存储</h2><p><a href="http://extundelete.sourceforge.net/">extundelete</a> 是 linux 系统下一个有力的数据恢复工具。extundelete使用存储在分区日志中的信息来尝试恢复已从分区中删除的文件。</p><p>我们稍微复习一下计算机基础知识：</p><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>硬盘是一种采用磁介质的数据存储设备，数据『物理意义上的』存储在若干个磁盘片上。在磁盘片的每一面上，以转动轴为轴心、以一定的磁密度为间隔的若干个同心圆就被划分成磁道（track），每个磁道又被划分为若干个扇区（sector）。</p><h3 id="主引导扇区和分区表"><a href="#主引导扇区和分区表" class="headerlink" title="主引导扇区和分区表"></a>主引导扇区和分区表</h3><p>硬盘的0磁道0柱面1扇区是主引导扇区位，包括硬盘主引导记录MBR（Main Boot Record）和<strong>分区表</strong>DPT（Disk Partition Table）。<strong>操作系统通过分区表把硬盘划分为若干个分区，然后再在每个分区里面创建文件系统，写入数据文件。</strong></p><h3 id="分区日志"><a href="#分区日志" class="headerlink" title="分区日志"></a>分区日志</h3><p>分区日志系统是一个文件系统，用于修复由于计算机关闭不当而导致的任何不一致。这种关闭通常是由于电源中断或软件问题造成的。即记录了分区的数据读写操作。</p><p>通过这些日志，可以知道分区中的历史操作。</p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>具体的数据存储原理内容比较多，这里不做赘述。为了便于理解，我在此理解为：</p><blockquote><p>操作系统中的文件在硬盘的表现形式是在硬盘一片数据区域记录二进制信息，并由操作系统的一个指针指向该物理地址<br>而操作系统级别的『删除文件』，即删除这个『指针』<br>原来的物理地址内没有『指针』指向后，相当于被释放，当操作系统需要时，可以被复写上新的数据。</p></blockquote><p>由此观得，extundelete 通过查阅分区日志，找到被删除的指针，告诉用户，可以尝试恢复哪些数据。</p><p>但由于操作系统随时可以复写空余磁盘，所以如果要恢复的物理地址已经被改写，数据将无法找回。</p><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><p>为了脱敏，我使用我自己的服务器，具体记录一下文件恢复的过程。</p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul><li>CentOS 7.4 64位</li><li>文件目录: /root/Sparrow/db.sqlite3</li></ul><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rm -rf db.sqlite3</span></span><br></pre></td></tr></table></figure><h4 id="安装-extundelete"><a href="#安装-extundelete" class="headerlink" title="安装 extundelete"></a>安装 extundelete</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install extundelete -y</span></span><br></pre></td></tr></table></figure><h4 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h4><p>首先我们去查询这个文件或上级文件夹所处的磁盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> df /root/Sparrow/</span></span><br><span class="line">文件系统          1K-块    已用     可用 已用% 挂载点</span><br><span class="line">/dev/vda1      41151808 2614640 36423736    7% /</span><br></pre></td></tr></table></figure><p>找到后首要的是挂载磁盘，<strong>挂载后磁盘将不会被继续写入，保护现场</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/vda1</span><br></pre></td></tr></table></figure><p><code>/dev/vda1</code> 就是文件所在的磁盘。</p><p>不挂载也是可以的，这样会导致磁盘可能会被其他的进程写入数据，从而抹掉原来的数据，所以我最后没有找回文件就是因为没有及时挂载。</p><h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><p>inode 是 linux 系统下文件或者文件夹的标识。通过 <code>ls –id</code> 就可以看到。</p><p>读取根目录的 inode 值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls -id /</span></span><br><span class="line">2 /</span><br></pre></td></tr></table></figure><p>现在我们知道磁盘根目录的 inode 是 2。</p><h4 id="extundelete-查询可恢复的数据信息"><a href="#extundelete-查询可恢复的数据信息" class="headerlink" title="extundelete 查询可恢复的数据信息"></a>extundelete 查询可恢复的数据信息</h4><p>先查询磁盘根目录下的可恢复信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> extundelete /dev/vda1 --inode 2</span></span><br></pre></td></tr></table></figure><p>执行时，如果没有挂载磁盘，会提示。</p><p>得到结果：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_data-restoration-01.png" alt=""></p><p>重点盘红圈内，看到 <code>root</code> 的 inode 是 131073，继续查询 <code>/dev</code> 的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> extundelete /dev/vda1 --inode 131073</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_data-restoration-02.png" alt=""></p><p>看到 <code>/Sparrow</code>  是 262194，继续查询 <code>/dev</code> 的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> extundelete /dev/vda1 --inode 262194</span></span><br></pre></td></tr></table></figure><p>最终找到了删除信息：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_data-restoration-03.png" alt=""></p><p>可以看到 db.sqlite3 被标识为 <code>Deleted</code>。</p><h4 id="extundelete-恢复数据"><a href="#extundelete-恢复数据" class="headerlink" title="extundelete 恢复数据"></a>extundelete 恢复数据</h4><p>执行 –restore-directory 恢复指定目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> extundelete /dev/vda1 --restore-directory /root/Sparrow/db.sqlite3</span></span><br></pre></td></tr></table></figure><p>或执行 –restore-all 恢复所有可恢复的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> extundelete /dev/vda1 --restore-all</span></span><br></pre></td></tr></table></figure><p>执行结束后，会在当前路径下，生成一个 <code>RECOVERED_FILES</code> 文件夹，里面有所有被恢复的文件。</p><p>如果磁盘已经被读写，无法恢复，会提示类似信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Loading filesystem metadata ... 320 groups loaded.</span><br><span class="line">Loading journal descriptors ... 27896 descriptors loaded.</span><br><span class="line">Searching for recoverable inodes in directory /root/Sparrow/db.sqlite3 ...</span><br><span class="line">120 recoverable inodes found.</span><br><span class="line">Looking through the directory structure for deleted files ...</span><br><span class="line">120 recoverable inodes still lost.</span><br><span class="line">No files were undeleted.</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这一次的『删库』事件，给我了一个很好的教训。服务器的数据一定要及时备份或做好容灾，防止丢失。同时，这次也借此机会进行学习了文件恢复。</p><p>当然，希望大家都不会出现我这样的悲剧 😂。</p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;记一次删库到数据恢复&quot;&gt;&lt;a href=&quot;#记一次删库到数据恢复&quot; class=&quot;headerlink&quot; title=&quot;记一次删库到数据恢复&quot;&gt;&lt;/a&gt;记一次删库到数据恢复&lt;/h1&gt;&lt;p&gt;熟悉的朋友可能知道，进入架构组后，今年一直在为团队做各种开发辅助工具，其中包括一个服务器。&lt;/p&gt;
&lt;p&gt;最近这个服务器也上线有三月多了，也不断收集了很多数据，包括用户的各种行为操作、API 调用数据等等。&lt;/p&gt;
&lt;p&gt;在最近的一次升级中，我调整了源码的目录结构，脑子一抽删除了数据库。&lt;/p&gt;
    
    </summary>
    
      <category term="Other" scheme="http://lottyzhou.com/categories/Other/"/>
    
    
      <category term="后端" scheme="http://lottyzhou.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="linux" scheme="http://lottyzhou.com/tags/linux/"/>
    
      <category term="数据库" scheme="http://lottyzhou.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 流量监控分析</title>
    <link href="http://lottyzhou.com/2018/05/30/ios-network-traffic/"/>
    <id>http://lottyzhou.com/2018/05/30/ios-network-traffic/</id>
    <published>2018-05-30T06:02:16.000Z</published>
    <updated>2021-10-11T09:40:59.401Z</updated>
    
    <content type="html"><![CDATA[<p>由于骑手不能随时处在有 WIFI 的状态，流量变成了很敏感的问题，为了精确到每个 API 的流量，进行针对性的优化，开始在我们的 APM 中添加流量监控功能。</p><p>本文将记录自己做流量监控方面的总结。其中包括了非常多的<strong>踩坑经验</strong>，和现有一些<strong>方案的缺陷分析</strong>，对我来说是一个非常有意义的过程。</p><blockquote><p>干货预警🤣请做好读大量代码的准备😂😂😂</p></blockquote><span id="more"></span><h1 id="一、资料收集"><a href="#一、资料收集" class="headerlink" title="一、资料收集"></a>一、资料收集</h1><p>就目前来说，各家大厂基本都有自己的 APM（包括我们公司其实之前也有一套 APM，但是由于各个事业部的需求不同，尚不能完全满足物流平台的需要）但各家大厂目前开源的 APM 项目却不多，当然也可能是由于各家的业务场景差异比较大且对数据的后续处理不同。</p><p>所以本次在查阅资料阶段，没有太多的源码可选参考，但有不少文章。</p><p>以下是一些本次开发过程中参考的文章和开源库：</p><ol><li><a href="https://github.com/aozhimin/iOS-Monitor-Platform">iOS-Monitor-Platform</a></li><li><a href="https://github.com/zixun/GodEye">GodEye</a></li><li><a href="https://github.com/zixun/NetworkEye">NetworkEye</a></li><li><a href="https://tech.meituan.com/hertz.html">移动端性能监控方案Hertz</a></li><li><a href="http://liujinlongxa.com/2016/12/20/%E4%BD%BF%E7%94%A8NSURLProtocol%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/">使用NSURLProtocol注意的一些问题</a></li><li><a href="https://github.com/Draveness/analyze/blob/master/contents/OHHTTPStubs/iOS%20%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8%20NSURLProtocol%20%E6%8B%A6%E6%88%AA%20HTTP%20%E8%AF%B7%E6%B1%82.md">iOS 开发中使用 NSURLProtocol 拦截 HTTP 请求</a></li><li><a href="https://www.jianshu.com/p/49e7282e888d">获取NSURLResponse的HTTPVersion</a></li></ol><p>但以上这些资料对我们的需求都有不足之处：</p><p><strong>1. Request 和 Response 记在同一条记录</strong></p><p>在实际的网络请求中 Request 和 Response 不一定是成对的，如果网络断开、或者突然关闭进程，都会导致不成对现象，如果将 Request 和 Response 记录在同一条数据，将会对统计造成偏差</p><p><strong>2. 上行流量记录不精准</strong></p><p>主要的原因有三大类：</p><ol><li><strong>直接忽略了 Header 和 Line 部分</strong></li><li><strong>忽略了 Cookie 部分</strong>，实际上，臃肿的 Cookie 也是消耗流量的一部分</li><li>body 部分的字节大小计算直接使用了 <code>HTTPBody.length</code> 不够准确</li></ol><p><strong>3. 下行流量记录不精准</strong></p><p>主要原因有：</p><ol><li><strong>直接忽略了 Header 和 Status-Line 部分</strong></li><li>body 部分的字节大小计算直接使用了 <code>expectedContentLength</code> 不够准确</li><li><strong>忽略了 gzip 压缩</strong>，在实际网络编程中，往往都使用了 gzip 来进行数据压缩，而系统提供的一些监听方法，返回的 NSData 实际是解压过的，如果直接统计字节数会造成大量偏差</li></ol><p>后文将详细讲述。</p><h1 id="二、需求"><a href="#二、需求" class="headerlink" title="二、需求"></a>二、需求</h1><p>先简单罗列我们的需求：</p><ol><li>Request 基本信息记录</li><li>上行流量</li><li>Reponse 基本信息记录</li><li>下行流量</li><li>数据归类：按照 host 和 path 归类，一条记录记载改 host/path 的 <strong>Request 记录数</strong>，<strong>Response 记录数</strong>，<strong>Reqeust 总流量（上行流量）</strong>，<strong>Reponse 总流量（下行流量）</strong></li></ol><p><strong>我们的侧重点是流量统计，为了方便分析 APP 使用中哪些 API 消耗流量多。所以对上行、下行流量都需要尽量准确记录。</strong></p><p>最终的数据库表展示：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ios-network-traffic-01.png" alt=""></p><p>type 字段表示的是『该条记录是 Request 还是 Response』，几个 length 分别记录了流量的各个细节，包括：总字节数、Line 字节数、Header 字节数、Body 字节数。</p><p>最后的界面展示类似于：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ios-network-traffic-02.png" alt=""></p><h1 id="三、分析现有资料"><a href="#三、分析现有资料" class="headerlink" title="三、分析现有资料"></a>三、分析现有资料</h1><p>现在分析一下上面收集到的资料有哪些不足之处。</p><p><a href="https://github.com/zixun/GodEye"><strong>GodEye</strong></a> | <a href="https://github.com/zixun/NetworkEye"><strong>NetworkEye</strong></a>：</p><p>NetworkEye 是 GodEye 的一部分，可以单独拆出来使用的网络监控库。</p><p>查阅两者的源码后发现，NetworkEye</p><ol><li>仅仅记录了 Reponse 的流量</li><li>通过 expectedContentLength 记录是不准确的（后面将会说到）</li><li>仅仅记录了总和，这对我们来说是无意义的，不能分析出哪条 API 流量使用多</li></ol><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ios-network-traffic-03.png" alt=""></p><p><a href="https://tech.meituan.com/hertz.html"><strong>移动端性能监控方案Hertz</strong></a>：</p><p>美团的文章中展示几个代码片段：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.data = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (connection.originalRequest) &#123;</span><br><span class="line">        WMNetworkUsageDataInfo *info = [[WMNetworkUsageDataInfo alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.connectionEndTime = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970];</span><br><span class="line">        info.responseSize = <span class="keyword">self</span>.responseDataLength;</span><br><span class="line">        info.requestSize = connection.originalRequest.HTTPBody.length;</span><br><span class="line">        info.contentType = [WMNetworkUsageURLProtocol getContentTypeByURL:connection.originalRequest.URL andMIMEType:<span class="keyword">self</span>.MIMEType];</span><br><span class="line">    [[WMNetworkMeter sharedInstance] setLastDataInfo:info];</span><br><span class="line">    [[WMNetworkUsageManager sharedManager] recordNetworkUsageDataInfo:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>connectionDidFinishLoading</code> 中记录了整个网络请求结束的时间、 response 数据大小、request 数据大小以及一些其他数据。</p><p>总体来说是比较详细的，但是这里并没有给出 <code>self.responseDataLength</code> 的具体逻辑，另外 <code>connection.originalRequest.HTTPBody.length</code> 仅仅是 Request body 的大小。</p><p><a href="https://github.com/aozhimin/iOS-Monitor-Platform"><strong>iOS-Monitor-Platform</strong></a>：</p><p>这篇文章比较详细的介绍了整个 APM 制作的过程，贴出了很多代码段，应该说非常详细也极具参考价值。</p><p>在流量部分，也分别针对了上行流量、下行流量进行了区分，但其中：</p><ol><li>没有处理 gzip 压缩情况</li><li>对 Header 计算大小的方式是 Dictionary 转 NSData，然而实际上头部并不是 Json 格式（这块我觉得很迷，因为作者特意展示了 HTTP 报文组成）</li></ol><h1 id="四、动手自己做"><a href="#四、动手自己做" class="headerlink" title="四、动手自己做"></a>四、动手自己做</h1><h2 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h2><p>为了更好的让大家了解 HTTP 流量计算的一些关键信息，首先要了解 HTTP 报文的组成。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ios-network-traffic-04.png" alt=""></p><p>再来随便抓个包具体看看：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ios-network-traffic-05.png" alt=""></p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ios-network-traffic-06.png" alt=""></p><h2 id="iOS-下的网络监控"><a href="#iOS-下的网络监控" class="headerlink" title="iOS 下的网络监控"></a>iOS 下的网络监控</h2><p>这块我采用的大家耳熟能详的 <code>NSURLProtocol</code>，<code>NSURLProtocol</code> 方式除了通过 CFNetwork 发出的网络请求，全部都可以拦截到。</p><p><a href="https://developer.apple.com/documentation/foundation/nsurlprotocol?language=occ">Apple 文档</a>中对 <code>NSURLProtocol</code> 有非常详细的描述和使用介绍</p><blockquote><p>An abstract class that handles the loading of protocol-specific URL data.</p></blockquote><p>如果想更详细的了解 <code>NSURLProtocol</code>，也可以看大佐的<a href="https://github.com/Draveness/analyze/blob/master/contents/OHHTTPStubs/iOS%20%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8%20NSURLProtocol%20%E6%8B%A6%E6%88%AA%20HTTP%20%E8%AF%B7%E6%B1%82.md">这篇文章</a></p><blockquote><p>在每一个 HTTP 请求开始时，URL 加载系统创建一个合适的 <code>NSURLProtocol</code> 对象处理对应的 URL 请求，而我们需要做的就是写一个继承自 <code>NSURLProtocol</code> 的类，并通过 <code>- registerClass:</code> 方法注册我们的协议类，然后 URL 加载系统就会在请求发出时使用我们创建的协议对象对该请求进行处理。</p></blockquote><p><code>NSURLProtocol</code> 是一个抽象类，需要做的第一步就是集成它，完成我们的自定义设置。</p><p>创建自己的 <code>DMURLProtocol</code>，为它添加几个属性并实现相关接口：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DMURLProtocol</span>() &lt;<span class="title">NSURLConnectionDelegate</span>, <span class="title">NSURLConnectionDataDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLConnection</span> *connection;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLRequest</span> *dm_request;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLResponse</span> *dm_response;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableData</span> *dm_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>canInitWithRequest</code> &amp; <code>canonicalRequestForRequest</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> DMHTTP = <span class="string">@&quot;LPDHTTP&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="keyword">if</span> (![request.URL.scheme isEqualToString:<span class="string">@&quot;http&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拦截过的不再拦截</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSURLProtocol</span> propertyForKey:LPDHTTP inRequest:request] ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [request mutableCopy];</span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES</span><br><span class="line">                        forKey:DMHTTP</span><br><span class="line">                     inRequest:mutableReqeust];</span><br><span class="line">    <span class="keyword">return</span> [mutableReqeust <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startLoading</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startLoading &#123;</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [[<span class="keyword">self</span> <span class="keyword">class</span>] canonicalRequestForRequest:<span class="keyword">self</span>.request];</span><br><span class="line">    <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">YES</span>];</span><br><span class="line">    <span class="keyword">self</span>.dm_request = <span class="keyword">self</span>.request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>didReceiveResponse</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageAllowed</span>];</span><br><span class="line">    <span class="keyword">self</span>.dm_response = response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>didReceiveData</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">    [<span class="keyword">self</span>.dm_data appendData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上部分是为了在单次 HTTP 请求中记录各个所需要属性。</p><h3 id="记录-Response-信息"><a href="#记录-Response-信息" class="headerlink" title="记录 Response 信息"></a>记录 Response 信息</h3><p>前面的代码实现了在网络请求过程中为 <code>dm_response</code> 和 <code>dm_data</code> 赋值，那么在 <code>stopLoading</code> 方法中，就可以分析 <code>dm_response</code> 和 <code>dm_data</code> 对象，获取下行流量等相关信息。</p><blockquote><p>需要说明的是，如果需要获得非常精准的流量，一般来说只有通过 Socket 层获取是最准确的，因为可以获取包括握手、挥手的数据大小。当然，我们的目的是为了分析 App 的耗流量 API，所以仅从应用层去分析也基本满足了我们的需要。</p></blockquote><p>上文中说到了报文的组成，那么按照报文所需要的内容获取。</p><h4 id="Status-Line"><a href="#Status-Line" class="headerlink" title="Status Line"></a>Status Line</h4><p>非常遗憾的是 <code>NSURLResponse</code> 没有接口能直接获取报文中的 Status Line，甚至连 HTTP Version 等组成 Status Line 内容的接口也没有。</p><p>最后，我通过转换到 CFNetwork 相关类，才拿到了 Status Line 的数据，这其中可能涉及到了读取私有 API</p><p>这里我为 <code>NSURLResponse</code> 添加了一个扩展：<code>NSURLResponse+DoggerMonitor</code>，并为其添加 <code>statusLineFromCF</code> 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CFHTTPMessageRef</span> (*DMURLResponseGetHTTPResponse)(<span class="built_in">CFURLRef</span> response);</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)statusLineFromCF &#123;</span><br><span class="line">    <span class="built_in">NSURLResponse</span> *response = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *statusLine = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 获取CFURLResponseGetHTTPResponse的函数实现</span></span><br><span class="line">    <span class="built_in">NSString</span> *funName = <span class="string">@&quot;CFURLResponseGetHTTPResponse&quot;</span>;</span><br><span class="line">    DMURLResponseGetHTTPResponse originURLResponseGetHTTPResponse =</span><br><span class="line">    dlsym(RTLD_DEFAULT, [funName UTF8String]);</span><br><span class="line"></span><br><span class="line">    SEL theSelector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;_CFURLResponse&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ([response respondsToSelector:theSelector] &amp;&amp;</span><br><span class="line">        <span class="literal">NULL</span> != originURLResponseGetHTTPResponse) &#123;</span><br><span class="line">        <span class="comment">// 获取NSURLResponse的_CFURLResponse</span></span><br><span class="line">        <span class="built_in">CFTypeRef</span> cfResponse = <span class="built_in">CFBridgingRetain</span>([response performSelector:theSelector]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != cfResponse) &#123;</span><br><span class="line">            <span class="comment">// 将CFURLResponseRef转化为CFHTTPMessageRef</span></span><br><span class="line">            <span class="built_in">CFHTTPMessageRef</span> messageRef = originURLResponseGetHTTPResponse(cfResponse);</span><br><span class="line">            statusLine = (__bridge_transfer <span class="built_in">NSString</span> *)<span class="built_in">CFHTTPMessageCopyResponseStatusLine</span>(messageRef);</span><br><span class="line">            <span class="built_in">CFRelease</span>(cfResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> statusLine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用私有 API <code>_CFURLResponse</code> 获得 <code>CFTypeRef</code> 再转换成 <code>CFHTTPMessageRef</code>，获取 Status Line。</p><p>再将其转换成 NSData 计算字节大小：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)dm_getLineLength &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *lineStr = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="built_in">NSHTTPURLResponse</span> *)<span class="keyword">self</span>;</span><br><span class="line">        lineStr = [<span class="keyword">self</span> statusLineFromCF];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSData</span> *lineData = [lineStr dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">return</span> lineData.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>通过 <code>httpResponse.allHeaderFields</code> 拿到 Header 字典，再拼接成报文的 key: value 格式，转换成 NSData 计算大小：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)dm_getHeadersLength &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> headersLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="built_in">NSHTTPURLResponse</span> *)<span class="keyword">self</span>;</span><br><span class="line">        <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *headerFields = httpResponse.allHeaderFields;</span><br><span class="line">        <span class="built_in">NSString</span> *headerStr = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> headerFields.allKeys) &#123;</span><br><span class="line">            headerStr = [headerStr stringByAppendingString:key];</span><br><span class="line">            headerStr = [headerStr stringByAppendingString:<span class="string">@&quot;: &quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> ([headerFields objectForKey:key]) &#123;</span><br><span class="line">                headerStr = [headerStr stringByAppendingString:headerFields[key]];</span><br><span class="line">            &#125;</span><br><span class="line">            headerStr = [headerStr stringByAppendingString:<span class="string">@&quot;\n&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSData</span> *headerData = [headerStr dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        headersLength = headerData.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headersLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><p>对于 Body 的计算，上文看到有些文章里采用的 <code>expectedContentLength</code> 或者去 <code>NSURLResponse</code> 对象的 <code>allHeaderFields</code> 中获取 <code>Content-Length</code> 值，其实都不够准确。</p><p>首先 API 文档中对 <code>expectedContentLength</code> 也有介绍是不准确的：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ios-network-traffic-07.png" alt=""></p><p>其次，HTTP 1.1 标准里也有介绍 <code>Content-Length</code> 字段不一定是每个 Response 都带有的，最重要的是，<strong><code>Content-Length</code> 只是表示 Body 部分的大小</strong>。</p><p>我的方式是，在前面代码中有写到，在 <code>didReceiveData</code> 中对 <code>dm_data</code> 进行了赋值</p><p> <code>didReceiveData</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">    [<span class="keyword">self</span>.dm_data appendData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在 <code>stopLoading</code> 方法中，就可以拿到本次网络请求接收到的数据。</p><p>但需要注意对 gzip 情况进行区别分析。我们知道 HTTP 请求中，客户端在发送请求的时候会带上 <strong><code>Accept-Encoding</code>，这个字段的值将会告知服务器客户端能够理解的内容压缩算法</strong>。而服务器进行相应时，会在 Response 中添加 <strong><code>Content-Encoding</code> 告知客户端选中的压缩算法</strong>。</p><p>所以，我们在 <code>stopLoading</code> 中获取 <code>Content-Encoding</code>，如果使用了 gzip，则模拟一次 gzip 压缩，再计算字节大小：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stopLoading &#123;</span><br><span class="line">    [<span class="keyword">self</span>.connection cancel];</span><br><span class="line"></span><br><span class="line">    DMNetworkTrafficLog *model = [[DMNetworkTrafficLog alloc] init];</span><br><span class="line">    model.path = <span class="keyword">self</span>.request.URL.path;</span><br><span class="line">    model.host = <span class="keyword">self</span>.request.URL.host;</span><br><span class="line">    model.type = DMNetworkTrafficDataTypeResponse;</span><br><span class="line">    model.lineLength = [<span class="keyword">self</span>.dm_response dm_getLineLength];</span><br><span class="line">    model.headerLength = [<span class="keyword">self</span>.dm_response dm_getHeadersLength];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.dm_response isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSHTTPURLResponse</span> *httpResponse = (<span class="built_in">NSHTTPURLResponse</span> *)<span class="keyword">self</span>.dm_response;</span><br><span class="line">        <span class="built_in">NSData</span> *data = <span class="keyword">self</span>.dm_data;</span><br><span class="line">        <span class="keyword">if</span> ([[httpResponse.allHeaderFields objectForKey:<span class="string">@&quot;Content-Encoding&quot;</span>] isEqualToString:<span class="string">@&quot;gzip&quot;</span>]) &#123;</span><br><span class="line">            <span class="comment">// 模拟压缩</span></span><br><span class="line">            data = [<span class="keyword">self</span>.dm_data gzippedData];</span><br><span class="line">        &#125;</span><br><span class="line">        model.bodyLength = data.length;</span><br><span class="line">    &#125;</span><br><span class="line">    model.length = model.lineLength + model.headerLength + model.bodyLength;</span><br><span class="line">    [model settingOccurTime];</span><br><span class="line">    [[DMDataManager defaultDB] addNetworkTrafficLog:model];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>gzippedData</code> 参考<a href="https://github.com/nicklockwood/GZIP">这个库的内容</a></p><p><code>[[DMDataManager defaultDB] addNetworkTrafficLog:model];</code> 是调用持久化层的代码将数据落库。</p><h3 id="记录-Resquest-信息"><a href="#记录-Resquest-信息" class="headerlink" title="记录 Resquest 信息"></a>记录 Resquest 信息</h3><h4 id="Line"><a href="#Line" class="headerlink" title="Line"></a>Line</h4><p>很遗憾，对于<code>NSURLRequest</code> 我没有像 <code>NSURLReponse</code> 一样幸运的找到私有接口将其转换成 CFNetwork 相关数据，但是我们很清楚 HTTP 请求报文 Line 部分的组成，所以我们可以添加一个方法，获取一个经验 Line。</p><p>同样为 <code>NSURLReques</code> 添加一个扩展：<code>NSURLRequest+DoggerMonitor</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)dgm_getLineLength &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *lineStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ %@ %@\n&quot;</span>, <span class="keyword">self</span>.HTTPMethod, <span class="keyword">self</span>.URL.path, <span class="string">@&quot;HTTP/1.1&quot;</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *lineData = [lineStr dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">return</span> lineData.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Header-1"><a href="#Header-1" class="headerlink" title="Header"></a>Header</h4><p><strong>Header 这里有一个非常大的坑</strong>。</p><p><code>request.allHTTPHeaderFields</code> 拿到的头部数据是有很多缺失的，这块跟业内朋友交流的时候，发现很多人都没有留意到这个问题。</p><p>缺失的部分不仅仅是上面一篇文章中说到的 Cookie。</p><p>如果通过 Charles 抓包，可以看到，会缺失包括但不仅限于以下字段：</p><ol><li>Accept</li><li>Connection</li><li>Host</li></ol><p>这个问题非常的迷，同时由于无法转换到 CFNetwork 层，所以一直拿不到准确的 Header 数据。</p><p>最后，我在 so 上也找到了两个相关问题，供大家参考</p><p><a href="https://stackoverflow.com/questions/5695914/nsurlrequest-where-an-app-can-find-the-default-headers-for-http-request">NSUrlRequest: where an app can find the default headers for HTTP request?</a></p><p><a href="https://stackoverflow.com/questions/21694886/nsmutableurlrequest-cant-access-all-request-headers-sent-out-from-within-my-iph">NSMutableURLRequest, cant access all request headers sent out from within my iPhone program</a></p><p>两个问题的回答基本表明了，如果你是通过 CFNetwork 来发起请求的，才可以拿到完整的 Header 数据。</p><p>所以这块只能拿到大部分的 Header，但是基本上缺失的都固定是那几个字段，对我们流量统计的精确度影响不是很大。</p><p>那么主要就针对 cookie 部分进行补全：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)dgm_getHeadersLengthWithCookie &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> headersLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *headerFields = <span class="keyword">self</span>.allHTTPHeaderFields;</span><br><span class="line">    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *cookiesHeader = [<span class="keyword">self</span> dgm_getCookies];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 cookie 信息</span></span><br><span class="line">    <span class="keyword">if</span> (cookiesHeader.count) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *headerFieldsWithCookies = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:headerFields];</span><br><span class="line">        [headerFieldsWithCookies addEntriesFromDictionary:cookiesHeader];</span><br><span class="line">        headerFields = [headerFieldsWithCookies <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, headerFields);</span><br><span class="line">    <span class="built_in">NSString</span> *headerStr = <span class="string">@&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> headerFields.allKeys) &#123;</span><br><span class="line">        headerStr = [headerStr stringByAppendingString:key];</span><br><span class="line">        headerStr = [headerStr stringByAppendingString:<span class="string">@&quot;: &quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> ([headerFields objectForKey:key]) &#123;</span><br><span class="line">            headerStr = [headerStr stringByAppendingString:headerFields[key]];</span><br><span class="line">        &#125;</span><br><span class="line">        headerStr = [headerStr stringByAppendingString:<span class="string">@&quot;\n&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSData</span> *headerData = [headerStr dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    headersLength = headerData.length;</span><br><span class="line">    <span class="keyword">return</span> headersLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)dgm_getCookies &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *cookiesHeader;</span><br><span class="line">    <span class="built_in">NSHTTPCookieStorage</span> *cookieStorage = [<span class="built_in">NSHTTPCookieStorage</span> sharedHTTPCookieStorage];</span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSHTTPCookie</span> *&gt; *cookies = [cookieStorage cookiesForURL:<span class="keyword">self</span>.URL];</span><br><span class="line">    <span class="keyword">if</span> (cookies.count) &#123;</span><br><span class="line">        cookiesHeader = [<span class="built_in">NSHTTPCookie</span> requestHeaderFieldsWithCookies:cookies];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookiesHeader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="body"><a href="#body" class="headerlink" title="body"></a>body</h4><p><strong>最后是 body 部分，这里也有个坑。通过 <code>NSURLConnection</code> 发出的网络请求 <code>resquest.HTTPBody</code> 拿到的是 nil。</strong></p><p>需要转而通过 <code>HTTPBodyStream</code> 读取 stream 来获取 request 的 Body 大小。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)dgm_getBodyLength &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *headerFields = <span class="keyword">self</span>.allHTTPHeaderFields;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bodyLength = [<span class="keyword">self</span>.HTTPBody length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([headerFields objectForKey:<span class="string">@&quot;Content-Encoding&quot;</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *bodyData;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.HTTPBody == <span class="literal">nil</span>) &#123;</span><br><span class="line">            uint8_t d[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">NSInputStream</span> *stream = <span class="keyword">self</span>.HTTPBodyStream;</span><br><span class="line">            <span class="built_in">NSMutableData</span> *data = [[<span class="built_in">NSMutableData</span> alloc] init];</span><br><span class="line">            [stream open];</span><br><span class="line">            <span class="keyword">while</span> ([stream hasBytesAvailable]) &#123;</span><br><span class="line">                <span class="built_in">NSInteger</span> len = [stream read:d maxLength:<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; stream.streamError == <span class="literal">nil</span>) &#123;</span><br><span class="line">                    [data appendBytes:(<span class="keyword">void</span> *)d length:len];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bodyData = [data <span class="keyword">copy</span>];</span><br><span class="line">            [stream close];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bodyData = <span class="keyword">self</span>.HTTPBody;</span><br><span class="line">        &#125;</span><br><span class="line">        bodyLength = [[bodyData gzippedData] length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bodyLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="落库"><a href="#落库" class="headerlink" title="落库"></a>落库</h4><p>最后在 <code>DMURLProtocol</code> 的 <code>- (nullable NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(nullable NSURLResponse *)response;</code> 方法中对 resquest 调用报文各个部分大小方法后落库：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSURLRequest</span> *)connection:(<span class="built_in">NSURLConnection</span> *)connection willSendRequest:(<span class="built_in">NSURLRequest</span> *)request redirectResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dm_response = response;</span><br><span class="line">        [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> wasRedirectedToRequest:request redirectResponse:response];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DMNetworkTrafficLog *model = [[DMNetworkTrafficLog alloc] init];</span><br><span class="line">    model.path = request.URL.path;</span><br><span class="line">    model.host = request.URL.host;</span><br><span class="line">    model.type = DMNetworkTrafficDataTypeRequest;</span><br><span class="line">    model.lineLength = [connection.currentRequest dgm_getLineLength];</span><br><span class="line">    model.headerLength = [connection.currentRequest dgm_getHeadersLengthWithCookie];</span><br><span class="line">    model.bodyLength = [connection.currentRequest dgm_getBodyLength];</span><br><span class="line">    model.length = model.lineLength + model.headerLength + model.bodyLength;</span><br><span class="line">    [model settingOccurTime];</span><br><span class="line">    [[DMDataManager defaultDB] addNetworkTrafficLog:model];</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="针对-NSURLSession-的处理"><a href="#针对-NSURLSession-的处理" class="headerlink" title="针对 NSURLSession 的处理"></a>针对 NSURLSession 的处理</h3><p>直接使用 <code>DMURLProtocol</code> 并 <code>registerClass</code> 并不能完整的拦截所有网络请求，因为通过 <code>NSURLSession</code> 的 <code>sharedSession</code> 发出的请求是无法被 <code>NSURLProtocol</code> 代理的。</p><p>我们需要让 <code>[NSURLSessionConfiguration defaultSessionConfiguration].protocolClasses</code> 的属性中也设置我们的 <code>DMURLProtocol</code>，这里通过 swizzle，置换 <code>protocalClasses</code> 的 get 方法：</p><p>编写一个 <code>DMURLSessionConfiguration</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DMURLSessionConfiguration</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">BOOL</span> isSwizzle;</span><br><span class="line">+ (DMURLSessionConfiguration *)defaultConfiguration;</span><br><span class="line">- (<span class="keyword">void</span>)load;</span><br><span class="line">- (<span class="keyword">void</span>)unload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;DMURLSessionConfiguration.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;DMURLProtocol.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;DMNetworkTrafficManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DMURLSessionConfiguration</span></span></span><br><span class="line"></span><br><span class="line">+ (DMURLSessionConfiguration *)defaultConfiguration &#123;</span><br><span class="line">    <span class="keyword">static</span> DMURLSessionConfiguration *staticConfiguration;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        staticConfiguration=[[DMURLSessionConfiguration alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> staticConfiguration;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.isSwizzle = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">self</span>.isSwizzle = <span class="literal">YES</span>;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;__NSCFURLSessionConfiguration&quot;</span>) ?: <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;NSURLSessionConfiguration&quot;</span>);</span><br><span class="line">    [<span class="keyword">self</span> swizzleSelector:<span class="keyword">@selector</span>(protocolClasses) fromClass:cls toClass:[<span class="keyword">self</span> <span class="keyword">class</span>]];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)unload &#123;</span><br><span class="line">    <span class="keyword">self</span>.isSwizzle=<span class="literal">NO</span>;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;__NSCFURLSessionConfiguration&quot;</span>) ?: <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;NSURLSessionConfiguration&quot;</span>);</span><br><span class="line">    [<span class="keyword">self</span> swizzleSelector:<span class="keyword">@selector</span>(protocolClasses) fromClass:cls toClass:[<span class="keyword">self</span> <span class="keyword">class</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swizzleSelector:(SEL)selector fromClass:(Class)original toClass:(Class)stub &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(original, selector);</span><br><span class="line">    Method stubMethod = class_getInstanceMethod(stub, selector);</span><br><span class="line">    <span class="keyword">if</span> (!originalMethod || !stubMethod) &#123;</span><br><span class="line">        [<span class="built_in">NSException</span> raise:<span class="built_in">NSInternalInconsistencyException</span> format:<span class="string">@&quot;Couldn&#x27;t load NEURLSessionConfiguration.&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    method_exchangeImplementations(originalMethod, stubMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)protocolClasses &#123;</span><br><span class="line">    <span class="comment">// DMNetworkTrafficManager 中的 protocolClasses 可以给使用者设置自定义的 protocolClasses</span></span><br><span class="line">    <span class="keyword">return</span> [DMNetworkTrafficManager manager].protocolClasses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这样，我们写好了方法置换，在执行过该类单例的 <code>load</code> 方法后，<code>[NSURLSessionConfiguration defaultSessionConfiguration].protocolClasses</code> 拿到的将会是我们设置好的 <code>protocolClasses</code>。</p><p>如此，我们再为 <code>DMURLProtocol</code> 添加 <code>start</code> 和 <code>stop</code> 方法，用于启动网络监控和停止网络监控：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    DMURLSessionConfiguration *sessionConfiguration = [DMURLSessionConfiguration defaultConfiguration];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> protocolClass <span class="keyword">in</span> [DMNetworkTrafficManager manager].protocolClasses) &#123;</span><br><span class="line">        [<span class="built_in">NSURLProtocol</span> registerClass:protocolClass];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (![sessionConfiguration isSwizzle]) &#123;</span><br><span class="line">        <span class="comment">// 设置交换</span></span><br><span class="line">        [sessionConfiguration load];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)end &#123;</span><br><span class="line">    DMURLSessionConfiguration *sessionConfiguration = [DMURLSessionConfiguration defaultConfiguration];</span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> unregisterClass:[DMURLProtocol <span class="keyword">class</span>]];</span><br><span class="line">    <span class="keyword">if</span> ([sessionConfiguration isSwizzle]) &#123;</span><br><span class="line">        <span class="comment">// 取消交换</span></span><br><span class="line">        [sessionConfiguration unload];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，基本完成了整个网络流量监控。</p><p>再提供一个 Manger 方便使用者调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">DMNetworkLog</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DMNetworkTrafficManager</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 所有 NSURLProtocol 对外设置接口，可以防止其他外来监控 NSURLProtocol */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *protocolClasses;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 单例 */</span></span><br><span class="line">+ (DMNetworkTrafficManager *)manager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过 protocolClasses 启动流量监控模块 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)startWithProtocolClasses:(<span class="built_in">NSArray</span> *)protocolClasses;</span><br><span class="line"><span class="comment">/** 仅以 DMURLProtocol 启动流量监控模块 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)start;</span><br><span class="line"><span class="comment">/** 停止流量监控 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;DMNetworkTrafficManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;DMURLProtocol.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DMNetworkTrafficManager</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DMNetworkTrafficManager</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Public</span></span><br><span class="line"></span><br><span class="line">+ (DMNetworkTrafficManager *)manager &#123;</span><br><span class="line">    <span class="keyword">static</span> DMNetworkTrafficManager *manager;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        manager=[[DMNetworkTrafficManager alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)startWithProtocolClasses:(<span class="built_in">NSArray</span> *)protocolClasses &#123;</span><br><span class="line">    [<span class="keyword">self</span> manager].protocolClasses = protocolClasses;</span><br><span class="line">    [DMURLProtocol start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span> manager].protocolClasses = @[[DMURLProtocol <span class="keyword">class</span>]];</span><br><span class="line">    [DMURLProtocol start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)end &#123;</span><br><span class="line">    [DMURLProtocol end];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h1 id="五、代码"><a href="#五、代码" class="headerlink" title="五、代码"></a>五、代码</h1><p>本文中贴出了比较多的代码，为了便于大家整体观看，可以到 <a href="https://github.com/summertian4/iOS-ObjectiveC/tree/master/NetworkTraffic">这里</a> 来阅读。</p><p>由于其中包含了一些数据操作的内容不需要关心，所以我直接省略了，虽然没有 Demo，但我相信大家都是能理解整个监控结构的。</p><h1 id="六、Other"><a href="#六、Other" class="headerlink" title="六、Other"></a>六、Other</h1><p>如果你的 APP 从 iOS 9 支持，可以使用 <a href="https://developer.apple.com/documentation/networkextension">NetworkExtension</a>，通过 NetworkExtension 可以通过 VPN 的形式接管整个网络请求，省掉了上面所有的烦恼。</p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于骑手不能随时处在有 WIFI 的状态，流量变成了很敏感的问题，为了精确到每个 API 的流量，进行针对性的优化，开始在我们的 APM 中添加流量监控功能。&lt;/p&gt;
&lt;p&gt;本文将记录自己做流量监控方面的总结。其中包括了非常多的&lt;strong&gt;踩坑经验&lt;/strong&gt;，和现有一些&lt;strong&gt;方案的缺陷分析&lt;/strong&gt;，对我来说是一个非常有意义的过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;干货预警🤣请做好读大量代码的准备😂😂😂&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://lottyzhou.com/categories/iOS/"/>
    
      <category term="iOS进阶" scheme="http://lottyzhou.com/categories/iOS/iOS%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="iOS" scheme="http://lottyzhou.com/tags/iOS/"/>
    
      <category term="流量监控" scheme="http://lottyzhou.com/tags/%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7/"/>
    
      <category term="APM" scheme="http://lottyzhou.com/tags/APM/"/>
    
  </entry>
  
  <entry>
    <title>Python——奇怪的扫码登录</title>
    <link href="http://lottyzhou.com/2018/05/20/python-scan-code-login/"/>
    <id>http://lottyzhou.com/2018/05/20/python-scan-code-login/</id>
    <published>2018-05-20T05:50:46.000Z</published>
    <updated>2021-10-11T09:40:59.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python——奇怪的扫码登录"><a href="#Python——奇怪的扫码登录" class="headerlink" title="Python——奇怪的扫码登录"></a>Python——奇怪的扫码登录</h1><p>最近在做 Sparrow（还在内测的一个敲好用 Mock 系统😁）的时候遇到了一个需求。Sparrow 服务器是使用 Django 2.0 编写的产品，所以<strong>本文所有的代码背景均为 Django 2.0 环境和 Python 3.6.3 语言，整体是 Vue + Django + SQLite。</strong></p><p>Sparrow 的操作一般都是在网页上操作，而手机客户端往往是用来同步一些简单数据的。那么这里遇到一个和平常 APP 不同的使用场景。</p><p>一般来说，一个产品的操作大多是在手机上，那么 PC 客户端和网页版就可以通过已经登录的移动端 APP 扫码登录。</p><p>而现在的情况是，Sparrow 的使用大多在网页版，那么，我需要的就是，让移动 APP 用户在网页版已经登录的情况下免去输入用户名、密码的登录操作，让移动 APP 用户扫描网页二维码，完成移动 APP 的登录。</p><span id="more"></span><h2 id="大致的-Use-Case"><a href="#大致的-Use-Case" class="headerlink" title="大致的 Use Case"></a>大致的 Use Case</h2><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_python-scan-code-login-03.png" alt=""></p><p>##设计思路</p><h3 id="扫码登录-URL"><a href="#扫码登录-URL" class="headerlink" title="扫码登录 URL"></a>扫码登录 URL</h3><p>首先能想到的是，服务器要提供给移动 APP 可以访问的 URL（展现成二维码给 APP 扫描），这个 URL 需要包括</p><ol><li>user 的唯一标志符</li><li>验证码</li></ol><p>那么其 URL 的大致模样就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frontend/account/quick_login?user_id=&lt;user_id&gt;&amp;verification_code=&lt;verification_code&gt;</span><br></pre></td></tr></table></figure><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>验证码是从哪里来的？</p><p>原因是这样的，如果扫码登录的 URL 永久有效，显然是不合理的，这意味着只要得到了这个 URL，任何人都可以通过这个 URL 随时登录该用户的账号，所以需要有验证码。</p><p>同时，<strong>验证码需要附带生成时间</strong>，以此来达<strong>到验证码一分钟有效</strong>的 Feature。为此，设计一个外键为 user 的 Model：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickLoginRecord</span>(<span class="params">models.Model, Dictable</span>):</span></span><br><span class="line">    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=<span class="literal">True</span>)</span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    update_time = models.DateTimeField(auto_now=<span class="literal">True</span>)</span><br><span class="line">    verification_code = models.CharField(max_length=<span class="number">32</span>, null=<span class="literal">True</span>, default=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>通过 Django 生成的对应数据库为：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_python-scan-code-login-01.png" alt=""></p><p>什么时候生成验证码，那当然是生成二维码的时候，所以，这个 URL 不是给移动端请求的，而是给前端来请求的，前端在已登录的情况下，访问该 URL 可以直接传递 user 信息，后端通过拿到 user 信息，生成一条 QuickLoginRecord 记录。</p><p>前端访问并拿到验证码的 URL 的大致模样是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frontend/account/request_quick_login</span><br></pre></td></tr></table></figure><p>那么整个流程就是（省略了细节处理）：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_python-scan-code-login-04.png" alt=""></p><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><h3 id="url-py"><a href="#url-py" class="headerlink" title="url.py"></a>url.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">// ···</span><br><span class="line">path(<span class="string">&#x27;frontend/account/quick_login&#x27;</span>, AccountAction.quick_login),</span><br><span class="line">    path(<span class="string">&#x27;frontend/account/request_quick_login&#x27;</span>, AccountAction.request_quick_login),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickLoginRecord</span>(<span class="params">models.Model, Dictable</span>):</span></span><br><span class="line">    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=<span class="literal">True</span>)</span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    update_time = models.DateTimeField(auto_now=<span class="literal">True</span>)</span><br><span class="line">    verification_code = models.CharField(max_length=<span class="number">32</span>, null=<span class="literal">True</span>, default=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="account-action-py"><a href="#account-action-py" class="headerlink" title="account_action.py"></a>account_action.py</h3><p>这里代码不想看的话，大概描述一下过程：</p><h4 id="def-request-quick-login-request-HttpRequest"><a href="#def-request-quick-login-request-HttpRequest" class="headerlink" title="def request_quick_login(request: HttpRequest)"></a>def request_quick_login(request: HttpRequest)</h4><ol><li>规定 HTTPMethod 必须为 GET 访问</li><li>获取 request 中的 user_id 参数</li><li>通过 user_id 查询 QuickLoginRecord 记录</li><li>如果未查询到结果，新建一个 QuickLoginRecord 记录，设置 user 关联、verification_code（create_time 和 update_time 在 QuickLoginRecordDao 中自动设置）</li><li>如果查询到结果，更新 verification_code 字段（ update_time 在 QuickLoginRecordDao 中自动设置）</li><li>返回 Success</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@track(<span class="params">AccountRequestQuickLogin</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_quick_login</span>(<span class="params">request: HttpRequest</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method != CommonData.Method.GET.value:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(Response.methodInvalidResponse().toJson(), content_type=<span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">    user = request.user</span><br><span class="line">    r = QuickLoginRecordDao.get_record_with_user_id(user.<span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">if</span> r <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        r.verification_code = <span class="built_in">str</span>(uuid.uuid1())</span><br><span class="line">        QuickLoginRecordDao.update_record(r)</span><br><span class="line">        response = Response(Success, <span class="string">&#x27;Success&#x27;</span>, &#123;<span class="string">&#x27;verification_code&#x27;</span>: r.verification_code&#125;)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(response.toJson(), content_type=<span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        record = QuickLoginRecord()</span><br><span class="line">        record.user = user</span><br><span class="line">        record.verification_code = <span class="built_in">str</span>(uuid.uuid1())</span><br><span class="line">        QuickLoginRecordDao.add_record(record)</span><br><span class="line">        response = Response(Success, <span class="string">&#x27;Success&#x27;</span>, &#123;<span class="string">&#x27;verification_code&#x27;</span>: record.verification_code&#125;)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(response.toJson(), content_type=<span class="string">&#x27;application/json&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="def-quick-login-request-HttpRequest"><a href="#def-quick-login-request-HttpRequest" class="headerlink" title="def quick_login(request: HttpRequest):"></a>def quick_login(request: HttpRequest):</h4><ol><li>规定 HTTPMethod 必须为 GET 访问</li><li>拿到 reqeust 中的 user_id</li><li>拿到 reqeust 中的 verification_code</li><li>通过 verification_code 获取 QuickLoginRecord 记录</li><li>如果记录不存在则表示验证码不存在或过期</li><li>如果存在，比较 update_time 字段，判断是否已经超过 60 秒</li><li>超过 60 秒返回『验证码过期』</li><li>未超过 60 秒，让用户登录</li><li>返回 Success</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@track(<span class="params">AccountQuickLogin</span>)</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">quick_login</span>(<span class="params">request: HttpRequest</span>):</span></span><br><span class="line">       <span class="keyword">if</span> request.method != CommonData.Method.GET.value:</span><br><span class="line">           <span class="keyword">return</span> HttpResponse(Response.methodInvalidResponse().toJson(), content_type=<span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">       user_id = request.GET.get(<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line">       verification_code = request.GET.get(<span class="string">&#x27;verification_code&#x27;</span>)</span><br><span class="line"></span><br><span class="line">       record = QuickLoginRecordDao.get_record_with_verification_code(verification_code)</span><br><span class="line">       <span class="keyword">if</span> record <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">           response = Response(QuickLoginFailed, <span class="string">&#x27;验证码不存在或已过期&#x27;</span>, &#123;&#125;)</span><br><span class="line">           <span class="keyword">return</span> HttpResponse(response.toJson(), content_type=<span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line"></span><br><span class="line">       now = datetime.now(timezone.utc)</span><br><span class="line">       offset = (now - record.update_time).seconds</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> offset &gt; <span class="number">60</span>:</span><br><span class="line">           response = Response(QuickLoginFailed, <span class="string">&#x27;验证码已过期&#x27;</span>, &#123;&#125;)</span><br><span class="line">           <span class="keyword">return</span> HttpResponse(response.toJson(), content_type=<span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line"></span><br><span class="line">       user = AccountDao.get_user_with_id(user_id)</span><br><span class="line">       <span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">           response = Response(QuickLoginFailed, <span class="string">&#x27;用户不存在&#x27;</span>, &#123;&#125;)</span><br><span class="line">           <span class="keyword">return</span> HttpResponse(response.toJson(), content_type=<span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">       user.backend = <span class="string">&#x27;django.contrib.auth.backends.ModelBackend&#x27;</span></span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;用户 &#x27;</span> + user.username + <span class="string">&#x27; 尝试登录&#x27;</span>)</span><br><span class="line">       auth.login(request, user)</span><br><span class="line">       accountInfo = User.objects.get(<span class="built_in">id</span>=user.<span class="built_in">id</span>)</span><br><span class="line">       response = Response(Success, <span class="string">&#x27;Success&#x27;</span>, &#123;<span class="string">&#x27;id&#x27;</span>: accountInfo.<span class="built_in">id</span>,</span><br><span class="line">                                                <span class="string">&#x27;username&#x27;</span>: accountInfo.username,</span><br><span class="line">                                                <span class="string">&#x27;email&#x27;</span>: accountInfo.email&#125;)</span><br><span class="line">       <span class="keyword">return</span> HttpResponse(response.toJson(), content_type=<span class="string">&#x27;application/json&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="quick-login-record-dao-py"><a href="#quick-login-record-dao-py" class="headerlink" title="quick_login_record_dao.py"></a>quick_login_record_dao.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickLoginRecordDao</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_record</span>(<span class="params">record</span>):</span></span><br><span class="line">        record.save()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_record_with_user_id</span>(<span class="params">user_id</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            record = QuickLoginRecord.objects.get(user_id=user_id)</span><br><span class="line">            <span class="keyword">return</span> record</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_record</span>(<span class="params">record</span>):</span></span><br><span class="line">        result = QuickLoginRecord.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=record.<span class="built_in">id</span>).update(</span><br><span class="line">            verification_code=record.verification_code,</span><br><span class="line">            update_time=datetime.datetime.now())</span><br><span class="line">        <span class="keyword">if</span> result &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_record_with_verification_code</span>(<span class="params">code</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            record = QuickLoginRecord.objects.get(verification_code=code)</span><br><span class="line">            <span class="keyword">return</span> record</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><p>前端的效果是这样的：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_python-scan-code-login-02.gif" alt=""></p><p>在已登录的状态下，点击右上角的『客户端扫码登录』按钮，弹出二维码。</p><p>动效、模态窗什么的就不过多展示代码了，只关注主流程的代码：</p><h3 id="导航栏按钮"><a href="#导航栏按钮" class="headerlink" title="导航栏按钮"></a>导航栏按钮</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;account.status&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;button is-primary&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;openModalImage&quot;</span>&gt;</span>客户端扫码登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="openModalImage-函数"><a href="#openModalImage-函数" class="headerlink" title="openModalImage 函数"></a>openModalImage 函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">openModalImage () &#123;</span><br><span class="line">  <span class="keyword">const</span> imageModal = openImageModal()</span><br><span class="line">  imageModal.loading = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> baseUrl = <span class="built_in">window</span>.location.protocol + <span class="string">&#x27;//&#x27;</span> + <span class="built_in">window</span>.location.host</span><br><span class="line">  request(<span class="string">&#x27;/frontend/account/request_quick_login&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> verificationCode = response.data.verification_code</span><br><span class="line">    <span class="keyword">var</span> url = baseUrl + <span class="string">&#x27;/frontend/account/quick_login&#x27;</span> + <span class="string">&#x27;?&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;verification_code=&#x27;</span> + verificationCode + <span class="string">&#x27;&amp;&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;user_id=&#x27;</span> + <span class="built_in">this</span>.accountInfo.id</span><br><span class="line"></span><br><span class="line">    QRCode.toDataURL(url)</span><br><span class="line">      .then(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">        imageModal.imgUrl = url</span><br><span class="line">        imageModal.loading = <span class="literal">false</span></span><br><span class="line">        imageModal.$children[<span class="number">0</span>].active()</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    notification.toast(&#123;</span><br><span class="line">      <span class="attr">message</span>: response.message,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;danger&#x27;</span>,</span><br><span class="line">      <span class="attr">duration</span>: <span class="number">2000</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iOS代码"><a href="#iOS代码" class="headerlink" title="iOS代码"></a>iOS代码</h2><p>iOS 代码就不展示了，就是扫码访问二维码里的 URL，再加上一些非法 URL 的判断即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过完整个流程后，可以感觉到，类似于支付宝的扫码支付。给出一个定时刷新的二维码，供给客户端进行扫码登录。</p><p>当然，还有可以完善的地方，比如前段在打开了二维码模态窗时，每 60 秒进行一次定时刷新。</p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python——奇怪的扫码登录&quot;&gt;&lt;a href=&quot;#Python——奇怪的扫码登录&quot; class=&quot;headerlink&quot; title=&quot;Python——奇怪的扫码登录&quot;&gt;&lt;/a&gt;Python——奇怪的扫码登录&lt;/h1&gt;&lt;p&gt;最近在做 Sparrow（还在内测的一个敲好用 Mock 系统😁）的时候遇到了一个需求。Sparrow 服务器是使用 Django 2.0 编写的产品，所以&lt;strong&gt;本文所有的代码背景均为 Django 2.0 环境和 Python 3.6.3 语言，整体是 Vue + Django + SQLite。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Sparrow 的操作一般都是在网页上操作，而手机客户端往往是用来同步一些简单数据的。那么这里遇到一个和平常 APP 不同的使用场景。&lt;/p&gt;
&lt;p&gt;一般来说，一个产品的操作大多是在手机上，那么 PC 客户端和网页版就可以通过已经登录的移动端 APP 扫码登录。&lt;/p&gt;
&lt;p&gt;而现在的情况是，Sparrow 的使用大多在网页版，那么，我需要的就是，让移动 APP 用户在网页版已经登录的情况下免去输入用户名、密码的登录操作，让移动 APP 用户扫描网页二维码，完成移动 APP 的登录。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://lottyzhou.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://lottyzhou.com/tags/Python/"/>
    
      <category term="Django" scheme="http://lottyzhou.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>关于 Pod 库的资源引用 resource_bundles or resources</title>
    <link href="http://lottyzhou.com/2018/02/02/pod-resource-reference/"/>
    <id>http://lottyzhou.com/2018/02/02/pod-resource-reference/</id>
    <published>2018-02-02T10:29:09.000Z</published>
    <updated>2021-10-11T09:40:59.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-资源文件引用的方式"><a href="#1-资源文件引用的方式" class="headerlink" title="1. 资源文件引用的方式"></a>1. 资源文件引用的方式</h1><p>在第一节，先来介绍一下 CocoaPods 两种资源文件引用的方式——<code>resource_bundles</code> &amp; <code>resources</code></p><h2 id="1-1-resource-bundles"><a href="#1-1-resource-bundles" class="headerlink" title="1.1 resource_bundles"></a>1.1 resource_bundles</h2><p><code>resource_bundles</code> 允许定义当前 Pod 库的资源包的<strong>名称和文件</strong>。用 hash 的形式来声明，key 是 bundle 的名称，value 是需要包括的文件的通配 patterns。</p><blockquote><p>We strongly recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute.</p></blockquote><p>CocoaPods 官方强烈推荐使用 <code>resource_bundles</code>，因为用 key-value 可以避免相同名称资源的名称冲突。</p><p>同时建议 bundle 的名称至少应该包括 Pod 库的名称，可以尽量减少同名冲突</p><p>Examples:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.ios.resource_bundle = &#123; <span class="string">&#x27;MapBox&#x27;</span> =&gt; <span class="string">&#x27;MapView/Map/Resources/*.png&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spec.resource_bundles = &#123;</span><br><span class="line">    <span class="string">&#x27;MapBox&#x27;</span> =&gt; [<span class="string">&#x27;MapView/Map/Resources/*.png&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;OtherResources&#x27;</span> =&gt; [<span class="string">&#x27;MapView/Map/OtherResources/*.png&#x27;</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="1-2-resources"><a href="#1-2-resources" class="headerlink" title="1.2 resources"></a>1.2 resources</h2><p>使用 <code>resources</code> 来指定资源，被指定的资源只会简单的被 copy 到目标工程中（主工程）。</p><blockquote><p>We strongly recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute. Moreover, resources specified with this attribute are copied directly to the client target and therefore they are not optimised by Xcode.</p></blockquote><p>官方认为用 <code>resources</code> 是无法避免同名资源文件的冲突的，同时，Xcode 也不会对这些资源做优化。</p><p>Examples:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.resource = <span class="string">&#x27;Resources/HockeySDK.bundle&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.resources = [<span class="string">&#x27;Images/*.png&#x27;</span>, <span class="string">&#x27;Sounds/*&#x27;</span>]</span><br></pre></td></tr></table></figure><blockquote><p><strong>FYI：</strong><br><a href="https://guides.cocoapods.org/syntax/podspec.html">Podspec Syntax Reference v1.4.0</a></p></blockquote><h1 id="2-图片资源的管理"><a href="#2-图片资源的管理" class="headerlink" title="2. 图片资源的管理"></a>2. 图片资源的管理</h1><p>我们熟知平常用的 @2x @3x 图片是为了缩小用户最终下载时包的大小，通常我们会将图片放在 <code>.xcassets</code> 文件中管理，新建的项目也默认创建：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-01.pnghttps://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-01.png" alt=""></p><p>使用 <code>.xcassets</code> 不仅可以方便在 Xcode 查看和拖入图片，同时 <code>.xcassets</code> 最终会打包生成为<br> <code>Assets.car</code> 文件。对于 <code>Assets.car</code> 文件，<a href="https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f">App Slicing</a> 会为切割留下符合目标设备分辨率的图片，可以缩小用户最终下载的包的大小。</p><blockquote><p><strong>FYI：</strong><br><a href="https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_ref-Asset_Catalog_Format/FolderStructure.html#//apple_ref/doc/uid/TP40015170-CH33-SW1">Xcode Ref Asset Catalog Format</a><br><a href="https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f">App thinning overview (iOS, tvOS, watchOS)</a></p></blockquote><p>实际上，对于 Pods 库的资源，同样可以使用 <code>.xcassets</code> 管理。</p><h1 id="3-实际验证"><a href="#3-实际验证" class="headerlink" title="3. 实际验证"></a>3. 实际验证</h1><blockquote><p>不关注的可以直接跳到下面『结论』</p></blockquote><p>官文中推荐了 <code>resource_bundles</code> 其理由主要是『可以解决同名冲突』和『Xcode为 bundle 提供的一些优化』。</p><p>我知道很多人看过 <a href="http://blog.xianqu.org/2015/08/pod-resources/">这篇</a> 文章，里面提到 resource_bundles 不能使用 .xcassets。</p><p>那么到底是不是这样，我们需要亲自动手验证，看看两种引用方式，CocoaPods 到底为我们做了什么。</p><p>我们将在『实际验证』一节验证：</p><ol><li><code>resource_bundles</code> 是否能使用 *.xcassets 指定资源并正确打包</li><li>同名冲突是怎样的</li></ol><h2 id="3-1-resource-bundles-是否能使用-xcassets-指定资源并正确打包"><a href="#3-1-resource-bundles-是否能使用-xcassets-指定资源并正确打包" class="headerlink" title="3.1 resource_bundles 是否能使用 *.xcassets 指定资源并正确打包"></a>3.1 resource_bundles 是否能使用 *.xcassets 指定资源并正确打包</h2><p>写两个 Demo Pod，同时创建好对应的 Example 测试工程。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-02.png" alt=""></p><p>对两个 Pod 分别使用不同的方式指定资源。</p><p>第一个 Demo Pod：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-04.png" alt=""></p><p>第二个 Demo Pod：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-03.png" alt=""></p><p>分别用了 <code>resource_bundles</code> 和 <code>resources</code> 两种方式引用。</p><p><code>pod install</code> 后，观察结果。</p><h3 id="3-1-1-使用-resources"><a href="#3-1-1-使用-resources" class="headerlink" title="3.1.1 使用 resources"></a>3.1.1 使用 resources</h3><p><code>pod install</code> 并编译 Example 工程后，我们可以打开最后生成的 Product 文件下的内容：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-06.png" alt=""></p><p>可以看到只有 一些 <code>.a</code> 文件，<code>.a</code> 文件是二进制文件。初次之外只有 <code>SubModule-Example.app</code>，打开包内容，可以看到只有一个 <code>Assets.car</code>。</p><p>这说明，使用 <code>resources</code> 之后只会简单的将资源文件 copy 到目标工程（Example 工程），最后和目标工程的图片文件以及其他同样使用 <code>resources</code> 的 Pod 的图片文件，统一一起打包为了一个 <code>Assets.car</code>。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-07.png" alt=""></p><p>再为 Pod 写一个 VC 来实验读取图片：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-08.png" alt=""></p><p>读取图片的方式和平常使用的方式不同，要先获取 Bundle：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;some-image&quot;</span></span><br><span class="line">                                inBundle:[<span class="built_in">NSBundle</span> bundleForClass:[<span class="keyword">self</span> <span class="keyword">class</span>]]</span><br><span class="line">           compatibleWithTraitCollection:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>在 Example 的 <code>ViewController</code> 写一下跳转 <code>SubModule/SMViewController</code>：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-09.png" alt=""></p><p>运行之后，看一下，能正常访问图片：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-10.png" alt=""></p><h3 id="3-1-2-使用-resource-bundles"><a href="#3-1-2-使用-resource-bundles" class="headerlink" title="3.1.2 使用 resource_bundles"></a>3.1.2 使用 <code>resource_bundles</code></h3><p><code>pod install</code> 并编译 Example 工程后，同样找到 Product 文件下的内容：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-11.png" alt=""></p><p>可以看到最终生成了一个 <code>SubModule_Use_Bundle.bundle</code>，打开看内部：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-12.png" alt=""></p><p>发现包含了一个 <code>Assets.car</code></p><p>再为 Pod 写一个 VC 来实验读取图片：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-13.png" alt=""></p><p>由于还需要带上 .bundle 文件的路径，获取的方式又不同：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *bundlePath = [[<span class="built_in">NSBundle</span> bundleForClass:[<span class="keyword">self</span> <span class="keyword">class</span>]].resourcePath</span><br><span class="line">                            stringByAppendingPathComponent:<span class="string">@&quot;/SubModule_Use_Bundle.bundle&quot;</span>];</span><br><span class="line"><span class="built_in">NSBundle</span> *resource_bundle = [<span class="built_in">NSBundle</span> bundleWithPath:bundlePath];</span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;some-image&quot;</span></span><br><span class="line">                                inBundle:resource_bundle</span><br><span class="line">           compatibleWithTraitCollection:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>在 Example 的 <code>ViewController</code> 写一下跳转 <code>SubModule/SMViewController</code>：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-14.png" alt=""></p><p>运行之后，看一下，也能正常访问图片：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-15.png" alt=""></p><h3 id="3-1-3-resources-和-resource-bundles-对于-xcassets-的支持"><a href="#3-1-3-resources-和-resource-bundles-对于-xcassets-的支持" class="headerlink" title="3.1.3 resources 和 resource_bundles 对于 .xcassets 的支持"></a>3.1.3 resources 和 resource_bundles 对于 .xcassets 的支持</h3><p>从 3.1 和 3.2 可以看出 resources 和 resource_bundles 都可以很好的支持 .xcassets 的引用。</p><p>所以，<a href="http://blog.xianqu.org/2015/08/pod-resources/">这篇</a> 文章，里面提到 resource_bundles 不能使用 .xcassets 并不存在。应该说这篇文章已经比较老了，<strong>CocoaPods 随着不断的更新，<code>resource_bundles</code> 已经可以很好的支持 <code>.xcassets</code> 了。</strong></p><h2 id="3-2-同名资源的冲突问题"><a href="#3-2-同名资源的冲突问题" class="headerlink" title="3.2 同名资源的冲突问题"></a>3.2 同名资源的冲突问题</h2><p>从上面的分析可以看出：</p><p>使用 <code>resources</code> 之后只会简单的将资源文件 copy 到目标工程（Example 工程），最后和目标工程的图片文件以及其他同样使用 <code>resources</code> 的 Pod 的图片文件，统一一起打包为了一个 <code>Assets.car</code>。</p><p>使用 <code>resource_bundles</code> 之后会为为指定的资源打一个 <code>.bundle</code>，<code>.bundle</code>包含一个 <code>Assets.car</code>，获取图片的时候要严格指定 <code>.bundle</code> 的位置，很好的隔离了各个库或者一个库下的资源包。</p><p>显然，使用 <code>resources</code>，如果出现同名的图片，显然是会出现冲突的，同样使用 <code>some-image</code> 名称的两个图片资源，不一定能正确调用到。</p><h4 id="3-2-1-简单验证-resources-重名问题"><a href="#3-2-1-简单验证-resources-重名问题" class="headerlink" title="3.2.1 简单验证 resources 重名问题"></a>3.2.1 简单验证 resources 重名问题</h4><p>给 Example 文件添加一个同样叫 <code>some-image</code> 的图片：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-16.png" alt=""></p><p>OK，现在的情况是 Example 工程自己有一个 <code>some-image</code> 图片资源，SubModule 这个 Pod 库也有一个 <code>some-image</code> 图片资源。</p><p>还是之前的显示图片的代码，再运行一下：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_pod-resource-reference-17.png" alt=""></p><p>可以看到，图片显然是用错了，显示了 Example 工程自己的 <code>some-image</code></p><p>这就是 resources 的重名资源问题。</p><p>而使用 <code>resource_bundles</code> 则可以很好的避开这个问题。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p><strong>resource_bundles 优点：</strong></p><ol><li>可以使用 <code>.xcassets</code> 指定资源文件</li><li>可以避免每个库和主工程之间的同名资源冲突</li></ol><p><strong>resource_bundles 缺点：</strong></p><ol><li>获取图片时可能需要使用硬编码的形式来获取：<code>[[NSBundle bundleForClass:[self class]].resourcePath stringByAppendingPathComponent:@&quot;/SubModule_Use_Bundle.bundle&quot;]</code></li></ol><p><strong>resources 优点：</strong></p><ol><li>可以使用 <code>.xcassets</code> 指定资源文件</li></ol><p><strong>resources 缺点：</strong></p><ol><li>会导致每个库和主工程之间的同名资源冲突</li><li>不需要用硬编码方式获取图片：<code>[NSBundle bundleForClass:[self class]] compatibleWithTraitCollection:nil];</code></li></ol><p>So，一般来说使用 <code>resource_bundles</code> 会更好，不过关于硬编码，还可以再找找别的方式去避免。</p><h1 id="5-Demo"><a href="#5-Demo" class="headerlink" title="5. Demo"></a>5. Demo</h1><p>本文所有的 Demo 代码都在 <a href="https://github.com/summertian4/iOS-ObjectiveC/tree/master/Pod-Resource-Reference">这里</a></p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">LottyLotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-资源文件引用的方式&quot;&gt;&lt;a href=&quot;#1-资源文件引用的方式&quot; class=&quot;headerlink&quot; title=&quot;1. 资源文件引用的方式&quot;&gt;&lt;/a&gt;1. 资源文件引用的方式&lt;/h1&gt;&lt;p&gt;在第一节，先来介绍一下 CocoaPods 两种资源文件引用的方式——&lt;code&gt;resource_bundles&lt;/code&gt; &amp;amp; &lt;code&gt;resources&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-1-resource-bundles&quot;&gt;&lt;a href=&quot;#1-1-resource-bundles&quot; class=&quot;headerlink&quot; title=&quot;1.1 resource_bundles&quot;&gt;&lt;/a&gt;1.1 resource_bundles&lt;/h2&gt;&lt;p&gt;&lt;code&gt;resource_bundles&lt;/code&gt; 允许定义当前 Pod 库的资源包的&lt;strong&gt;名称和文件&lt;/strong&gt;。用 hash 的形式来声明，key 是 bundle 的名称，value 是需要包括的文件的通配 patterns。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We strongly recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CocoaPods 官方强烈推荐使用 &lt;code&gt;resource_bundles&lt;/code&gt;，因为用 key-value 可以避免相同名称资源的名称冲突。&lt;/p&gt;
&lt;p&gt;同时建议 bundle 的名称至少应该包括 Pod 库的名称，可以尽量减少同名冲突&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;spec.ios.resource_bundle = &amp;#123; &lt;span class=&quot;string&quot;&gt;&amp;#x27;MapBox&amp;#x27;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;MapView/Map/Resources/*.png&amp;#x27;&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;spec.resource_bundles = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;#x27;MapBox&amp;#x27;&lt;/span&gt; =&amp;gt; [&lt;span class=&quot;string&quot;&gt;&amp;#x27;MapView/Map/Resources/*.png&amp;#x27;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;#x27;OtherResources&amp;#x27;&lt;/span&gt; =&amp;gt; [&lt;span class=&quot;string&quot;&gt;&amp;#x27;MapView/Map/OtherResources/*.png&amp;#x27;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一周阅读列表-2018</title>
    <link href="http://lottyzhou.com/2018/01/08/%E4%B8%80%E5%91%A8%E9%98%85%E8%AF%BB%E5%88%97%E8%A1%A8-2018/"/>
    <id>http://lottyzhou.com/2018/01/08/一周阅读列表-2018/</id>
    <published>2018-01-08T10:36:00.000Z</published>
    <updated>2021-10-11T09:40:59.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018-年-1-月-1-日"><a href="#2018-年-1-月-1-日" class="headerlink" title="2018 年 1 月 1 日 +"></a>2018 年 1 月 1 日 +</h1><p><del><a href="https://mp.weixin.qq.com/s/SqEHBOZUZ6UzFhrccLm39A">理解比特币(BitCoin)背后的区块链技术，这一篇文章就够了</a></del></p><p><del><a href="https://www.jianshu.com/p/01126437e8a4">Django权限机制的实现</a></del></p><p><del><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000">使用元类</a></del></p><p><del><a href="https://blog.seedlab.io/understanding-responder-chain/">Understanding Responder Chain</a></del></p><p><del><a href="https://cloud.tencent.com/developer/article/1006222">iOS 电量测试实践</a></del></p><p><del><a href="https://github.com/aozhimin/iOS-Monitor-Platform#power-consumption">iOS 性能监控 SDK —— Wedjat（华狄特）开发过程的调研和整理</a></del></p><p><del><a href="http://liujinlongxa.com/2016/12/20/%E4%BD%BF%E7%94%A8NSURLProtocol%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/">使用NSURLProtocol时要注意的一些问题</a></del></p><h1 id="2018-年-6-月-1-日"><a href="#2018-年-6-月-1-日" class="headerlink" title="2018 年 6 月 1 日 +"></a>2018 年 6 月 1 日 +</h1><p><a href="https://github.com/youngwind/blog/issues/108">图解 HTTPS：Charles 捕获 HTTPS 的原理</a></p><p><del><a href="http://blog.joyingx.me/2015/05/03/NSMutableArray%20%E5%8E%9F%E7%90%86%E6%8F%AD%E9%9C%B2/">NSMutableArray原理揭露</a></del></p><p><a href="http://gilnuy.github.io/2016/12/20/%E6%8E%A2%E7%A9%B6NSMutableDictinory%E5%92%8CNSMutableArray%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">探究NSMutableArray的实现原理</a></p><h1 id="2018-年-11-月-1-日"><a href="#2018-年-11-月-1-日" class="headerlink" title="2018 年 11 月 1 日 +"></a>2018 年 11 月 1 日 +</h1><p><del><a href="https://xiaozhuanlan.com/topic/4263189057">北美软件工程师面试简单介绍</a></del></p><p><del><a href="https://xiaozhuanlan.com/topic/0514769328">色彩第一课：自然人眼中的色彩</a></del></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018-年-1-月-1-日&quot;&gt;&lt;a href=&quot;#2018-年-1-月-1-日&quot; class=&quot;headerlink&quot; title=&quot;2018 年 1 月 1 日 +&quot;&gt;&lt;/a&gt;2018 年 1 月 1 日 +&lt;/h1&gt;&lt;p&gt;&lt;del&gt;&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="Other" scheme="http://lottyzhou.com/categories/Other/"/>
    
      <category term="阅读列表" scheme="http://lottyzhou.com/categories/Other/%E9%98%85%E8%AF%BB%E5%88%97%E8%A1%A8/"/>
    
    
      <category term="Other" scheme="http://lottyzhou.com/tags/Other/"/>
    
      <category term="ReadList" scheme="http://lottyzhou.com/tags/ReadList/"/>
    
  </entry>
  
  <entry>
    <title>iOS 灵活的 模块化/组件化 工具与规范 Lotusoot 解说</title>
    <link href="http://lottyzhou.com/2017/11/29/iOS-modularized-tool-Lotusoot/"/>
    <id>http://lottyzhou.com/2017/11/29/iOS-modularized-tool-Lotusoot/</id>
    <published>2017-11-29T02:40:41.000Z</published>
    <updated>2021-10-11T09:40:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>上一篇<a href="http://lottyzhou.com/2017/11/24/iOS-Modularization/">《iOS 混编 模块化/组件化 经验指北》</a>中介绍到的 <a href="https://github.com/Vegetarians/Lotusoot">Lotusoot</a> ，将在本篇中做一个更为详细的介绍。</p><p>最初 <a href="https://github.com/Vegetarians/Lotusoot">Lotusoot</a> 简称为『混编路由』，但是随后反而曲解了它的功能，其真正的定位是『模块化工具和规范』。</p><p> <a href="https://github.com/Vegetarians/Lotusoot">Lotusoot</a> 可以做到：</p><ol><li>模块间、模块内服务调用</li><li>Swift、OC、或者两者混编项目均可使用</li><li>短链注册、路由调用</li><li>脚本自动注册服务/路由表</li></ol><blockquote><p>注：这里的模块化，也就是大家说的『组件化』，不是在主工程用文件夹分模块，而是指将独立模块抽调成 CocoaPods 库、或者其他形式的库文件，成为一个独立工程。<br>下文中的模块就代表一个 CocoaPods 库</p></blockquote><span id="more"></span><h1 id="模块化解耦——路由-or-服务调用？"><a href="#模块化解耦——路由-or-服务调用？" class="headerlink" title="模块化解耦——路由 or 服务调用？"></a>模块化解耦——路由 or 服务调用？</h1><p>关于模块化，大多数人的第一反应是制作路由、注册短链、调用短链，通过这样的方式来去耦，来实现模块间的页面跳转、服务调用。类似 <a href="https://github.com/meili/MGJRouter">MGJRouter</a> 一类的库就是基于这样的思想。</p><p>但我也非常认可 <a href="https://casatwy.com/">casa</a> 在反驳使用 URL 作为模块化核心的理由。即：『短链的实质还是通过 URL 来调用服务或者打开页面，反而不如字符串直接，反而增加了 URL 本身的维护成本』。</p><p>所以，我们应当回归模块化的本质。我们模块化的最初的目的往往是为了：</p><ol><li>代码拆分，将<strong>关联性强的基础服务代码</strong>或者<strong>业务代码</strong>抽调在一起，单独封版，独立开发</li><li>防止主工程越来越大，变得臃肿</li></ol><p>相对应的，模块化需要的功能是：</p><ol><li>提供多个库之间的服务调用</li><li>保持库与库之间的独立、非强依赖</li></ol><p>所以，总的来说，模块化的重点还是如何<strong>去除多个模块之间的耦合，让每个模块在不强依赖的情况下可以调用其他模块的服务</strong>。</p><p><strong>URL 短链、甚至是路由、都不是模块化重点之处。</strong>路由只要你想，都可以通过服务注册实现。</p><blockquote><p>注：『不强依赖』指的是，模块A 调用 模块B 不需要在 Pod 依赖中写出对 B 的依赖，或者简单的认为，模块A 的代码中不出现 <code>import B</code>。</p></blockquote><h1 id="公共模块和依赖关系"><a href="#公共模块和依赖关系" class="headerlink" title="公共模块和依赖关系"></a>公共模块和依赖关系</h1><p>Lotusoot 是这样解耦的：</p><h2 id="1-Lotus"><a href="#1-Lotus" class="headerlink" title="1. Lotus"></a>1. Lotus</h2><p>创建一个 PublicModule，其中存放各个模块的 Lotus，Lotus 其实就是协议，定义了每个模块可以提供的服务（即可以调用的方法），举例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">AccountLotus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">login</span>(<span class="params">username</span>: <span class="type">String</span>, <span class="params">password</span>: <span class="type">String</span>, <span class="params">complete</span>: (<span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">register</span>(<span class="params">username</span>: <span class="type">String</span>, <span class="params">password</span>: <span class="type">String</span>, <span class="params">complete</span>: (<span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">email</span>(<span class="params">username</span>: <span class="type">String</span>)</span> -&gt; <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showLoginVC</span>(<span class="params">username</span>: <span class="type">String</span>, <span class="params">password</span>: <span class="type">String</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Lotusoot"><a href="#2-Lotusoot" class="headerlink" title="2. Lotusoot"></a>2. Lotusoot</h2><p>在各个模块中，实现 PublicModule 中对应的 Lotus，即具体的服务类，称为 Lotusoot。<br>Lotusoot 中具体实现了服务的逻辑，并在 <strong>注解</strong> 中表明了模块的 <code>命名空间-@NameSpace</code>、<code>Lotusoot-@Lotusoot</code>、<code>Lotus-@Lotus</code>。举例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @NameSpace(TestAccountModule)</span></span><br><span class="line"><span class="comment">// @Lotusoot(AccountLotusoot)</span></span><br><span class="line"><span class="comment">// @Lotus(AccountLotus)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountLotusoot</span>: <span class="title">NSObject</span>, <span class="title">AccountLotus</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">email</span>(<span class="params">username</span>: <span class="type">String</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">OtherService</span>.email(username: <span class="string">&quot;zhoulingyu&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">login</span>(<span class="params">username</span>: <span class="type">String</span>, <span class="params">password</span>: <span class="type">String</span>, <span class="params">complete</span>: (<span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">        <span class="type">LoginService</span>.login(username: username, password: password, complete: complete)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">register</span>(<span class="params">username</span>: <span class="type">String</span>, <span class="params">password</span>: <span class="type">String</span>, <span class="params">complete</span>: (<span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">        <span class="type">RegisterService</span>.register(username: username, password: password, complete: complete)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showLoginVC</span>(<span class="params">username</span>: <span class="type">String</span>, <span class="params">password</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 可以用你们喜欢的非耦合方式处理跳转</span></span><br><span class="line">        <span class="comment">// 或者传入 rootvc</span></span><br><span class="line">        <span class="comment">// 更好的方式是自己的非耦合 UI 跳转处理模块</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;show login view controller&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解是非必须的，注解是为了 <code>Lotusoot.py</code> 可以扫描 Lotusoot 自动注册，后面一节将会说到。如果你不想使用自动注册，也可以选择手动注册。</p><blockquote><p>注：这里做一点解释，『协议-服务类』即『Lotus-Lotusoot』的命名由来纯属卖个萌，因为，协议是暴露外部的，所以叫莲花，而具体实现的服务类自然就是莲藕（Loutsoot）了。</p></blockquote><h2 id="3-自动注册-or-手动注册"><a href="#3-自动注册-or-手动注册" class="headerlink" title="3. 自动注册 or 手动注册"></a>3. 自动注册 or 手动注册</h2><p>如果使用了注解，可以自动注册所有服务，只需要：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="type">LotusootCoordinator</span>.registerAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果先手动注册，如下所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[LotusootCoordinator registerWithLotusoot:[AppDelegateLotusoot new] lotusName:<span class="string">@&quot;AppDelegateLotus&quot;</span>];</span><br><span class="line">    [LotusootCoordinator registerWithLotusoot:[MainLotusoot new] lotusName:<span class="string">@&quot;MainLotus&quot;</span>];</span><br></pre></td></tr></table></figure><p>不过手动注册就是去了使用 Lotusoot 的意义了，所以在无法满足条件时再使用手动注册（比如目前 0.0.2 版本的 Lotusoot，主工程如果有多 Target，是无法动态获取 Target 名，导致无法正确获取命名空间，反射到类，当然除工程，各个模块由于使用 CocoaPos 不存在这个问题。下一个版本 Lotusoot 将会重点解决这个问题）</p><h2 id="4-关系图"><a href="#4-关系图" class="headerlink" title="4. 关系图"></a>4. 关系图</h2><p>通过 Lotusoot 搭建的工程如下图所示：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-modularized-tool-Lotusoot-003.png" alt=""></p><p>所有模块只需要依赖 PublicModule，通过 PublicMoudle 下的 Lotusoot 即可调用其他模块的服务。实例代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> loginLotus <span class="operator">=</span> s(<span class="type">LoginLotus</span>.<span class="keyword">self</span>) </span><br><span class="line"><span class="keyword">let</span> loginModule: <span class="type">LoginLotus</span> <span class="operator">=</span> <span class="type">LotusootCoordinator</span>.lotusoot(lotus: loginLotus) <span class="keyword">as!</span> <span class="type">LoginLotus</span></span><br><span class="line">loginModule.login(username: <span class="string">&quot;test&quot;</span>, password: <span class="string">&quot;test&quot;</span>, complete:<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>OC 中使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span>&lt;LoginLotus&gt; loginModule = [LotusootCoordinator lotusootWithLotus:<span class="string">@&quot;LoginLotus&quot;</span>];</span><br><span class="line">[loginModule login:<span class="string">@&quot;test&quot;</span> password:<span class="string">@&quot;test&quot;</span> complete:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h1 id="Lotusoot-是如何实现自动注册服务的？在什么时机？"><a href="#Lotusoot-是如何实现自动注册服务的？在什么时机？" class="headerlink" title="Lotusoot 是如何实现自动注册服务的？在什么时机？"></a>Lotusoot 是如何实现自动注册服务的？在什么时机？</h1><p>这个问题也是在编写 Lotusoot 最初重点考虑的问题。原因是 Swift 没有 <code>+(void)load</code>。</p><p>大概是每个用 Swift 开发模块路由和解耦工具的人都纠结过的问题。</p><h2 id="1-OC-中常见的解决方案"><a href="#1-OC-中常见的解决方案" class="headerlink" title="1. OC 中常见的解决方案"></a>1. OC 中常见的解决方案</h2><p>先说说通常 OC 的路由或者解耦，都是在 <code>+(void)load</code> 注册类服务的，大致的做法类似于：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[Router shared] map:<span class="string">@&quot;LoginViewController&quot;</span> toController:[<span class="keyword">self</span> <span class="keyword">class</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[ServiceManager shared] <span class="keyword">register</span>:<span class="string">@&quot;LoginService&quot;</span> toService:[<span class="keyword">self</span> <span class="keyword">class</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，即使是在每个模块内，也可以正常注册自己的服务。而主工程和其他模块调用只需要通过字符串调用即可。</p><h2 id="2-Swift-中的痛点"><a href="#2-Swift-中的痛点" class="headerlink" title="2. Swift 中的痛点"></a>2. Swift 中的痛点</h2><p>由于 Swift 是没有 <code>+(void)load</code> 的，也没有其他可靠的方法可以替代，那么势必需要在主工程中加入注册路由这一步骤，通常可以放在 <code>didFinishLaunchingWithOptions</code>，因为主模块可以调到所有模块的类。那么随之而来的问题就是，你可能会出现这样常常的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServiceManager</span>().register(<span class="string">&quot;LoginService&quot;</span>, toService:<span class="type">LoginService</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="type">ServiceManager</span>().register(<span class="string">&quot;UserCenterService&quot;</span>, toService:<span class="type">UserCenterService</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="type">ServiceManager</span>().register(<span class="string">&quot;HistoryService&quot;</span>, toService:<span class="type">HistoryService</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure><p>可能会有一张长长的列表，而且由于服务都分散在各个模块，但是却集中在主模块，往往难以看到路由表和服务类的关联，表征不够明显、关系不够强烈。</p><h2 id="3-Lotusoot-的解决方案"><a href="#3-Lotusoot-的解决方案" class="headerlink" title="3. Lotusoot 的解决方案"></a>3. Lotusoot 的解决方案</h2><p>有什么更好的办法注册？<a href="http://www.jianshu.com/u/2d46948e84e3">mmoaay</a> 给了我一个灰常棒的建议，参考 <a href="https://github.com/mac-cain13/R.swift">R.swift</a> 的做法，通过脚本，来完成自动注册。</p><blockquote><p><a href="https://github.com/mac-cain13/R.swift">R.swift</a> 的提供的功能是，可以让使用的 iOSer 可以像开发 Android 的一样调用图片、字符串、音频等等资源文件。在 Project 中插入 Run Script，这个脚本可以在编译阶段扫描整个工程，列算所有的资源文件，最后生成一个 <code>R.generated.swift</code> 文件，就像这个样子：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-modularized-tool-Lotusoot-001.png" alt=""></p><p>使用的时候就可以：</p><p><img src="https://github.com/mac-cain13/R.swift/raw/master/Documentation/Images/DemoUseImage.gif" alt=""></p></blockquote><p><strong>同样 Lotusoot 通过一个 python 脚本，在『Compile Source』之前扫描工程目录下的文件，找出 Lotusoot 和 Lotus 对应关系，并生成一个 <code>Lotusoot.plist</code> 文件</strong>：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-modularized-tool-Lotusoot-004.png" alt=""></p><p>如何识别 Lotus？</p><p>目前，Lotusoot 使用了很 Low 的方式，在注解中表明了模块的 <code>命名空间-@NameSpace</code>、<code>Lotusoot-@Lotusoot</code>、<code>Lotus-@Lotus</code>，脚本就可以识别。举例如下：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-modularized-tool-Lotusoot-002.png" alt=""></p><p>所以，<code>didFinishLaunchingWithOptions</code> 只需要一句，即可自动注册路由。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LotusootCoordinator</span>.registerAll()</span><br></pre></td></tr></table></figure><p>为什么使用脚本解决？是因为到目前为止，所有的解耦工具或者路由都是通过程序员手动去写代码添加路由，不管是在 <code>+ (void)load</code> 中注册也好，在程序启动后注册也好，都是有程序员手动管理的。使用脚本是希望在编译阶段前，就准备好所有的『协议-服务类』对应关系表，在程序启动后通过这张表自动注册，<strong>实现程序员不手动注册、完全无感</strong>。我觉得这才是真正的解耦工具应当具备的功能。</p><h1 id="Lotusoot-的重大缺点和下一版本目标"><a href="#Lotusoot-的重大缺点和下一版本目标" class="headerlink" title="Lotusoot 的重大缺点和下一版本目标"></a>Lotusoot 的重大缺点和下一版本目标</h1><p>Lotusoot 的缺点是显而易见的，虽然通过脚本可以在编译阶段创建好『协议-服务类』关系表。但 <code>Lotusoot.py</code> 识别『协议-服务类』是通过注解来的，而这里的注解其实就是注释，不能编译检测错误，及时误写错也无法及时检查出问题。如果解决了这一痛点，就可以相对完美的解决了 Swift 的模块化方案。</p><p>目前的思路如下：</p><p>尝试通过全局方法或是其他语法方式实现真正的注解，可以像 Java 中的注解一样，不仅可以作为一种标识，也可以进行编译检查。</p><p>其实 OC 中是可以直接用宏定义做的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="type">Service</span>(_name_) \</span><br><span class="line"><span class="operator">+</span> (void)load &#123; \</span><br><span class="line">    [<span class="keyword">self</span> registerService:_name_]; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">@Service</span>(@<span class="string">&quot;LoginService&quot;</span>)</span><br><span class="line"><span class="meta">@implementation</span> <span class="type">LoginService</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure><p>但 Lotusoot 是提供给 Swift 和 OC 以及混编项目都可以使用的，所以实现方案还需要我继续探索。</p><p>另一种方式可以使用 LLVM 是提供了 @annotation 操作的，如果通过这种方式生成 <code>.plist</code> 的注册列表文件应该会放到编译结束时。</p><p>以上，是以后的一些构思，希望可以完美的解决 Swift 模块化方案。<strong>如果你有什么好的建议，都可以来找我讨论哦~~~</strong></p><h1 id="Demo-和-Github"><a href="#Demo-和-Github" class="headerlink" title="Demo 和 Github"></a>Demo 和 Github</h1><p>如果想更清晰的感受 Lotusoot 带来的模块化改造，请必须下载 <a href="https://github.com/Vegetarians/Lotusoot/tree/master/Demo">Demo</a> 来看哟。</p><p>总项目的地址在<a href="https://github.com/Vegetarians/Lotusoot">这里</a>。</p><p>非常欢迎一起讨论（卖萌~~）</p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h1&gt;&lt;p&gt;上一篇&lt;a href=&quot;http://lottyzhou.com/2017/11/24/iOS-Modularization/&quot;&gt;《iOS 混编 模块化/组件化 经验指北》&lt;/a&gt;中介绍到的 &lt;a href=&quot;https://github.com/Vegetarians/Lotusoot&quot;&gt;Lotusoot&lt;/a&gt; ，将在本篇中做一个更为详细的介绍。&lt;/p&gt;
&lt;p&gt;最初 &lt;a href=&quot;https://github.com/Vegetarians/Lotusoot&quot;&gt;Lotusoot&lt;/a&gt; 简称为『混编路由』，但是随后反而曲解了它的功能，其真正的定位是『模块化工具和规范』。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/Vegetarians/Lotusoot&quot;&gt;Lotusoot&lt;/a&gt; 可以做到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模块间、模块内服务调用&lt;/li&gt;
&lt;li&gt;Swift、OC、或者两者混编项目均可使用&lt;/li&gt;
&lt;li&gt;短链注册、路由调用&lt;/li&gt;
&lt;li&gt;脚本自动注册服务/路由表&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;注：这里的模块化，也就是大家说的『组件化』，不是在主工程用文件夹分模块，而是指将独立模块抽调成 CocoaPods 库、或者其他形式的库文件，成为一个独立工程。&lt;br&gt;下文中的模块就代表一个 CocoaPods 库&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://lottyzhou.com/categories/iOS/"/>
    
      <category term="iOS模块化" scheme="http://lottyzhou.com/categories/iOS/iOS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
      <category term="iOS" scheme="http://lottyzhou.com/tags/iOS/"/>
    
      <category term="iOS模块化" scheme="http://lottyzhou.com/tags/iOS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS 混编 模块化/组件化 经验指北</title>
    <link href="http://lottyzhou.com/2017/11/24/iOS-Modularization/"/>
    <id>http://lottyzhou.com/2017/11/24/iOS-Modularization/</id>
    <published>2017-11-24T03:03:52.000Z</published>
    <updated>2021-10-11T09:40:59.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1. 开篇"></a>1. 开篇</h1><p>本文的初衷，是为了给正在做混编或者模块化的同学们一个建议和参考。</p><p>因为来饿厂以后做的项目是全公司唯一一个 Swift/OC 混编的 iOS 项目，所以一路上踩坑无数，现在把一些踩坑的过程和经验总结起来，供大家参考。</p><p>相信在浏览本文后，一定会有所收获。</p><p>我来的时候项目已经开始 Swift 改造了，慢慢的把项目 Swift 化，新代码都是 Swift 的。</p><p>先公布七个月成果，下图是我们最终的项目结构：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-Modularization-03.png" alt=""></p><p>对于我们混编的情况，在五个月前大家就展开了讨论。</p><p>给我们的选择有两种：</p><ol><li>慢慢将 OC 代码替换成 Swift</li><li>尽快模块化，分离两种语言代码</li></ol><p>一开始我们是从 <code>选择1</code> 开始做的，但是很快我们就发现，对于我们 74% 都是 OC 代码的项目来说，太痛了，太漫长了，而且期间迭代的过程中还在不断地迭代，不断的耦合。</p><p>所以在经过一番利害分析后我们迅速投入到了 <code>选择2</code> 中。一方面，模块化本身就是越来越臃肿的项目的最终归宿，一方面可以慢慢将两种语言剥离。</p><span id="more"></span><blockquote><p>注：这里的模块化，也就是大家说的『组件化』，不是在主工程用文件夹分模块，而是指将独立模块抽调成 CocoaPods 库、或者其他形式的库文件，成为一个独立工程。</p></blockquote><h1 id="2-模块划分"><a href="#2-模块划分" class="headerlink" title="2. 模块划分"></a>2. 模块划分</h1><p><strong>刀怎么切，是混编模块化最重要的一步</strong>，完全决定了后续工作的难与否。</p><p>不用从业务模块拆分，类似『实时订单模块』、『历史订单模块』、『个人中心』这样直接拆分，保准你后面哭到无法自已。</p><p>正确的做法应该从底层部分开始抽离，首先能想到的应该是『类扩展 Extension』、『工具类』、『网络库』、『DB 管理』（当然这个我们没有用到比较重的 DB）。</p><p>平常我们看到一些大型库，或者一些公司介绍自己产品架构时候都是什么样的？是不是下层有 OpenGL ES 和 Core Graphics 才有上层 Core Animation，再到 UIKit。下层决定上层，只有把复用率高的部分抽出才能逐步构建上层业务。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-Modularization-01.png" alt=""></p><p>所以首先我们做的就是抽工具类和 Extension，诸如：</p><ol><li>各类 Constants 文件</li><li><code>NSTimer</code>、<code>NSString</code>、<code>UILabel</code> 等等类的 Extension</li><li><code>RouterHelper</code>、<code>JavascripInterface</code> 等等 Utils 和 Helper</li></ol><p>这一块的工作，不仅仅可以抽出 OC 代码，也同时可以抽出 Swift 的代码。我们将 OC 部分的代码新建了库为 <code>LPDBOCFoundationGarbage</code>，Swift 部分的代码新建库为 <code>LPDBPublicModule</code>。</p><h2 id="2-1-LPDBOCFoundationGarbage"><a href="#2-1-LPDBOCFoundationGarbage" class="headerlink" title="2.1 LPDBOCFoundationGarbage"></a>2.1 LPDBOCFoundationGarbage</h2><p>先说 <code>LPDBOCFoundationGarbage</code>，叫这个名字显然不仅仅会放入上面所提到的文件。<code>LPDBOCFoundationGarbage</code> 还会<strong>大量放入长期不跟随业务变动的 OC 代码</strong>。这是因为，在实践中，我们发现总是『理想很美好』，虽然大家都抱有把旧代码整理一遍的愿望，但是实际上，我们项目的旧代码已经到了剪不断理还乱的地步，所以期望一边整理、一边分离的想法基本是不可靠的。这时候就要借用 <a href="https://github.com/mmoaay">MM</a> 大佬给我们传授的一句话『让恶心的代码恶心到一起』，<code>LPDBOCFoundationGarbage</code> 正是为此而创建。</p><p><strong>大量放入长期不跟随业务变动的 OC 代码</strong>包括：</p><ol><li>自定义的 Customer View，诸如：Refresh 控件、Loading 控件、红点控件等等</li><li>自定义的小型控制器，诸如：TextField 和其五六个过滤器 PhoneNumValidator、IDCardValidator 等等</li><li>不随业务变动的 Controller，诸如：自定义的 AlertController、自定义的 WebController、自定义的 BaseViewController 等等</li></ol><p>最后我们的一级列表看起来就像这样：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-Modularization-04.png" alt=""></p><blockquote><p>关于前缀说两句。我们所有抽出的库都带有前缀 <code>LPDB</code>，但是针对 Swift 库和 OC 库稍有区分的是，OC 库内的文件也都带有前缀，而 Swift 库是去掉了前缀，这也符合两种语言的规范。</p></blockquote><h2 id="2-2-LPDBPublicModule"><a href="#2-2-LPDBPublicModule" class="headerlink" title="2.2 LPDBPublicModule"></a>2.2 LPDBPublicModule</h2><p><code>LPDBPublicModule</code> 情况很简单，主要是新业务迭代时候产生的一些复用性高的代码，但是这显然和 OC 那个垃圾桶库不一样，要干净整洁的多。主要存放的是：</p><ol><li>Swift Extension</li><li><a href="https://github.com/Vegetarians/Lotusoot">Lotusoot</a> 及其他公开协议</li></ol><blockquote><p><a href="https://github.com/Vegetarians/Lotusoot">Lotusoot</a> 是个由我开发的模块化工具和规范，一开始我叫它『路由』，但是随后发现部门这边因为叫它『路由库』而曲解了它的意思，所以后来我就叫『模块化工具』了。关于 Lotusoot 可以查看<a href="http://lottyzhou.com/2017/11/29/iOS-modularized-tool-Lotusoot/">这篇</a>。</p></blockquote><h2 id="2-3-LPDBNetwork"><a href="#2-3-LPDBNetwork" class="headerlink" title="2.3 LPDBNetwork"></a>2.3 LPDBNetwork</h2><p>这块毋庸置疑，不管什么项目都基本有的一块，基本上我们项目中网络相关的旧代码都是 OC 的，唯一比较麻烦的是，我们的网络层，早期人员写的比较粗糙，甚至和 UI 层代码有很多耦合，比如网络请求中和网络请求失败有一些 HUD 显示，转转菊花什么的。所以导致在从主工程抽离的时候有很多恶心的地方。</p><p><strong>所以对于这种强耦合，最后解决的方式是分成了两遍代码改造，第一遍先通过反射先将 OC 代码抽出，保证代码可用，通过基础测试。第二遍是通过协议来代替原先的反射。第三遍是使用 <a href="https://github.com/Vegetarians/Lotusoot">Lotusoot</a> 彻底规范服务调用。在后面一节『过程中的一些难点总结』中会介绍</strong></p><h2 id="2-4-LPDBUIKit"><a href="#2-4-LPDBUIKit" class="headerlink" title="2.4 LPDBUIKit"></a>2.4 LPDBUIKit</h2><p>这块是 Swift 的 UI 库，一些比较常用到的控件等等。</p><h2 id="2-5-LPDBEnvironment"><a href="#2-5-LPDBEnvironment" class="headerlink" title="2.5 LPDBEnvironment"></a>2.5 LPDBEnvironment</h2><p>这块是用于环境控制的，切换要访问的服务器环境，这块本身可以不抽出的，但是由于有其他基础模块，比如 <code>LPDBNetwork</code> 依赖，而且其中相关代码比较多，环境相关的代码也比较独立，所以单独抽出。</p><h1 id="3-业务模块抽离"><a href="#3-业务模块抽离" class="headerlink" title="3. 业务模块抽离"></a>3. 业务模块抽离</h1><p>到这里为止，比较底层的代码就基本抽出结束了，剩下的就可以较为轻松一些的抽取业务库了。</p><p>抽取业务库的重点在于：</p><ol><li>抽取的业务库不会经常改动，以防止在抽取、重构过程中由于业务需求发生更动</li><li>抽取的业务库可以高度独立，抽取后应当和积木一样，如 <code>LPDBLoginModule</code>，抽取后快速被集成在任何模块，并能保证登录功能，更好的服务其他模块</li></ol><p>我们目前抽出的三个业务模块分别是： <code>LPDBHistoryModule</code>、<code>LPDBUserCenterModule</code>、<code>LPDBLoginModule</code>。</p><h1 id="4-过程中的一些重难点"><a href="#4-过程中的一些重难点" class="headerlink" title="4. 过程中的一些重难点"></a>4. 过程中的一些重难点</h1><p>剩下的就是，来说一下在这个过程中的疑难问题。</p><h2 id="4-1-处理模块耦合代码-反射调用"><a href="#4-1-处理模块耦合代码-反射调用" class="headerlink" title="4.1 处理模块耦合代码-反射调用"></a>4.1 处理模块耦合代码-反射调用</h2><p>抽取代码第一遍使用反射的原因主要是，通常你在递归某个文件的依赖的时候，会递归出非常多的东西（尤其是我们的蜜汁旧代码），往往就是 <strong>A-&gt;B-&gt;C-&gt;D-&gt;F</strong>，中间有各种依赖，甚至到最后一层的时候还引用了 Swift 的类。直到最后你看 <code>#import</code> 就想吐。给个图感受一下：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-Modularization-05.png" alt=""></p><p>为什么没有办法一步到位，通过协议解决耦合？</p><p>这主要是因为单个 Pod 库开发时使用开发模式是很容易调试的，但是两个 Pod 库同时在不发版本的情况下使用开发模式是比较难处理的（可以参考<a href="http://www.pluto-y.com/cocoapod-private-pods-and-module-manager/">这篇文章</a>中『使用私有库』一节）。这种情况下，反复操作两个或者两个以上的库是麻烦的，所以优先考虑将代码尽快分离开来，并能通过基本测试，不影响功能。</p><p>所以在这一遍处理结束后，子库中出现了很多 <code>NSClassFromString</code> 等等。</p><p>以 <code>LPDBLoginMoudle</code> 为例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *className = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@.`AuthLoginManager&quot;</span>, [<span class="built_in">NSString</span> targetName]];</span><br><span class="line"><span class="keyword">id</span> authLoginManager = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line"><span class="keyword">if</span> (![authLoginManager conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">authLoginSuccess</span>)]) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">[authLoginManager authLoginSuccess];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> delegate = [[<span class="built_in">UIApplication</span> sharedApplication] delegate];</span><br><span class="line">[delegate jumpToShopListVC:shops];</span><br></pre></td></tr></table></figure><h2 id="4-2-处理模块耦合代码-协议调用"><a href="#4-2-处理模块耦合代码-协议调用" class="headerlink" title="4.2 处理模块耦合代码-协议调用"></a>4.2 处理模块耦合代码-协议调用</h2><p>保持第一遍中充满 <code>NSClassFromString</code>  是不可取的，因为这类代码往往属于硬编码，不能在类名出现改动、或者方法名出现改动的时候及时在编译阶段抛出 error。</p><p>在这里引出一段讨论。</p><p>之前跟大神们讨论组件化（模块化）的具体实践时候，说到了主流的组件化可能都借用了 <code>+ (void)load</code> 方法和 rumtime 操作来注册路由和服务。这时候 <a href="https://casatwy.com/">casa</a> 大神提出了一种说法『组件化的根本目的是隔离、隔离问题影响域、隔离业务、隔离开发时的依赖。所以让两个本来有关系的人变得没有关系，就需要一个中间人，如果不用 runtime 能省掉不少事，但是用 URL 是一件相对来说比较多余的事，一个包含了 target-action 的字符串就足够了，URL 是字符串的更复杂表征，target-action 的意义体现的更明显。同时 URL 应该仅限于 H5 调度和跨 App 的 URL Scheme 调度』。</p><blockquote><p>这里要向 <a href="https://casatwy.com/">casa</a> 大神非常非常郑重的道歉，上面一段，原来在第一版的时候是预留修改的片段，本想再读一遍大神 <a href="https://casatwy.com/iOS-Modulization.html">《 [iOS应用架构谈 组件化方案]》</a> 仔细理解以后再次修改这块，本来是悄咪咪的发了文章，没想到被推送出去了，有引导大家曲解大神的愿意。非常非常抱歉！现在已经修改。<br>下面在贴上大佬自己对 URL 的见解：</p></blockquote><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-Modularization-09.png" alt=""></p><p>那个时候听了 casa 大神的说法觉得『哎？有道理』，但是在后期的实践中，我觉得就我个人的代码习惯，是希望尽可能的将问题暴露在编译阶段，能让它抛出 error 就抛出 error，纵使使用字符串可以定义常量，但由于大家不是独立负责项目，在其他人看到你的方法参数时，比如：<code>+ (void)callService:(NSString *)sUrl</code> 或者 <code>+ (void)openURL:(NSString *)url</code> ，对方发现你的参数是 NSStrring，很有可能直接出现硬编码字符串而不去查阅常量列表，这是习惯性编码很容易出现的问题。但我对 casa 『URL 没有 target-action 表征明显』是非常仍可的，所以 Lotusoot 的重点只在于解耦的服务调用，URL 只是为了更好的为 H5 页面提供外部调用服务，在工程内部大可使用更加简洁的方式。</p><p>最后一点原因是，反射或者通过类/方法字符串字典的方式实在太 OC 了，不管怎么样我们是一个尽量 Swift 化的项目，应该尽量吸取其优点，虽然抽出的 OC 库可以使用反射，那 Swift 库咋办？目前 Swift3 与 4 都没有很好的支持反射。</p><p>所以，第二遍处理使用协议替换反射是很有必要的。但实质上，处理的并不是很好。大致如下（我们以 <code>LPDBLoginModule</code> 为例）：</p><h3 id="4-2-1-在-LPDBLoginModule-整理用到的服务，归类整理"><a href="#4-2-1-在-LPDBLoginModule-整理用到的服务，归类整理" class="headerlink" title="4.2.1 在 LPDBLoginModule 整理用到的服务，归类整理"></a>4.2.1 在 LPDBLoginModule 整理用到的服务，归类整理</h3><p>如我们的 <code>LPDBLoginModule</code> 用到了 AppDelegate 中的一些方法，同事用到了 AuthLogin 相关类中的一些方法</p><h3 id="4-2-2-在-LPDBLoginModule-中建立相应的协议"><a href="#4-2-2-在-LPDBLoginModule-中建立相应的协议" class="headerlink" title="4.2.2 在 LPDBLoginModule 中建立相应的协议"></a>4.2.2 在 LPDBLoginModule 中建立相应的协议</h3><p>即建立 <code>AuthLoginDelegate.h</code> 和 <code>AppDelegateProtocol</code></p><p>大致的代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AppDelegateProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)jumpToHomeVC;</span><br><span class="line">- (<span class="keyword">void</span>)jumpToShopListVC:(<span class="built_in">NSArray</span> *)shops;</span><br><span class="line">- (<span class="built_in">CLLocationCoordinate2D</span>)getCoordinate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AuthLoginDelegate</span> &lt;<span class="title">NSObject</span>&gt;[<span class="title">Pods</span>](<span class="title">media</span>/<span class="title">Pods</span>.)</span></span><br><span class="line">+ (<span class="keyword">void</span>)authLoginSuccess;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="4-2-3-在主工程中去实现协议"><a href="#4-2-3-在主工程中去实现协议" class="headerlink" title="4.2.3 在主工程中去实现协议"></a>4.2.3 在主工程中去实现协议</h3><p>AppDelegateProtocol 由 AppDelegate 扩展实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> LPDBLoginModule;</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> (<span class="title">Protocol</span>)  &lt;<span class="title">AppDelegateProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span> (<span class="title">Protocol</span>)</span></span><br><span class="line">- (<span class="built_in">CLLocationCoordinate2D</span>)getCoordinate &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)jumpToHomeVC &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)jumpToShopListVC:(<span class="built_in">NSArray</span> *)shops &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>AuthLoginDelegate 由 AuthLoginManager(这个 Manager 在主工程中是 swift 编写的) 实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AuthLoginManager</span>: <span class="title">AuthLoginDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">authLoginSuccess</span>()</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-在-LPDBLoginModule-调用服务"><a href="#4-2-4-在-LPDBLoginModule-调用服务" class="headerlink" title="4.2.4 在 LPDBLoginModule 调用服务"></a>4.2.4 在 LPDBLoginModule 调用服务</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> delegate = [[<span class="built_in">UIApplication</span> sharedApplication] delegate];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (![delegate conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">AppDelegateProtocol</span>)]) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CLLocationCoordinate2D</span> coordinate = [delegate coordinate];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *className = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@.AuthLoginManager&quot;</span>, [<span class="built_in">NSString</span> targetName]];</span><br><span class="line"><span class="keyword">id</span> authLoginManager = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line"><span class="keyword">if</span> (![authLoginManager conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">LPDBAuthLoginDelegate</span>)]) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">[authLoginManager authLoginSuccess];</span><br><span class="line">[<span class="keyword">self</span> jumpToSelectShopView:shops];</span><br></pre></td></tr></table></figure><p>经过这些改造之后，模块间的状态如图所示：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-Modularization-06.png" alt=""></p><p>但是，可以很明显感受到，这次的改变并不彻底：</p><ol><li>还是存在大量的 <code>![delegate conformsToProtocol:@protocol(AppDelegateProtocol)]</code> 这样的判断，仅仅是起到了容错，保证不会 crash，但是却不能将问题暴露在编译阶段。</li><li><code>AppDelegateProtocol</code> 明明是一个公共的，多个模块使用的协议，却被定义到了 <code>LPDBLoginModule</code></li><li>概念颠倒，理想状态下，应该是各个子模块提供协议和实现，告知其他模块可以调用该模块哪些功能。而目前是子模块告知其他模块需要调用哪些方法，由其他模块实现。</li></ol><p>那么为了彻底解决问题，我们引入了 <a href="https://github.com/Vegetarians/Lotusoot">Lotusoot —— 组件通信和工具</a>。</p><h2 id="4-3-处理模块耦合代码-Lotusoot"><a href="#4-3-处理模块耦合代码-Lotusoot" class="headerlink" title="4.3 处理模块耦合代码-Lotusoot"></a>4.3 处理模块耦合代码-Lotusoot</h2><p> <a href="https://github.com/Vegetarians/Lotusoot">Lotusoot</a> 的最初目的就是为了解决模块间的耦合，并且同时支持 OC 和 Swift 使用，也是这几个月中去做的一个比较重要的东西，库本身小巧灵活，包含的东西也很少，但是起到的规范作用却是我非常满意的一点。</p><p>Lotusoot 规范的核心思想主要是以下几步，我们同样使用上面的 <code>LPDBLoginModule 为例</code>：</p><h3 id="4-3-1-建立共用模块——LPDBPublicModule"><a href="#4-3-1-建立共用模块——LPDBPublicModule" class="headerlink" title="4.3.1 建立共用模块——LPDBPublicModule"></a>4.3.1 建立共用模块——LPDBPublicModule</h3><p><code>LPDBPublicModule</code>中定义了各个模块可以提供的服务，做成协议，称为 Lotus，一个 Lotus 协议包含了一个模块的所有的能调用的方法的列表。举例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">AppDelegateLotus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">jumpToHomeVC</span>()</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">jumpToSelectShopVC</span>(<span class="params">shops</span>: [<span class="keyword">Any</span>], <span class="params">isNapos</span>: <span class="type">Bool</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getCoordinate</span>()</span> -&gt; <span class="type">CLLocationCoordinate2D</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MainLotus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">authLoginSuccess</span>()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-各个模块中，实现-LPDBPublicModule-中对应的-Lotus-协议"><a href="#4-3-2-各个模块中，实现-LPDBPublicModule-中对应的-Lotus-协议" class="headerlink" title="4.3.2 各个模块中，实现 LPDBPublicModule 中对应的 Lotus 协议"></a>4.3.2 各个模块中，实现 LPDBPublicModule 中对应的 Lotus 协议</h3><p>实现协议的 Class 称为 Lotusoot。举例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegateLotusoot</span>: <span class="title">NSObject</span>, <span class="title">AppDelegateLotus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">jumpToHomeVC</span>()</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">jumpToSelectShopVC</span>(<span class="params">shops</span>: [<span class="keyword">Any</span>], <span class="params">isNapos</span>: <span class="type">Bool</span>)</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getCoordinate</span>()</span> -&gt; <span class="type">CLLocationCoordinate2D</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainLotusoot</span>: <span class="title">NSObject</span>, <span class="title">MainLotus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">authLoginSuccess</span>()</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-注册服务"><a href="#4-3-3-注册服务" class="headerlink" title="4.3.3 注册服务"></a>4.3.3 注册服务</h3><p><strong>需要着重说明的是，这一步是可以省略的，通过 Lotusoot 提供的脚本和注解，可以自动为所有的路由进行注册。请移步 <a href="https://github.com/Vegetarians/Lotusoot">Lotusoot</a>参考『3. 注解与规范』部分。</strong></p><p><code>didFinishLaunchingWithOptions</code> 中注册服务：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[LotusootCoordinator registerWithLotusoot:[AppDelegateLotusoot new] lotusName:<span class="string">@&quot;AppDelegateLotus&quot;</span>];</span><br><span class="line">    [LotusootCoordinator registerWithLotusoot:[MainLotusoot new] lotusName:<span class="string">@&quot;MainLotus&quot;</span>];</span><br></pre></td></tr></table></figure><h3 id="4-3-3-在其他模块中调用服务"><a href="#4-3-3-在其他模块中调用服务" class="headerlink" title="4.3.3 在其他模块中调用服务"></a>4.3.3 在其他模块中调用服务</h3><p>现在只需要 <code>import Lotusoot</code>、<code>import ModulePublic</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span>&lt;MainLotus&gt; mainModule = [LotusootCoordinator lotusootWithLotus:<span class="string">@&quot;MainLotus&quot;</span>];</span><br><span class="line">[mainModule authLoginSuccess];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果使用字符串 @&quot;AppDelegateLotus&quot; 注册，建议定义在 LPDBPublicModule</span></span><br><span class="line"><span class="comment">// 也可以使用 NSStirngFromClass(AppDelegateLotus.class)</span></span><br><span class="line"><span class="keyword">id</span>&lt;AppDelegateLotus&gt; appDelegateLotus = [LotusootCoordinator lotusootWithLotus:<span class="string">@&quot;AppDelegateLotus&quot;</span>];</span><br><span class="line">[appDelegateLotus goToHomeVC];</span><br></pre></td></tr></table></figure><p>无论 OC 还是 Swift，都可以顺畅调用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或者使用类似字符串 &quot;AccountLotus&quot;，但需要你管理好 kAccountLotus，尽量不要硬编码</span></span><br><span class="line"><span class="keyword">let</span> appDelegateLotus <span class="operator">=</span> s(<span class="type">AppDelegateLotus</span>.<span class="keyword">self</span>) </span><br><span class="line"><span class="keyword">let</span> appDelegateLotusoot: <span class="type">AppDelegateLotus</span> <span class="operator">=</span> <span class="type">LotusootCoordinator</span>.lotusoot(lotus: appDelegateLotus) <span class="keyword">as!</span> <span class="type">AppDelegateLotus</span></span><br><span class="line">accountModule.goToHomeVC()</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mainLotus <span class="operator">=</span> s(<span class="type">MainLotus</span>.<span class="keyword">self</span>) </span><br><span class="line"><span class="keyword">let</span> mainModule: <span class="type">MainLotus</span> <span class="operator">=</span> <span class="type">LotusootCoordinator</span>.lotusoot(lotus: mainLotus) <span class="keyword">as!</span> <span class="type">MainLotus</span></span><br><span class="line">mainModule.authLoginSuccess()</span><br></pre></td></tr></table></figure><p>到此为止，就比较完整的解决了模块间耦合。清爽的风格用一张图表示就是这样（这是我在做 Lotusoot 解说时候用的一张配图）：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-Modularization-07.png" alt=""></p><p><code>LPDBPublicModule</code> 中的 <code>Lotus</code> 协议，像一张清单列出了所有模块提供的服务声明，而在各个模块中，直接通过这些公共协议就可以调用想要的服务。很多问题都可以在编译前和编译阶段显示出来（如果模块不提供服务，是不能通过编译的；如果没有一项服务没有声明，是不能通过编译的）。</p><h2 id="4-4-语言耦合"><a href="#4-4-语言耦合" class="headerlink" title="4.4 语言耦合"></a>4.4 语言耦合</h2><p>我们抽模块中一个重要的目的就是『分割两种语言』，但是实践过程中，会发现，分割语言比分割业务还要难。</p><p>一个 Pod 库中只能包含一种语言，但往往，在抽离代码的最后，会发现有无数的<strong>基础 Model 耦合</strong>，如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ShopInfo</span> : <span class="title">LPDBModel</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) DeliveryService *workingProduct;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) DeliveryService *preEffectiveProduct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeliveryService</span>: <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要将 <code>ShopInfo</code> 和 <code>DeliveryService</code> 抽出到一个模块时，必须要『有舍有得』，在涉及到基础 Model 语言不同时，可以适当的重写，因为 Model 的代码量是极小的，Model 通常也只包含属性声明，作为数据传输的中介，即使更改，产生的不可预支错误的可能性也较低。</p><p>如果要抽出的模块主体使用 OC，那么可以将 <code>DeliveryService</code> 重新用 OC 编写。</p><p>但要注意，要先尽量通过拆分更基础的服务模块，在考虑重新编写文件，保证项目的稳定性。</p><h2 id="4-5-模块的积木化"><a href="#4-5-模块的积木化" class="headerlink" title="4.5 模块的积木化"></a>4.5 模块的积木化</h2><p>模块化的最终目的，不仅仅是去耦，还应当让每个模块像积木一样，随意拼接，最后达到主工程完全没有代码，通过 Pod 集成各个模块，组成完整的功能。而每个模块也应当可以独立测试，独立开发。</p><p>还是以 <code>LPDBLoginModule</code> 和 <code>LPDBNetWort</code> 为例。</p><p>登录模块是一个非常特殊的模块，所有的子模块如果想独立测试和开发，一般都需要通过登录验证，比如订单模块，必须要登录后，该业务模块内能才能正确的拉取订单信息。</p><p>由于 <code>LPDBLoginModule</code> 依赖基础库 <code>LPDBNetWort</code>，<code>LPDBNetWort</code> 需要做的有：</p><ol><li>包含 cer 文件，可以正确的提供给其他模块正常的 https 接口访问</li><li>便利的网络服务调用</li></ol><p>而 <code>LPDBLoginModule</code> 至少要做的事有：</p><ol><li>可以正确的保存登录信息，完成登录操作</li><li>提供登录的 UI 界面，可以直接调用 LoginVC</li></ol><p>在具备以上功能后，<code>LPDBLoginModule</code> 就可以快速的集成进其他模块，为其他模块提供独立开发、独立测试的功能。</p><h2 id="4-6-资源打包"><a href="#4-6-资源打包" class="headerlink" title="4.6 资源打包"></a>4.6 资源打包</h2><p>上一小结提到『 <code>LPDBLoginModule</code> 要提供登录的 UI 界面』。对于 UI 界面，需要做的是资源打包，在模块拆分中，要非常注意资源分割。</p><p><em><strong>因为业务模块的划分，不仅仅是是代码抽出，也有资源抽出。</strong></em></p><p>资源库包括但不仅限于：</p><ol><li><code>.xib</code> 文件</li><li>声音资源</li><li>图片资源</li><li>纯文本文件</li><li>视频资源</li></ol><p>所以，所有的资源文件，应当单独创立 <code>Res</code> 文件夹，放入其中，并在 <code>.podspec</code> 中表明资源文件路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.resources  = [&quot;Source/**/*.xib&quot;, &quot;Source/Res/*.xcassets&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>注意图片资源，如果想保留 @2x、@3x，是可以按照 xcassets 的格式直接 copy 过来的。</p></blockquote><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-Modularization-08.png" alt=""></p><h1 id="5-结尾"><a href="#5-结尾" class="headerlink" title="5 结尾"></a>5 结尾</h1><p>以上是我在混编项目中进行 模块化/ 组件化的经验总结，写成了指导的模式，希望这篇文章能对走同样路的人有所帮助，希望你们会有所收获，么么哒。</p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">LottyLotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-开篇&quot;&gt;&lt;a href=&quot;#1-开篇&quot; class=&quot;headerlink&quot; title=&quot;1. 开篇&quot;&gt;&lt;/a&gt;1. 开篇&lt;/h1&gt;&lt;p&gt;本文的初衷，是为了给正在做混编或者模块化的同学们一个建议和参考。&lt;/p&gt;
&lt;p&gt;因为来饿厂以后做的项目是全公司唯一一个 Swift/OC 混编的 iOS 项目，所以一路上踩坑无数，现在把一些踩坑的过程和经验总结起来，供大家参考。&lt;/p&gt;
&lt;p&gt;相信在浏览本文后，一定会有所收获。&lt;/p&gt;
&lt;p&gt;我来的时候项目已经开始 Swift 改造了，慢慢的把项目 Swift 化，新代码都是 Swift 的。&lt;/p&gt;
&lt;p&gt;先公布七个月成果，下图是我们最终的项目结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS-Modularization-03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于我们混编的情况，在五个月前大家就展开了讨论。&lt;/p&gt;
&lt;p&gt;给我们的选择有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;慢慢将 OC 代码替换成 Swift&lt;/li&gt;
&lt;li&gt;尽快模块化，分离两种语言代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一开始我们是从 &lt;code&gt;选择1&lt;/code&gt; 开始做的，但是很快我们就发现，对于我们 74% 都是 OC 代码的项目来说，太痛了，太漫长了，而且期间迭代的过程中还在不断地迭代，不断的耦合。&lt;/p&gt;
&lt;p&gt;所以在经过一番利害分析后我们迅速投入到了 &lt;code&gt;选择2&lt;/code&gt; 中。一方面，模块化本身就是越来越臃肿的项目的最终归宿，一方面可以慢慢将两种语言剥离。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://lottyzhou.com/categories/iOS/"/>
    
      <category term="iOS模块化" scheme="http://lottyzhou.com/categories/iOS/iOS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
      <category term="iOS" scheme="http://lottyzhou.com/tags/iOS/"/>
    
      <category term="iOS模块化" scheme="http://lottyzhou.com/tags/iOS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【500 Lines or Less】-【翻译练习】-【chapter 14】-【简单对象模型】-【第三部分】</title>
    <link href="http://lottyzhou.com/2017/11/22/500-Lines-or-Less-14-3/"/>
    <id>http://lottyzhou.com/2017/11/22/500-Lines-or-Less-14-3/</id>
    <published>2017-11-22T07:27:19.000Z</published>
    <updated>2021-10-11T09:40:59.390Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="http://aosabook.org/en/500L/a-simple-object-model.html">A Simple Object Model</a><br>作者信息：<a href="https://twitter.com/cfbolz">Carl Friedrich Bolz</a></p></blockquote><hr><blockquote><p><a href="http://lottyzhou.com/2017/10/31/500-Lines-or-Less-14-2/">上一篇：《【500 Lines or Less】-【翻译练习】-【chapter 14】-【简单对象模型】-【第二部分】》</a><br>译者注：休息结束，我们继续</p></blockquote><h1 id="实例优化"><a href="#实例优化" class="headerlink" title="实例优化"></a>实例优化</h1><p>虽然对象模型的在之前的几节中发生了很多行为变化，但在最后一节中，我们将在没有影响任何行为的情况下进行优化。这种优化被称为 maps，并在自编程语言的虚拟机中率先被使用。如今，它仍然是最重要的对象模型优化之一：它被用于 PyPy 和所有现代 JavaScript 虚拟机，如V8（其中优化被称为 <em>hidden classes</em>）。</p><p>目前的观察：在到目前为止实现的对象模型中，所有实例都使用完整的字典来存储它们的属性。字典是使用哈希映射来实现的，这消耗大量的内存。此外，同一个类的实例将会拥有同样的属性，比如，有一个类 <code>Point</code>，它所有的实例都包含同样的属性 <code>x</code>、<code>y</code>。</p><p>maps 优化利用了这一点。它有效地将每个实例的字典分成两部分。一部分存放所有实例共享的 keys。而实例只存储对共享映射的引用和列表中的属性值（比字典更消耗了更少的内存）。</p><p>做简单测试用例如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_maps</span>():</span></span><br><span class="line">    <span class="comment"># white box test inspecting the implementation</span></span><br><span class="line">    Point = Class(name=<span class="string">&quot;Point&quot;</span>, base_class=OBJECT, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class="line">    p1 = Instance(Point)</span><br><span class="line">    p1.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    p1.write_attr(<span class="string">&quot;y&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> p1.storage == [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">assert</span> p1.<span class="built_in">map</span>.attrs == &#123;<span class="string">&quot;x&quot;</span>: <span class="number">0</span>, <span class="string">&quot;y&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">    p2 = Instance(Point)</span><br><span class="line">    p2.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">5</span>)</span><br><span class="line">    p2.write_attr(<span class="string">&quot;y&quot;</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">assert</span> p1.<span class="built_in">map</span> <span class="keyword">is</span> p2.<span class="built_in">map</span></span><br><span class="line">    <span class="keyword">assert</span> p2.storage == [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    p1.write_attr(<span class="string">&quot;x&quot;</span>, -<span class="number">1</span>)</span><br><span class="line">    p1.write_attr(<span class="string">&quot;y&quot;</span>, -<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> p1.<span class="built_in">map</span> <span class="keyword">is</span> p2.<span class="built_in">map</span></span><br><span class="line">    <span class="keyword">assert</span> p1.storage == [-<span class="number">1</span>, -<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    p3 = Instance(Point)</span><br><span class="line">    p3.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">100</span>)</span><br><span class="line">    p3.write_attr(<span class="string">&quot;z&quot;</span>, -<span class="number">343</span>)</span><br><span class="line">    <span class="keyword">assert</span> p3.<span class="built_in">map</span> <span class="keyword">is</span> <span class="keyword">not</span> p1.<span class="built_in">map</span></span><br><span class="line">    <span class="keyword">assert</span> p3.<span class="built_in">map</span>.attrs == &#123;<span class="string">&quot;x&quot;</span>: <span class="number">0</span>, <span class="string">&quot;z&quot;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>请注意，这个测试用例不同于我们之前写的测试用例。以前的所有测试都是通过已知的接口来测试类的功能。而此测试用例通过读取内部属性并将其与预定义值进行比较来检查 <code>Instance</code> 类的实现细节。</p><p><code>p1</code> 包含 <code>attrs</code> 的 <code>map</code> 存放了 <code>x</code> 和 <code>y</code> 两个属性，具体在 <code>p1</code> 中存放的值分别为 0 和 1。后创建的第二个实例 <code>p2</code>，同样在 map 中添加同样的属性。 换句话说，如果添加了不同的属性，其 map 是不通用的。</p><p><code>Map</code> 类类似于下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, attrs</span>):</span></span><br><span class="line">        self.attrs = attrs</span><br><span class="line">        self.next_maps = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_index</span>(<span class="params">self, fieldname</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.attrs.get(fieldname, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next_map</span>(<span class="params">self, fieldname</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> fieldname <span class="keyword">not</span> <span class="keyword">in</span> self.attrs</span><br><span class="line">        <span class="keyword">if</span> fieldname <span class="keyword">in</span> self.next_maps:</span><br><span class="line">            <span class="keyword">return</span> self.next_maps[fieldname]</span><br><span class="line">        attrs = self.attrs.copy()</span><br><span class="line">        attrs[fieldname] = <span class="built_in">len</span>(attrs)</span><br><span class="line">        result = self.next_maps[fieldname] = Map(attrs)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">EMPTY_MAP = Map(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>Maps 类拥有两个方法，<code>get_index</code> 和 <code>next_map</code>。前者用于查找对象存储中属性名称的索引。当一个新的属性被添加到一个对象时，后者被使用。 在这种情况下，对象需要使用 <code>next_map</code> 计算不同的 map。该方法使用 <code>next_maps</code> 字典来缓存已经创建的 map。这样，具有相同布局的对象也最终使用相同的 <code>Map</code> 对象。</p><p><img src="http://aosabook.org/en/500L/objmodel-images/maptransition.png" alt="图 14.2 Map 关系"></p><p>使用 maps 的 <code>Instance</code> 实现如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instance</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Instance of a user-defined class. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cls</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(cls, Class)</span><br><span class="line">        Base.__init__(self, cls, <span class="literal">None</span>)</span><br><span class="line">        self.<span class="built_in">map</span> = EMPTY_MAP</span><br><span class="line">        self.storage = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_read_dict</span>(<span class="params">self, fieldname</span>):</span></span><br><span class="line">        index = self.<span class="built_in">map</span>.get_index(fieldname)</span><br><span class="line">        <span class="keyword">if</span> index == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> MISSING</span><br><span class="line">        <span class="keyword">return</span> self.storage[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_write_dict</span>(<span class="params">self, fieldname, value</span>):</span></span><br><span class="line">        index = self.<span class="built_in">map</span>.get_index(fieldname)</span><br><span class="line">        <span class="keyword">if</span> index != -<span class="number">1</span>:</span><br><span class="line">            self.storage[index] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_map = self.<span class="built_in">map</span>.next_map(fieldname)</span><br><span class="line">            self.storage.append(value)</span><br><span class="line">            self.<span class="built_in">map</span> = new_map</span><br></pre></td></tr></table></figure><p>目前 <code>Instance</code> 类将给 <code>Base</code> 类传递 <code>None</code> 作为字段字典，因为 <code>Instance</code> 将会以另一种方式构建存储字典。因此它需要重载 <code>_read_dict</code> 和 <code>_write_dict</code> 。在实际操作中，我们将重构 <code>Base</code>类，使其不再负责存放属性字典。但目前，我们可以仅仅传递一个 <code>None</code> 作为参数。</p><p>在一个新的实例创建使用 <code>EMPTY_MAP</code>，其中没有存放任何对象。为了<code>_read_dict</code>，<code>Instance</code> 的 map 要提供属性名称的索引，然后返回相应的条目。</p><p>写入属性字典有两种情况。第一种是现有属性值的修改，那么就简单的在 map 的列表中修改对应的值就好。而如果对应属性不存在，那么需要进行 map 变换（如上面的图所示一样），将会调用 <code>next_map</code> 方法，然后将新的值存放入储存列表中。</p><p>这个优化到底实现了什么？一般而言，在具有很多相似结构实例的情况下优化了内存的使用。但这不是一个通用的优化手段：有些时候代码中充斥着结构不同的实例之时，这样优化可能会耗费更大的空间。</p><p>在优化动态语言时，这是一个常见问题。一般而言，不太可能找到一种十分通用的方法去优化代码，既其更快，又节省空间。在实践中，所选择的优化适用于通常使用的语言，而对于使用极其动态的功能的程序而言，可能会有相反的作用。</p><p>maps 优化另一个有意思的点是，虽然这里只优化内存使用，但是在使用 JIT 技术 的 VM 中，也能提高程序的性能。为了实现这一点，JIT 技术使用 maps 来查找属性在存储空间中的偏移量。然后完全拜托字典查找的方式。</p><h1 id="潜在扩展"><a href="#潜在扩展" class="headerlink" title="潜在扩展"></a>潜在扩展</h1><p>扩展我们的对象模型和使用不同语言的设计选择是很容易的。这里给出一些可能的方向：</p><ul><li><p>最简单的是添加更多的特殊方法方法，比如一些 <code>__init__</code>, <code>__getattribute__</code>, <code>__set__</code> 这样容易实现又有趣的方法。</p></li><li><p>扩展模型支持多重继承。为了实现这一点，每一个类都需要一个父类列表。然后 <code>Class.method_resolution_order</code> 需要进行修改，以便支持方法查找。可以使用深度优先搜索和删除重复项来计算简单的方法解析顺序。更为复杂的可以采用 C3 算法, 这种算法拥有更好的处理菱形继承结构的能力，并且避免了不可感知的继承模式。</p></li><li><p>一个更为疯狂的想法是切换到原型模式，这需要消除类和实例之间的差别。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>面向对象编程语言设计的核心是其对象模型的细节。编写一些简单的对象模型原型可以更好地理解现有语言的内部工作原理以及深入了解面向对象语言的设计理念。编写不同的对象模型验证不同对象的设计思路是一个很好的方式，你也必语言实现的更枯燥的部分，比如解析和执行代码。</p><p>编写对象模型在实践中也是非常有用的而不仅仅是用作实验。除了作为实验品以外，它们还可以在编写其他语言中所使用。例子有很多：用 C 语言编写的 GObject 模型，用于 GLib 和 其余 Gnome 库中，或者 JavaScript 各种类系统的实现。</p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">LottyLotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://aosabook.org/en/500L/a-simple-object-model.html&quot;&gt;A Simple Object Model&lt;/a&gt;&lt;br&gt;作者信息：&lt;a href=&quot;https://twitter.com/cfbolz&quot;&gt;Carl Friedrich Bolz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://lottyzhou.com/2017/10/31/500-Lines-or-Less-14-2/&quot;&gt;上一篇：《【500 Lines or Less】-【翻译练习】-【chapter 14】-【简单对象模型】-【第二部分】》&lt;/a&gt;&lt;br&gt;译者注：休息结束，我们继续&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;实例优化&quot;&gt;&lt;a href=&quot;#实例优化&quot; class=&quot;headerlink&quot; title=&quot;实例优化&quot;&gt;&lt;/a&gt;实例优化&lt;/h1&gt;&lt;p&gt;虽然对象模型的在之前的几节中发生了很多行为变化，但在最后一节中，我们将在没有影响任何行为的情况下进行优化。这种优化被称为 maps，并在自编程语言的虚拟机中率先被使用。如今，它仍然是最重要的对象模型优化之一：它被用于 PyPy 和所有现代 JavaScript 虚拟机，如V8（其中优化被称为 &lt;em&gt;hidden classes&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;目前的观察：在到目前为止实现的对象模型中，所有实例都使用完整的字典来存储它们的属性。字典是使用哈希映射来实现的，这消耗大量的内存。此外，同一个类的实例将会拥有同样的属性，比如，有一个类 &lt;code&gt;Point&lt;/code&gt;，它所有的实例都包含同样的属性 &lt;code&gt;x&lt;/code&gt;、&lt;code&gt;y&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;maps 优化利用了这一点。它有效地将每个实例的字典分成两部分。一部分存放所有实例共享的 keys。而实例只存储对共享映射的引用和列表中的属性值（比字典更消耗了更少的内存）。&lt;/p&gt;
&lt;p&gt;做简单测试用例如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_maps&lt;/span&gt;():&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# white box test inspecting the implementation&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Point = Class(name=&lt;span class=&quot;string&quot;&gt;&amp;quot;Point&amp;quot;&lt;/span&gt;, base_class=OBJECT, fields=&amp;#123;&amp;#125;, metaclass=TYPE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p1 = Instance(Point)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p1.write_attr(&lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p1.write_attr(&lt;span class=&quot;string&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; p1.storage == [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; p1.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;.attrs == &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p2 = Instance(Point)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p2.write_attr(&lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p2.write_attr(&lt;span class=&quot;string&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; p1.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; p2.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; p2.storage == [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p1.write_attr(&lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p1.write_attr(&lt;span class=&quot;string&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; p1.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; p2.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; p1.storage == [-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p3 = Instance(Point)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p3.write_attr(&lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p3.write_attr(&lt;span class=&quot;string&quot;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;343&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; p3.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; p1.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; p3.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;.attrs == &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://lottyzhou.com/categories/Python/"/>
    
    
      <category term="译文" scheme="http://lottyzhou.com/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Python" scheme="http://lottyzhou.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【500 Lines or Less】-【翻译练习】-【chapter 14】-【简单对象模型】-【第二部分】</title>
    <link href="http://lottyzhou.com/2017/10/31/500-Lines-or-Less-14-2/"/>
    <id>http://lottyzhou.com/2017/10/31/500-Lines-or-Less-14-2/</id>
    <published>2017-10-31T04:14:15.000Z</published>
    <updated>2021-10-11T09:40:59.390Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="http://aosabook.org/en/500L/a-simple-object-model.html">A Simple Object Model</a><br>作者信息：<a href="https://twitter.com/cfbolz">Carl Friedrich Bolz</a></p></blockquote><hr><blockquote><p><a href="http://lottyzhou.com/2017/10/08/500-Lines-or-Less-14-1/">上一篇：《【500 Lines or Less】-【翻译练习】-【chapter 14】-【简单对象模型】-【第一部分】》</a><br>译者注：休息结束，我们继续</p></blockquote><hr><h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><p>现在我们的模型还缺少方法调用的功能，本章我们将会实现一个简单的继承模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_callmethod_simple</span>():</span></span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> self.x + <span class="number">1</span></span><br><span class="line">    obj = A()</span><br><span class="line">    obj.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> obj.f() == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    obj = B()</span><br><span class="line">    obj.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> obj.f() == <span class="number">2</span> <span class="comment"># works on subclass too</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f_A</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.read_attr(<span class="string">&quot;x&quot;</span>) + <span class="number">1</span></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;<span class="string">&quot;f&quot;</span>: f_A&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(A)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.callmethod(<span class="string">&quot;f&quot;</span>) == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    B = Class(name=<span class="string">&quot;B&quot;</span>, base_class=A, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(B)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.callmethod(<span class="string">&quot;f&quot;</span>) == <span class="number">3</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>为了正确的实现对象方法的调用，我们开始关注类的方法解析顺序。在方法解析顺序中找到的类的字典中的的第一个方法将被调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>(<span class="params">Base</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_read_from_class</span>(<span class="params">self, methname</span>):</span></span><br><span class="line">        <span class="keyword">for</span> cls <span class="keyword">in</span> self.method_resolution_order():</span><br><span class="line">            <span class="keyword">if</span> methname <span class="keyword">in</span> cls._fields:</span><br><span class="line">                <span class="keyword">return</span> cls._fields[methname]</span><br><span class="line">        <span class="keyword">return</span> MISSING</span><br></pre></td></tr></table></figure><p>完善了 <code>Base</code> 类中的 <code>callmethod</code> 方法，测试用例就可以通过了。</p><p>为了确保方法参数正确传递，以及之前的代码能完成方法重载的功能，我们编写以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_callmethod_subclassing_and_arguments</span>():</span></span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">g</span>(<span class="params">self, arg</span>):</span></span><br><span class="line">            <span class="keyword">return</span> self.x + arg</span><br><span class="line">    obj = A()</span><br><span class="line">    obj.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> obj.g(<span class="number">4</span>) == <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">g</span>(<span class="params">self, arg</span>):</span></span><br><span class="line">            <span class="keyword">return</span> self.x + arg * <span class="number">2</span></span><br><span class="line">    obj = B()</span><br><span class="line">    obj.x = <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> obj.g(<span class="number">4</span>) == <span class="number">12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g_A</span>(<span class="params">self, arg</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.read_attr(<span class="string">&quot;x&quot;</span>) + arg</span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;<span class="string">&quot;g&quot;</span>: g_A&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(A)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.callmethod(<span class="string">&quot;g&quot;</span>, <span class="number">4</span>) == <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g_B</span>(<span class="params">self, arg</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.read_attr(<span class="string">&quot;x&quot;</span>) + arg * <span class="number">2</span></span><br><span class="line">    B = Class(name=<span class="string">&quot;B&quot;</span>, base_class=A, fields=&#123;<span class="string">&quot;g&quot;</span>: g_B&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(B)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.callmethod(<span class="string">&quot;g&quot;</span>, <span class="number">4</span>) == <span class="number">12</span></span><br></pre></td></tr></table></figure><h1 id="基于属性的模型"><a href="#基于属性的模型" class="headerlink" title="基于属性的模型"></a>基于属性的模型</h1><p>现在最简单版本的对象模型已经可以用了，我们可以开会考虑完善它。这一节我们将介绍 <code>基于方法的模型</code> 和 <code>基于属性的模型</code> 之间的异同点。其实这也是 Smalltalk 、 Ruby 、 JavaScript 、 Python 和 Lua 之间的核心差异。</p><p><code>基于方法的模型</code> 将方法调用作为程序执行的基本方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = obj.f(arg1, arg2)</span><br></pre></td></tr></table></figure><p><code>基于属性的模型</code> 将方法调用分为两步：查找属性和执行返回结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method = obj.f</span><br><span class="line">result = method(arg1, arg2)</span><br></pre></td></tr></table></figure><p>两者的差异可以在下面的测试用例中看出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_bound_method</span>():</span></span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">self, a</span>):</span></span><br><span class="line">            <span class="keyword">return</span> self.x + a + <span class="number">1</span></span><br><span class="line">    obj = A()</span><br><span class="line">    obj.x = <span class="number">2</span></span><br><span class="line">    m = obj.f</span><br><span class="line">    <span class="keyword">assert</span> m(<span class="number">4</span>) == <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    obj = B()</span><br><span class="line">    obj.x = <span class="number">1</span></span><br><span class="line">    m = obj.f</span><br><span class="line">    <span class="keyword">assert</span> m(<span class="number">10</span>) == <span class="number">12</span> <span class="comment"># works on subclass too</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f_A</span>(<span class="params">self, a</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.read_attr(<span class="string">&quot;x&quot;</span>) + a + <span class="number">1</span></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;<span class="string">&quot;f&quot;</span>: f_A&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(A)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    m = obj.read_attr(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> m(<span class="number">4</span>) == <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    B = Class(name=<span class="string">&quot;B&quot;</span>, base_class=A, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(B)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    m = obj.read_attr(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> m(<span class="number">10</span>) == <span class="number">12</span></span><br></pre></td></tr></table></figure><p>虽然设置与方法调用的相应测试相同，但调用方法的方式不同。首先，在对象中查找与 <code>read_attr</code> 方法传入参数一致的方法名。<code>read_attr</code> 返回值是一个对象，该对象封装了对象以及类中找到的对应方法。接下来我们就使用它调用该方法。</p><p>为了实现这个功能，我们需要修改 <code>Base.read_attr</code> 的实现。如果查找属性不在实例字典中，就应该去类的字典中查找。如果在类的字典中找到了这个属性，那么我们将会返回这个属性，这使用可以闭包来实现。除了更改 <code>Base.read_attr</code>，我们也可以修改 <code>Base.callmethod</code> 来确保我么你的代码能够通过测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_attr</span>(<span class="params">self, fieldname</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; read field &#x27;fieldname&#x27; out of the object &quot;&quot;&quot;</span></span><br><span class="line">        result = self._read_dict(fieldname)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> MISSING:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        result = self.cls._read_from_class(fieldname)</span><br><span class="line">        <span class="keyword">if</span> _is_bindable(result):</span><br><span class="line">            <span class="keyword">return</span> _make_boundmethod(result, self)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> MISSING:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(fieldname)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callmethod</span>(<span class="params">self, methname, *args</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; call method &#x27;methname&#x27; with arguments &#x27;args&#x27; on object &quot;&quot;&quot;</span></span><br><span class="line">        meth = self.read_attr(methname)</span><br><span class="line">        <span class="keyword">return</span> meth(*args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_is_bindable</span>(<span class="params">meth</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">callable</span>(meth)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_make_boundmethod</span>(<span class="params">meth, self</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bound</span>(<span class="params">*args</span>):</span></span><br><span class="line">        <span class="keyword">return</span> meth(self, *args)</span><br><span class="line">    <span class="keyword">return</span> bound</span><br></pre></td></tr></table></figure><p>其他的代码不需要做更改。</p><h1 id="元对象协议"><a href="#元对象协议" class="headerlink" title="元对象协议"></a>元对象协议</h1><p>除了常规的调用方法，很多动态语言还提供了特殊的方法。这些方法不是直接调用而是通过对象系统调用。在 Python 中这些特殊的方法往往用两个下划线作为开头和结尾，比如 <code>__init__</code>。可这些特殊的方法可以覆盖重载普通的操作，并为它们提供自定义功能。因此它们是可以告诉对象模型如何处理不同事物的 hook，关于 Python 中的特殊方法可以参考<a href="https://docs.python.org/2/reference/datamodel.html#special-method-names">这篇文档</a>。</p><p>元对象协议概念由 Smalltalk 引入，但 Common Lisp 这样的对象系统（如CLOS）也广泛的地使用元对象协议。</p><p>在本章我们将给我们的对象模型添加三种 meta-hook。它们将可以改变读写属性操作的功能。首先要添加的方法是 <code>__getattr__</code> 和 <code>__setattr__</code>（看起来和 Python 中类似方法的名字很类似）。</p><h2 id="自定义读写属性操作"><a href="#自定义读写属性操作" class="headerlink" title="自定义读写属性操作"></a>自定义读写属性操作</h2><p><code>__getattr__</code> 在通过常规的属性查找方法无法查找到时被调用（在类和对象方法字典中均未找到）。该方法需要的参数是『需要查找的属性名称』。早期的 <code>Smalltalk4</code> 中被称为 <code>doesNotUnderstand</code></p><p><code>__setattr__</code> 的情况有点不同。 由于设置属性总是会创建一个属性，所以在设置属性时总是调用<code>__setattr__</code>。为了确保 <code>__setattr__</code> 存在，我们需要在 <code>OBEJCT</code> 中实现 <code>__setattr__</code> 方法。保证我们可以向字典中写入属性。也可以让用户可以将自定义的 <code>__setattr__</code> 委托给 <code>OBJECT.__setattr__</code>。</p><p>针对这两个特殊方法的测试用例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_getattr</span>():</span></span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">            <span class="keyword">if</span> name == <span class="string">&quot;fahrenheit&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> self.celsius * <span class="number">9.</span> / <span class="number">5.</span> + <span class="number">32</span></span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">            <span class="keyword">if</span> name == <span class="string">&quot;fahrenheit&quot;</span>:</span><br><span class="line">                self.celsius = (value - <span class="number">32</span>) * <span class="number">5.</span> / <span class="number">9.</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># call the base implementation</span></span><br><span class="line">                <span class="built_in">object</span>.__setattr__(self, name, value)</span><br><span class="line">    obj = A()</span><br><span class="line">    obj.celsius = <span class="number">30</span></span><br><span class="line">    <span class="keyword">assert</span> obj.fahrenheit == <span class="number">86</span> <span class="comment"># test __getattr__</span></span><br><span class="line">    obj.celsius = <span class="number">40</span></span><br><span class="line">    <span class="keyword">assert</span> obj.fahrenheit == <span class="number">104</span></span><br><span class="line"></span><br><span class="line">    obj.fahrenheit = <span class="number">86</span> <span class="comment"># test __setattr__</span></span><br><span class="line">    <span class="keyword">assert</span> obj.celsius == <span class="number">30</span></span><br><span class="line">    <span class="keyword">assert</span> obj.fahrenheit == <span class="number">86</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;fahrenheit&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.read_attr(<span class="string">&quot;celsius&quot;</span>) * <span class="number">9.</span> / <span class="number">5.</span> + <span class="number">32</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;fahrenheit&quot;</span>:</span><br><span class="line">            self.write_attr(<span class="string">&quot;celsius&quot;</span>, (value - <span class="number">32</span>) * <span class="number">5.</span> / <span class="number">9.</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># call the base implementation</span></span><br><span class="line">            OBJECT.read_attr(<span class="string">&quot;__setattr__&quot;</span>)(self, name, value)</span><br><span class="line"></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT,</span><br><span class="line">              fields=&#123;<span class="string">&quot;__getattr__&quot;</span>: __getattr__, <span class="string">&quot;__setattr__&quot;</span>: __setattr__&#125;,</span><br><span class="line">              metaclass=TYPE)</span><br><span class="line">    obj = Instance(A)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;celsius&quot;</span>, <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;fahrenheit&quot;</span>) == <span class="number">86</span> <span class="comment"># test __getattr__</span></span><br><span class="line">    obj.write_attr(<span class="string">&quot;celsius&quot;</span>, <span class="number">40</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;fahrenheit&quot;</span>) == <span class="number">104</span></span><br><span class="line">    obj.write_attr(<span class="string">&quot;fahrenheit&quot;</span>, <span class="number">86</span>) <span class="comment"># test __setattr__</span></span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;celsius&quot;</span>) == <span class="number">30</span></span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;fahrenheit&quot;</span>) == <span class="number">86</span></span><br></pre></td></tr></table></figure><p>为了通过这个测试，需要完善 <code>Base.read_attr</code> 和 <code>Base.write_attr</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_attr</span>(<span class="params">self, fieldname</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; read field &#x27;fieldname&#x27; out of the object &quot;&quot;&quot;</span></span><br><span class="line">        result = self._read_dict(fieldname)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> MISSING:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        result = self.cls._read_from_class(fieldname)</span><br><span class="line">        <span class="keyword">if</span> _is_bindable(result):</span><br><span class="line">            <span class="keyword">return</span> _make_boundmethod(result, self)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> MISSING:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        meth = self.cls._read_from_class(<span class="string">&quot;__getattr__&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> meth <span class="keyword">is</span> <span class="keyword">not</span> MISSING:</span><br><span class="line">            <span class="keyword">return</span> meth(self, fieldname)</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(fieldname)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_attr</span>(<span class="params">self, fieldname, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; write field &#x27;fieldname&#x27; into the object &quot;&quot;&quot;</span></span><br><span class="line">        meth = self.cls._read_from_class(<span class="string">&quot;__setattr__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> meth(self, fieldname, value)</span><br></pre></td></tr></table></figure><p>通过属性名作为参数，如果字段不存在抛出错误。注意 <code>__getattr__</code> 只能在类中调用（Python 中的特殊方法也是）以避免递归调用 <code>self.read_attr(&quot;__getattr__&quot;)</code>。</p><p>属性的写操作也交给 <code>__setattr__</code> 方法。为了完成这个功能，<code>OBEJCT</code> 需要实现 <code>__setattr__</code> 的基本功能，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OBJECT__setattr__</span>(<span class="params">self, fieldname, value</span>):</span></span><br><span class="line">    self._write_dict(fieldname, value)</span><br><span class="line">OBJECT = Class(<span class="string">&quot;object&quot;</span>, <span class="literal">None</span>, &#123;<span class="string">&quot;__setattr__&quot;</span>: OBJECT__setattr__&#125;, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><code>OBJECT__setattr__</code> 的行为就像以前的 <code>write_attr</code>。 通过这些修改，测试用例可以通过。</p><h2 id="描述符协议"><a href="#描述符协议" class="headerlink" title="描述符协议"></a>描述符协议</h2><p>上述测试用例中反复转换不同温标，十分的烦人。因为属性名要在 <code>__getattr__</code> 和 <code>__setattr__</code> 中显式的去校验。为了解决这个问题，在 Python 中引入了描述符协议的概念。</p><p>我们将从 <code>__getattr__</code> 和 <code>__setattr__</code> 方法中获取具体的属性，而描述符协议是在属性调用过程结束返回结果时触发一个特殊的方法。描述符协议可以被看作是绑定方法和类的操作。除了绑定方法外，Python中描述符协议最重要的用例是 <code>staticmethod</code>、<code>classmethod</code> 和 <code>property</code>。</p><p>在本节中，我们将介绍如何使用描述符协议绑定对象。我们可以通过使用 <strong>get</strong> 方法来达成这一目标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_get</span>():</span></span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FahrenheitGetter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, inst, cls</span>):</span></span><br><span class="line">            <span class="keyword">return</span> inst.celsius * <span class="number">9.</span> / <span class="number">5.</span> + <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        fahrenheit = FahrenheitGetter()</span><br><span class="line">    obj = A()</span><br><span class="line">    obj.celsius = <span class="number">30</span></span><br><span class="line">    <span class="keyword">assert</span> obj.fahrenheit == <span class="number">86</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FahrenheitGetter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, inst, cls</span>):</span></span><br><span class="line">            <span class="keyword">return</span> inst.read_attr(<span class="string">&quot;celsius&quot;</span>) * <span class="number">9.</span> / <span class="number">5.</span> + <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT,</span><br><span class="line">              fields=&#123;<span class="string">&quot;fahrenheit&quot;</span>: FahrenheitGetter()&#125;,</span><br><span class="line">              metaclass=TYPE)</span><br><span class="line">    obj = Instance(A)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;celsius&quot;</span>, <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;fahrenheit&quot;</span>) == <span class="number">86</span></span><br></pre></td></tr></table></figure><p>现在测试用例可以通过了。之前关于方法绑定的测试用例也依然通过，在 Python 中 <code>__get__</code> 方法执行完了将会返回一个已绑定方法对象。</p><p>在实践中，描述符协议要更加复杂。它还支持 <code>__set__</code> 来设置属性。你现在所看到这里实现的版本是经过一些简化的。注意，前面 <code>_make_boundmethod</code> 方法调用 <code>__get__</code> 是实现级的操作，而不是使用 <code>meth.read_attr(&#39;__get__&#39;)</code> 。意思是，我们的对象模型是在借用 Python 的函数和方法，而不是展示 Python 的对象模型。一个更完整的对象模型将不得不解决这个问题。</p><hr><h3 id="译者著：文章有点长，怕大家看着感觉太干，分成了的三篇文章，大家休息一下，继续吧。"><a href="#译者著：文章有点长，怕大家看着感觉太干，分成了的三篇文章，大家休息一下，继续吧。" class="headerlink" title="译者著：文章有点长，怕大家看着感觉太干，分成了的三篇文章，大家休息一下，继续吧。"></a>译者著：文章有点长，怕大家看着感觉太干，分成了的三篇文章，大家休息一下，继续吧。</h3><h3 id="下一篇：《【500-Lines-or-Less】-【翻译练习】-【chapter-14】-【简单对象模型】-【第三部分】》"><a href="#下一篇：《【500-Lines-or-Less】-【翻译练习】-【chapter-14】-【简单对象模型】-【第三部分】》" class="headerlink" title="下一篇：《【500 Lines or Less】-【翻译练习】-【chapter 14】-【简单对象模型】-【第三部分】》"></a><a href="http://lottyzhou.com/2017/11/22/500-Lines-or-Less-14-3/">下一篇：《【500 Lines or Less】-【翻译练习】-【chapter 14】-【简单对象模型】-【第三部分】》</a></h3><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://aosabook.org/en/500L/a-simple-object-model.html&quot;&gt;A Simple Object Model&lt;/a&gt;&lt;br&gt;作者信息：&lt;a href=&quot;https://twitter.com/cfbolz&quot;&gt;Carl Friedrich Bolz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://lottyzhou.com/2017/10/08/500-Lines-or-Less-14-1/&quot;&gt;上一篇：《【500 Lines or Less】-【翻译练习】-【chapter 14】-【简单对象模型】-【第一部分】》&lt;/a&gt;&lt;br&gt;译者注：休息结束，我们继续&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;方法调用&quot;&gt;&lt;a href=&quot;#方法调用&quot; class=&quot;headerlink&quot; title=&quot;方法调用&quot;&gt;&lt;/a&gt;方法调用&lt;/h1&gt;&lt;p&gt;现在我们的模型还缺少方法调用的功能，本章我们将会实现一个简单的继承模型。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_callmethod_simple&lt;/span&gt;():&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# Python code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;object&lt;/span&gt;&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.x + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj = A()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj.x = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; obj.f() == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;B&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;A&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj = B()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj.x = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; obj.f() == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# works on subclass too&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# Object model code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f_A&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.read_attr(&lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;) + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A = Class(name=&lt;span class=&quot;string&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;, base_class=OBJECT, fields=&amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;quot;f&amp;quot;&lt;/span&gt;: f_A&amp;#125;, metaclass=TYPE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj = Instance(A)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj.write_attr(&lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; obj.callmethod(&lt;span class=&quot;string&quot;&gt;&amp;quot;f&amp;quot;&lt;/span&gt;) == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    B = Class(name=&lt;span class=&quot;string&quot;&gt;&amp;quot;B&amp;quot;&lt;/span&gt;, base_class=A, fields=&amp;#123;&amp;#125;, metaclass=TYPE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj = Instance(B)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj.write_attr(&lt;span class=&quot;string&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;assert&lt;/span&gt; obj.callmethod(&lt;span class=&quot;string&quot;&gt;&amp;quot;f&amp;quot;&lt;/span&gt;) == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://lottyzhou.com/categories/Python/"/>
    
    
      <category term="译文" scheme="http://lottyzhou.com/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Python" scheme="http://lottyzhou.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【500 Lines or Less】-【翻译练习】-【chapter 14】-【简单对象模型】-【第一部分】</title>
    <link href="http://lottyzhou.com/2017/10/08/500-Lines-or-Less-14-1/"/>
    <id>http://lottyzhou.com/2017/10/08/500-Lines-or-Less-14-1/</id>
    <published>2017-10-08T07:31:46.000Z</published>
    <updated>2021-10-11T09:40:59.390Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="http://aosabook.org/en/500L/a-simple-object-model.html">A Simple Object Model</a><br>作者信息：<a href="https://twitter.com/cfbolz">Carl Friedrich Bolz</a></p></blockquote><p><a href="https://twitter.com/cfbolz">Carl Friedrich Bolz</a>是伦敦国王大学的研究员，对动态语言的实现及优化兴趣浓厚。他是 PyPy/RPython 的核心贡献者之一，并为 Prolog, Racket, Smalltalk, PHP 和 Ruby 等语言贡献代码。</p><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>面向对象开发是现今最主流的编程范式之一，面向对象的思想和变成范式也被大量的编程语言所支持。虽然不痛语言提供的面向对象编程机制表面上非常相似，但是细节上却大相径庭。大多数语言的共同点是拥有对象和继承机制。而『类』，并不是每一种语言都很好的支持它的种种特性。比如，比如对于 <code>Self</code> 或者 <code>JavaScript</code> 这样的原型程序设计的语言来说没有类的概念，而是对象间直接进行了继承。</p><p>了解不同语言的对象模型的不同之处是一件非常有趣的事。这能帮助你发现不同语言的异同之处。这将在我们学习新语言时，运用以往的编程语言经验，快速的学习。</p><p>本章将探索学实现一套简单的对象模型。我们将从一个简单的实例和它的类开始，并让它拥有一些方法可以用于访问。这是被 Simula 67 、Smalltalk 等早期 OO（面向对象） 语言所采用的经典面向对象范例。在本章中，这个模型将会被一步步进行扩展，前两个小节我们将展示不同语言的设计思路，最后一小节将讲解如何提高对象模型的性能。最终我们的模型并不是任何一门语言所采用的模型，不过，将认为是一个简化的 Python 对象模型。</p><p>本章中使用的代码范例都使用 Python 编写。代码可以运行在 Python 2.7 和 3.4。为了更好的理解对象模型的设计，本章也提供了相应的单元测试。测试代码可以通过 py.test 或者 nose 来运行。</p><p>用 Python 作为实现语言并不是最好的，通常一个 VM（或者语言解释器）是由底层语言比如 C 和 C++ 实现的，并在实现过程中对更偏向于扣每一个实现细节从而提高代码效率。而更简单的语言更让我们更容易关注实际的行为表现，而不是扣实现细节。</p><span id="more"></span><h1 id="Method-Based-Model"><a href="#Method-Based-Model" class="headerlink" title="Method-Based Model"></a>Method-Based Model</h1><p>我们将从实现 Smalltalk 的极简版本开始讲解我么你的对象模型。Smalltalk 是由 Xerox PARC 的Alan Kay’s 小组在上世纪 70 年代开发的面向对象语言。它推广了面向对象语言，在今时的众多编程语言中也能看到它的很多特性。Smalltalk 的设计宗旨之一就是『万物皆对象』。如今，Smalltalk 的最接近的思想继承者是 Ruby，Ruby 的语法更像 C 语言，但却保留了大部分 Smalltalk 的对象模型。</p><p>本节中的对象模型将具有它们的类和实例，可以读写对象的属性，可以调用对象的方法，<br>同时允许继承。在开始之前要说的是，这些类的对象都是有属性和方法的普通类。</p><p>FYI: 本章节中我使用的『实例』代表『对象（而不是类）』。</p><p>开始的一个好方式是编写一个测试用例来指定『将要实现的行为』。本章介绍的所有测试用例都由两部分组成。第一部分由 Python 常用工具类的定义、使用以及更高级的一些特性。第二部门将会使用我们自己编写的对象模型来代替 Python 的常用工具类。</p><p>测试用例中，我们需要手动维护 Python 的常用工具类和我们自己编写的对象莫行之间的映射关系。比如，Python 中会使用 <code>obj.attribute</code>，而我们自己编写的对象模型的使用是 <code>obj.read_attr(&quot;attribute&quot;)</code>。这种映射在真正的语言实现中可以由语言的解释器或编译器来完成。</p><p>本章中对整体的代码的进行进一步简化，我们没有明显的区分『实现对象模型』和『使用对象模型』。在一个真正的语言系统中，这两者通常会以不同的编程语言来实现。</p><p>我们从读取和写入对象属性的简单测试开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_read_write_field</span>():</span></span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    obj = A()</span><br><span class="line">    obj.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> obj.a == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    obj.b = <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> obj.a == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> obj.b == <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    obj.a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> obj.a == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> obj.b == <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(A)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;a&quot;</span>) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    obj.write_attr(<span class="string">&quot;b&quot;</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;a&quot;</span>) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;b&quot;</span>) == <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    obj.write_attr(<span class="string">&quot;a&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;a&quot;</span>) == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;b&quot;</span>) == <span class="number">5</span></span><br></pre></td></tr></table></figure><p>这个测试用例使用了三个我们必须实现的东西。<code>Class</code> 类和 <code>Instance</code> 类分别代表了我们的对象模型的类与实例。其中有两个特殊的类的实例：<code>OBJECT</code> 和 <code>TYPE</code>，<code>OBJECT</code> 代表 Python 中的的根类，<code>TYPE</code> 代表 Python 中类的 type。</p><p>为了给 <code>Class</code> 以及 <code>Instance</code> 类的实例提供通用操作支持，他们通过继承一个基类 <code>Base</code> 来实现一个共享接口，这个基类暴露了很多方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; The base class that all of the object model classes inherit from. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cls, fields</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Every object has a class. &quot;&quot;&quot;</span></span><br><span class="line">        self.cls = cls</span><br><span class="line">        self._fields = fields</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_attr</span>(<span class="params">self, fieldname</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; read field &#x27;fieldname&#x27; out of the object &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._read_dict(fieldname)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_attr</span>(<span class="params">self, fieldname, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; write field &#x27;fieldname&#x27; into the object &quot;&quot;&quot;</span></span><br><span class="line">        self._write_dict(fieldname, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isinstance</span>(<span class="params">self, cls</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; return True if the object is an instance of class cls &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.cls.<span class="built_in">issubclass</span>(cls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callmethod</span>(<span class="params">self, methname, *args</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; call method &#x27;methname&#x27; with arguments &#x27;args&#x27; on object &quot;&quot;&quot;</span></span><br><span class="line">        meth = self.cls._read_from_class(methname)</span><br><span class="line">        <span class="keyword">return</span> meth(self, *args)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_read_dict</span>(<span class="params">self, fieldname</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; read an field &#x27;fieldname&#x27; out of the object&#x27;s dict &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._fields.get(fieldname, MISSING)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_write_dict</span>(<span class="params">self, fieldname, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; write a field &#x27;fieldname&#x27; into the object&#x27;s dict &quot;&quot;&quot;</span></span><br><span class="line">        self._fields[fieldname] = value</span><br><span class="line"></span><br><span class="line">MISSING = <span class="built_in">object</span>()</span><br></pre></td></tr></table></figure><p><code>Base</code> 类实现了对象的类的存储，用一个字典保存对象的属性和其值。现在我们需要去实现 <code>Class</code> 和 <code>Instance</code> 类。在 <code>Instance</code> 的构造器中将会完成类的实例化以及 <code>fields</code> 和 <code>dict</code> 初始化】。也就是说 <code>Instance</code> 仅仅是 没有任何额外功能的 <code>Base</code> 的简单子类。</p><p><code>Class</code> 的构造器将会获取类名、基类、类的字典以及元类进行构造。对于类来说，属性会在蕾叔实话的时候由用户传入给构造器。构造器也会从基类中获取属性的默认值（这里将会在下一节讲解）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instance</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Instance of a user-defined class. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cls</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(cls, Class)</span><br><span class="line">        Base.__init__(self, cls, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; A User-defined class. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, base_class, fields, metaclass</span>):</span></span><br><span class="line">        Base.__init__(self, metaclass, fields)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.base_class = base_class</span><br></pre></td></tr></table></figure><p>由于类也是一种对象，它们（间接）从 <code>Base</code> 继承。 因此，类是一个特殊类的实例：元类。</p><p>现在我们基本通过了第一个测试用例。还剩下没有详解的是 <code>Class</code> 的两个实例 <code>TYPE</code> 和 <code>OBJECT</code>。这里我们不使用 Smalltalk 的模型，因为它过于复杂，我们将使用 Python 借鉴的 ObjVlisp（一种元编程语言，可参考《Metaclasses are first class: The ObjVlisp Model》）。</p><p>ObjVlisp 模型中，<code>OBJECT</code> 和 <code>TYPE</code> 是交织在一起的。<code>OBJECT</code> 是所有类的基类，这意味着 <code>OBJECT</code> 类没有基类。<code>TYPE</code> 是 <code>OBJECT</code> 的子类，一般来说，每一个类都是 <code>TYPE</code> 的实例。特殊情况下，<code>TYPE</code> 和 <code>OBJECT</code> 都是 <code>TYPE</code> 的实例。然而，程序员可以通过继承 <code>TYPE</code> 来实现一个新的元类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set up the base hierarchy as in Python (the ObjVLisp model)</span></span><br><span class="line"><span class="comment"># the ultimate base class is OBJECT</span></span><br><span class="line">OBJECT = Class(name=<span class="string">&quot;object&quot;</span>, base_class=<span class="literal">None</span>, fields=&#123;&#125;, metaclass=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># TYPE is a subclass of OBJECT</span></span><br><span class="line">TYPE = Class(name=<span class="string">&quot;type&quot;</span>, base_class=OBJECT, fields=&#123;&#125;, metaclass=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># TYPE is an instance of itself</span></span><br><span class="line">TYPE.cls = TYPE</span><br><span class="line"><span class="comment"># OBJECT is an instance of TYPE</span></span><br><span class="line">OBJECT.cls = TYPE</span><br></pre></td></tr></table></figure><p>为了实现一个新的元类，可以继承 <code>TYPE</code>。然而，在本章中我们不这样去做，我们只见得使用 <code>TYPE</code> 作为我们每个类的元类。</p><p><img src="http://aosabook.org/en/500L/objmodel-images/inheritance.png" alt="图 14.1 - 继承"></p><p>现在第一个测试用例就通过了。第二个测试用例校验了对象属性读写是否正常。这十分简单，很快就能通过用例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_read_write_field_class</span>():</span></span><br><span class="line">    <span class="comment"># classes are objects too</span></span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    A.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> A.a == <span class="number">1</span></span><br><span class="line">    A.a = <span class="number">6</span></span><br><span class="line">    <span class="keyword">assert</span> A.a == <span class="number">6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;, metaclass=TYPE)</span><br><span class="line">    <span class="keyword">assert</span> A.read_attr(<span class="string">&quot;a&quot;</span>) == <span class="number">1</span></span><br><span class="line">    A.write_attr(<span class="string">&quot;a&quot;</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">assert</span> A.read_attr(<span class="string">&quot;a&quot;</span>) == <span class="number">5</span></span><br></pre></td></tr></table></figure><h1 id="isinstance-（对象是否是该类实例）校验"><a href="#isinstance-（对象是否是该类实例）校验" class="headerlink" title="isinstance （对象是否是该类实例）校验"></a><code>isinstance</code> （对象是否是该类实例）校验</h1><p>到目前为止，我们还没有利用『对象对应类』的特性。下一个测试用例将机械实现 <code>isinstance</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_isinstance</span>():</span></span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    b = B()</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(b, B)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(b, A)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(b, <span class="built_in">object</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(b, <span class="built_in">type</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class="line">    B = Class(name=<span class="string">&quot;B&quot;</span>, base_class=A, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class="line">    b = Instance(B)</span><br><span class="line">    <span class="keyword">assert</span> b.<span class="built_in">isinstance</span>(B)</span><br><span class="line">    <span class="keyword">assert</span> b.<span class="built_in">isinstance</span>(A)</span><br><span class="line">    <span class="keyword">assert</span> b.<span class="built_in">isinstance</span>(OBJECT)</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> b.<span class="built_in">isinstance</span>(TYPE)</span><br></pre></td></tr></table></figure><p>要检查一个 <code>obj</code> 对象是否是某个类 <code>cls</code> 的一个实例，可以通过检查 <code>cls</code> 是 <code>obj</code> 类的超类还是类本身。要检查一个 <code>类X</code> 是否是另一个类的超类，可以通过检查这个类的是否在 <code>类X</code> 的继承链上。如果还有其他的类在这个继承链上，那么这些类也是 <code>类X</code> 的超类。包括 <code>类x</code> 本身在内的一个继承链称为该类的『方法解析顺序』。 通过递归很容易将其计算出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>(<span class="params">Base</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_resolution_order</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; compute the method resolution order of the class &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.base_class <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> [self]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [self] + self.base_class.method_resolution_order()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">issubclass</span>(<span class="params">self, cls</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; is self a subclass of cls? &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> cls <span class="keyword">in</span> self.method_resolution_order()</span><br></pre></td></tr></table></figure><p>加上这段代码后，测试用例就可以顺利通过了。</p><hr><h3 id="译者著：文章有点长，怕大家看着感觉太干，分成了的三篇文章，大家休息一下，继续吧。"><a href="#译者著：文章有点长，怕大家看着感觉太干，分成了的三篇文章，大家休息一下，继续吧。" class="headerlink" title="译者著：文章有点长，怕大家看着感觉太干，分成了的三篇文章，大家休息一下，继续吧。"></a>译者著：文章有点长，怕大家看着感觉太干，分成了的三篇文章，大家休息一下，继续吧。</h3><h3 id="下一篇：《【500-Lines-or-Less】-【翻译练习】-【chapter-14】-【简单对象模型】-【第二部分】》"><a href="#下一篇：《【500-Lines-or-Less】-【翻译练习】-【chapter-14】-【简单对象模型】-【第二部分】》" class="headerlink" title="下一篇：《【500 Lines or Less】-【翻译练习】-【chapter 14】-【简单对象模型】-【第二部分】》"></a><a href="http://lottyzhou.com/2017/10/31/500-Lines-or-Less-14-2/">下一篇：《【500 Lines or Less】-【翻译练习】-【chapter 14】-【简单对象模型】-【第二部分】》</a></h3><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://aosabook.org/en/500L/a-simple-object-model.html&quot;&gt;A Simple Object Model&lt;/a&gt;&lt;br&gt;作者信息：&lt;a href=&quot;https://twitter.com/cfbolz&quot;&gt;Carl Friedrich Bolz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/cfbolz&quot;&gt;Carl Friedrich Bolz&lt;/a&gt;是伦敦国王大学的研究员，对动态语言的实现及优化兴趣浓厚。他是 PyPy/RPython 的核心贡献者之一，并为 Prolog, Racket, Smalltalk, PHP 和 Ruby 等语言贡献代码。&lt;/p&gt;
&lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;面向对象开发是现今最主流的编程范式之一，面向对象的思想和变成范式也被大量的编程语言所支持。虽然不痛语言提供的面向对象编程机制表面上非常相似，但是细节上却大相径庭。大多数语言的共同点是拥有对象和继承机制。而『类』，并不是每一种语言都很好的支持它的种种特性。比如，比如对于 &lt;code&gt;Self&lt;/code&gt; 或者 &lt;code&gt;JavaScript&lt;/code&gt; 这样的原型程序设计的语言来说没有类的概念，而是对象间直接进行了继承。&lt;/p&gt;
&lt;p&gt;了解不同语言的对象模型的不同之处是一件非常有趣的事。这能帮助你发现不同语言的异同之处。这将在我们学习新语言时，运用以往的编程语言经验，快速的学习。&lt;/p&gt;
&lt;p&gt;本章将探索学实现一套简单的对象模型。我们将从一个简单的实例和它的类开始，并让它拥有一些方法可以用于访问。这是被 Simula 67 、Smalltalk 等早期 OO（面向对象） 语言所采用的经典面向对象范例。在本章中，这个模型将会被一步步进行扩展，前两个小节我们将展示不同语言的设计思路，最后一小节将讲解如何提高对象模型的性能。最终我们的模型并不是任何一门语言所采用的模型，不过，将认为是一个简化的 Python 对象模型。&lt;/p&gt;
&lt;p&gt;本章中使用的代码范例都使用 Python 编写。代码可以运行在 Python 2.7 和 3.4。为了更好的理解对象模型的设计，本章也提供了相应的单元测试。测试代码可以通过 py.test 或者 nose 来运行。&lt;/p&gt;
&lt;p&gt;用 Python 作为实现语言并不是最好的，通常一个 VM（或者语言解释器）是由底层语言比如 C 和 C++ 实现的，并在实现过程中对更偏向于扣每一个实现细节从而提高代码效率。而更简单的语言更让我们更容易关注实际的行为表现，而不是扣实现细节。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://lottyzhou.com/categories/Python/"/>
    
    
      <category term="译文" scheme="http://lottyzhou.com/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Python" scheme="http://lottyzhou.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>iOS——Swift 中的 strongSelf，你以为不需要了？</title>
    <link href="http://lottyzhou.com/2017/08/14/iOS%E2%80%94%E2%80%94swift-strongself/"/>
    <id>http://lottyzhou.com/2017/08/14/iOS——swift-strongself/</id>
    <published>2017-08-14T07:19:35.000Z</published>
    <updated>2021-10-11T09:40:59.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h1><p>Objective-C 中，有一段重复写到你不得不加入 <code>snippets</code> 的代码块。就是下面这段</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span>.aButton touchUpInside:^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf) &#123;</span><br><span class="line">        strongSelf.title = <span class="string">@&quot;按钮被点击&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>一般，由于重复写的次数过多，就加到了 <code>snippets</code> 快捷代码块，以下是我的：</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_swift-strongself-01.png" alt=""></p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_swift-strongself-02.png" alt=""></p><p>当然，如果用了 RAC，你可以写成如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">[<span class="keyword">self</span>.aButton touchUpInside:^&#123;</span><br><span class="line"> @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (strongSelf) &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="string">@&quot;按钮被点击&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>当然，如果你阅读过 RAC 对 <code>@weakify</code> 和 <code>@strongify</code> 语法糖的实现，你会知道，实现方式不过是用宏简写了 <code>__weak __typeof__(self) weakSelf = self;</code> 和 <code>__strong __typeof(weakSelf)strongSelf = weakSelf;</code></p><p>重点是为什么要写这两句代码？</p><p>weakSelf 是为了避免循环引用（如果你对循环引用和内存管理不了解的话，请调跳到下方 <a href="#Other">Other 部分</a>）。</p><p>strongSelf 是为了防止 self 被提前释放。具体可以参考 <a href="http://www.jianshu.com/p/701da54bd78c">深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用</a>。</p><h1 id="你以为-Swift-中不需要-strongSelf-了吗？"><a href="#你以为-Swift-中不需要-strongSelf-了吗？" class="headerlink" title="你以为 Swift 中不需要 strongSelf 了吗？"></a>你以为 Swift 中不需要 strongSelf 了吗？</h1><p>Swift 中有了 <code>[weak self]</code> 语法糖后，再也不用谢一长串 <code>__weak __typeof__(self) weakSelf = self;</code>，相应的，在闭包中会调用到已经被弱引用的 <code>self</code>，但使用 <code>self</code> 时需要加上 <code>?</code>。</p><p>这里就已经可以初见端倪了，和 Objective-C 一样，weak 引用的 <code>self</code> 是可以被释放的，也就是说 <code>self</code> 可以为 <code>nil</code>。在 Objective-C 中，没有可选性概念，所以对此并不感知，在 Swift 中问题就很容易暴露出来。如果 <code>self</code> 被提前释放了会如何？</p><p>我们做如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> anObject: <span class="type">SomeClass</span>? <span class="operator">=</span> <span class="type">SomeClass</span>()  <span class="comment">// Optional, so we can set it to nil</span></span><br><span class="line">        anObject<span class="operator">?</span>.doClosure()</span><br><span class="line"></span><br><span class="line">        <span class="type">DispatchQueue</span>.global(qos: .userInitiated).async &#123;</span><br><span class="line">            usleep(<span class="number">100</span>)</span><br><span class="line">            anObject <span class="operator">=</span> <span class="literal">nil</span>  <span class="comment">// This will dealloc c</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Destroying C&quot;</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">log</span>(<span class="keyword">_</span> <span class="params">msg</span>: <span class="type">String</span>)</span> &#123; <span class="built_in">print</span>(msg) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doClosure</span>()</span> &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.global(qos: .userInitiated).async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span><span class="operator">?</span>.log(<span class="string">&quot;before sleep&quot;</span>)</span><br><span class="line">            usleep(<span class="number">500</span>)</span><br><span class="line">            <span class="keyword">self</span><span class="operator">?</span>.log(<span class="string">&quot;after sleep&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码运行结果如下：</p><p>这就是问题所在了。代码中可以清晰的看到，在闭包中代码运行的过程中，<code>anObject</code> 被设置成了 <code>nil</code>，此时没有任何对象强引用它，自然被释放了，释放后闭包中代码继续运行，<code>self</code> 此时为 <code>nil</code>，但由于 Swfit 的安全性，<code>self?.log(&quot;after sleep&quot;)</code> 没有解包成功便不会执行，所以不会造成闪退。但问题依然有。</p><p>由于后续代码没有执行，造成的其他逻辑错误是可想而知的，如果闭包中正在执行存磁盘操作，<code>self</code> 被释放，后续还有更新 UI 显示等等操作，便不会执行，造成各种各样的问题。</p><p>所以，你以为 Swift 中就不需要 <code>strongSelf</code> 了？不，以后你的代码仍然需要：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global(qos: .userInitiated).async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> strongSelf <span class="operator">=</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        strongSelf.log(<span class="string">&quot;before sleep&quot;</span>)</span><br><span class="line">        usleep(<span class="number">500</span>)</span><br><span class="line">        strongSelf.log(<span class="string">&quot;after sleep&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_swift-strongself-05.png" alt=""></p><p>当然，你可以加到 <code>snippets</code>，这样就可以快速插入代码了：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_swift-strongself-04.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>Swift 和 Objective-C 大不同，但是 iOS 内存管理仍然是 iOS 内存管理，ARC 仍然是 ARC，所以不管语法怎么变，关于内存和引用依旧还是原来的样子，<code>strongSelf</code> 也好，循环引用也好，千万别忘了去注意。</strong></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码都在<a href="https://github.com/summertian4/iOS-Swift/tree/master/StrongSelf">这里</a></p><h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><p>如果以下这幅图中的三个问题，你不能清晰的答出答案和其理由，建议你去读一读 Objective-C 关于内存管理的源码哟。这里是我的两篇博文，希望能帮到你：</p><ol><li><a href="http://lottyzhou.com/2017/02/08/iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS-Memory-Block/">iOS进阶——iOS（Objective-C） 内存管理&amp;Block</a></li><li><a href="http://lottyzhou.com/2017/02/15/Advanced-iOS-Study-objc-Memory-2/">iOS进阶——iOS（Objective-C）内存管理·二</a></li></ol><p>以下是三个问题：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_swift-strongself-03.jpeg" alt=""></p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开端&quot;&gt;&lt;a href=&quot;#开端&quot; class=&quot;headerlink&quot; title=&quot;开端&quot;&gt;&lt;/a&gt;开端&lt;/h1&gt;&lt;p&gt;Objective-C 中，有一段重复写到你不得不加入 &lt;code&gt;snippets&lt;/code&gt; 的代码块。就是下面这段&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; __typeof__(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) weakSelf = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.aButton touchUpInside:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(weakSelf)strongSelf = weakSelf;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (strongSelf) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        strongSelf.title = &lt;span class=&quot;string&quot;&gt;@&amp;quot;按钮被点击&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一般，由于重复写的次数过多，就加到了 &lt;code&gt;snippets&lt;/code&gt; 快捷代码块，以下是我的：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://lottyzhou.com/categories/iOS/"/>
    
      <category term="Swift" scheme="http://lottyzhou.com/categories/iOS/Swift/"/>
    
    
      <category term="iOS" scheme="http://lottyzhou.com/tags/iOS/"/>
    
      <category term="内存与引用" scheme="http://lottyzhou.com/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
    
      <category term="Swift" scheme="http://lottyzhou.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>简介我的 Git Work Flow</title>
    <link href="http://lottyzhou.com/2017/05/08/Git-Work-Flow/"/>
    <id>http://lottyzhou.com/2017/05/08/Git-Work-Flow/</id>
    <published>2017-05-08T07:31:46.000Z</published>
    <updated>2021-10-11T09:40:59.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h1><p>我们从重要性说起。</p><p>团队开发中要重视有洁癖的人，这种人往往对糟糕的工作流不断提出意见、对 Git 的使用方式提出要求。如果你的团队中这种人正在不断的被忽视，那么你的团队一定出现了管理混乱、代码质量不高等等等等问题。</p><p>统一的工作流程是至关重要的，不管对于哪一个行业的作业来说都一样。对于我们开发人员，工作流包含了开发时 Git 的使用规范、Repo 管理的规范、测试过程的规范、设计交互的管理规范等等。由于测试、交互等设计到更多的人员，本篇文章暂且不表，重点说 Git 的使用规范和 repo 管理的规范。</p><p>本篇文章将讲述我在工作中一直使用的 Work Flow，希望对大家有帮助。</p><span id="more"></span><h1 id="常见-Git-使用规范"><a href="#常见-Git-使用规范" class="headerlink" title="常见 Git 使用规范"></a>常见 Git 使用规范</h1><p>先举一个例子，放上几张 Network 的图形截图。为了你的工程不变成下面这个样子，请善待 Git 的使用：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-01.png" alt="示例1"></p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-02.png" alt="示例2"></p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-03.png" alt="示例3"></p><p>这样一个乱糟糟的 Git，你们能忍我不能忍。</p><p>先来说说几张图种的问题：</p><ol><li>反向拉取 <code>develop</code> 分支</li><li>不经过 <code>Pull Request</code> 的合并</li><li>重复使用已经合并的分支</li><li>没有意义的 <code>Commit Message</code></li></ol><p><strong>对于问题 1</strong>，敢问这位同学，能不能用 <code>rebase</code>？很多同学在开发分支过程中，发现 <code>develop</code> 有更新，就去拉取 <code>develop</code> 的内容 Merge 进自己当前分支。对于 <code>rebase</code> 和 <code>merge</code>，请参考 <a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9">这篇文章</a> 。引用里面的话：</p><blockquote><p>每次合并上游更改时 <code>feature</code> 分支都会引入一个外来的合并提交。如果 <code>develop</code> 非常活跃的话，这或多或少会污染你的分支历史。虽然高级的 <code>git log</code> 选项可以减轻这个问题，但对于开发者来说，<strong>还是会增加理解项目历史的难度。</strong></p></blockquote><p><strong>对于问题 2</strong>，完全就是习惯问题，对于所有的合并，如果是你自己的两个分支之间，如果非要直接 Merge 也不是不可，但是如果是两个人分别开发的分支，直接的 Merge 是不负责任的。<code>Pull Request</code> 或者 <code>Merge Request</code> 可以更早的帮你发现合并冲突，并且<strong>强制你 review 代码</strong>，这在保证代码质量方面起着至关重要的作用。</p><p><strong>对于问题 3</strong>，已经合并入 <code>develop</code> 分支的分支，最好在 <code>Pull Request</code> 合并时直接勾选移除原分支，更容易保持和 <code>develop</code> 的同步。</p><p><strong>对于问题 4</strong>，是最最最常见的问题，看看自己的项目，里面有多少个连续的 <code>Commit Message</code> 是『bug fix』、『update』、『pod add』、『修复』等等这样完全看不出啥内容的描述。敢问这样写的同学，你们的项目 Owner 看到 <code>Network</code> 时候是不是心里充满了 WTF？<code>Commit Message</code> 应当简短干练的描述这个 <code>commit</code> 做了什么。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-17.jpeg" alt=""></p><p>下面再看一个正面的示例，无比清爽的 Network：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-04.png" alt="示例3"></p><p>关于我的 Work Flow，我们从基本的 Git 开发流接着介绍。</p><h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><p>广为人知的 Git Flow 定义了一套标准的 Git 开发流。<a href="http://nvie.com/posts/a-successful-git-branching-model/">这里是经典文章</a>。</p><p>大致的意思为：</p><ol><li><code>master</code> 是长期分支，一般用于管理对外发布版本，每个 commit 对一个 tag，也就是一个发布版本</li><li><code>develop</code> 是长期分支，一般用于作为日常开发汇总，即开发版的代码</li><li><code>feature</code> 是短期分支，一般用于一个新功能的开发</li><li><code>hotfix</code> 是短期分支 ，一般用于正式发布以后，出现 bug，需要创建一个分支，进行 bug 修补。</li><li><code>release</code> 是短期分支，一般用于发布正式版本之前（即合并到 <code>master</code> 分支之前），需要有的预发布的版本进行测试。<code>release</code> 分支在经历测试之后，测试确认验收，将会被合并的 <code>develop</code> 和 <code>master</code></li></ol><p>具体的也可以参考 <a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a>。</p><h2 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h2><p>在开发中 Git 往往搭配持续交付平台，Github 也好，GitLab 也好，都提供了完备的持续交付管理功能。配合这些就有了 <a href="https://guides.github.com/introduction/flow/index.html">Github Flow</a></p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-05.png" alt="Github Flow"></p><p>大致意思为：</p><ol><li><code>master</code> 开出新分支，不区分功能分支或补丁分支。</li><li>新分支开发完成后，或者需要讨论的时候，就向 <code>master</code> 发起一个 <code>Pull Request</code>。</li><li>项目内人一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。</li><li><code>Pull Request</code> 通过，合并进 <code>master</code>，原分支就被删除。</li></ol><p>可以看出 Github Flow 是 Git Flow 的简化版本，但是加上了一些合作关节的把控。</p><h1 id="我的-Git-Work-Flow"><a href="#我的-Git-Work-Flow" class="headerlink" title="我的 Git Work Flow"></a>我的 Git Work Flow</h1><p>我通常希望团队中的开发流程类似 Git Flow，但更为详细，大致为：</p><h2 id="一、Git-分支部分"><a href="#一、Git-分支部分" class="headerlink" title="一、Git 分支部分"></a>一、Git 分支部分</h2><h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><p>长期分支，每个 <code>commit</code> 对一个 <code>tag</code>（一个发布版本）</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-06.png" alt="master"></p><h3 id="develop"><a href="#develop" class="headerlink" title="develop"></a>develop</h3><p>长期分支，日常开发汇总（开发版的代码）。</p><p>开发一个新的 feature 直接新在 <code>develop</code> 新开一个临时的 <code>feature</code> 分支，开发完成向 <code>develop</code> 提 <code>Pull Request`</code>Pull Request`。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-07.png" alt="develop"></p><h3 id="release"><a href="#release" class="headerlink" title="release"></a><code>release</code></h3><p>短期分支，feature 开发完成后从 <code>develop</code> 拉出的分支，用于测试阶段，期间添加的 <code>commit</code> 基本都是 bug fix，开发结束后同时和并进 <code>develop</code> 和 <code>master</code>，<code>master</code> 打上发布 tag。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-08.png" alt="release"></p><h3 id="hotfix"><a href="#hotfix" class="headerlink" title="hotfix"></a><code>hotfix</code></h3><p>短期分支，正式发布以后，进行 bug 修补</p><h2 id="二、Git-操作部分"><a href="#二、Git-操作部分" class="headerlink" title="二、Git 操作部分"></a>二、Git 操作部分</h2><h3 id="commit-规范"><a href="#commit-规范" class="headerlink" title="commit 规范"></a>commit 规范</h3><ol><li><code>commit message</code> 言简意赅，不要写无用信息。不要出现 『update』，『Bug Fix』，这样让别人不能领其意的描述</li><li>添加一个新的 <code>Pod</code> 库或 <code>pod update</code> 后，单独提交一个 <code>commit</code>，统一 <code>commit message</code> 为『pod add xxx』或 『pod update』</li><li><code>commit</code> 之间保持独立，不要有修改同一个文件的情况。比如一个 <code>Pull Request</code> 中 commit1 在 FileA 中改了一个变量名， commit2 改回了变量名。原因是：<strong>审核代码时，审核人通常会逐个 <code>commit</code>查看，而不是直接看 <code>Changes</code>（可以直接忽略掉 pod update 这样的 <code>commit</code> 不看）</strong></li></ol><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-09.png" alt=""></p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p><strong>不要出现反向拉取代码</strong>的情况，即文章开头第一张、第二张图片中的情况——看到 <code>develop</code> 有更新，就将 <code>develop</code> 的代码拉取 merge 进自己的分支。</p><p>原因是：</p><ol><li><code>merge</code> 会导致你的分支都会引入一个外来的合并提交。如果 <code>develop</code> 非常活跃的话，或多或少会污染你的分支。</li><li>丑，Network 复杂，增加理解项目历史的难度。</li></ol><p>如何解决当前 <code>develop</code> 有更新的情况？</p><p><strong>请使用 <code>rebase</code>！</strong></p><p><code>rebase</code> 用中文直译就是 <code>变基</code>。上张图帮助大家理解：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-10.png" alt="rebase"></p><p><code>rebase</code> 在进行时，需要选择一个 <code>commit</code> 点，将当前分支从根基整个移到指定 <code>commit</code> 点，名副其实——<code>变基</code>。</p><p>这样你既可以得到一个好看的 <code>Network</code>，又可以及时控制冲突。不过在多人开发中你需要多多关注 <code>develop</code> 的情况，及时 <code>rebase</code>，避免长时间不更新代码突然 <code>rebase</code> 到最新后发现了大量冲突。当然，控制和分配比较好的项目本身也很少产生冲突。</p><h2 id="三、GitLab-管理规范"><a href="#三、GitLab-管理规范" class="headerlink" title="三、GitLab 管理规范"></a>三、GitLab 管理规范</h2><h3 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h3><p>日常 Github 玩的转的同学都知道 <code>issue</code> 可以做很多事，比如：意见管理、Bug 管理、任务管理，可以只做一种功能，也能通过不同的 Label 同时使用所有的功能。</p><p>我的 Work Flow 中，<code>issue</code> 用来做任务管理，因为 <code>issue</code> 可以方便的指派，及时收到邮件通知。</p><p>每次新版本迭代开始，PRD 审核通过时，组内协商好任务分配后将任务拆成最小单元，由 Owner 分别建立 issue，大家自行领取。</p><p>如果有开发过程中发现的需要改进的地方，同样可以建立 issue。</p><p>关于 Label，我通常会分为：<code>optimizing</code>、<code>bug fix</code>、<code>feature</code></p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-11.png" alt="issue 管理任务"></p><p>一个任务完成时，通常会提 <code>Pull Request</code>，如果该 <code>Pull Request</code> 中完成了所有的任务，<code>Pull Request</code> 的 Title 应当类似以下格式：</p><blockquote><p>『close #13 首页滚动栏切换效果完善』</p></blockquote><p>GitLab 和 Github 都能识别 <code>close #&#123;issue id&#125;</code>，如果在 Title 中这样写，在 <code>Pull Request</code> 通过审核时，相应的 issue 会自动被关闭。</p><h3 id="Milestones"><a href="#Milestones" class="headerlink" title="Milestones"></a>Milestones</h3><p><code>Milestones</code> 即里程碑，<code>issue</code> 在建立的时候可以选择 <code>Milestones</code>，如果合理的使用了 <code>Milestones</code>，在 Milestones 页面，就可以得到一个清晰的项目进度。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-12.png" alt="Milestones 页面"></p><h3 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h3><p>所有的合并都需要提 <code>Pull Request</code>，包括自己的分支合并到自己的分支，可以更好的帮助大家养成 Code Review 的好习惯。</p><p><code>Pull Request</code> 的标题应该简介的介绍该次合并所做的事。更详细的内容应当在 <code>Description</code> 中逐条列出。如有相关文档链接也应列出。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-13.png" alt="Milestones 页面"></p><p>注意选择合适的 <code>Milestone</code> 和 <code>Labels</code>。选择一位 Assignee 来审核，如果觉得该 <code>Pull Request</code> 内容过多，或有需要大家共同讨论的地方，再 <code>Pull Request</code> 提交后，在 <code>Discussion</code> 区域 <code>@</code> 其他人，所有人都会及时收到邮件。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-14.png" alt="Milestones 页面"></p><h3 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h3><p><code>Code Review</code> 是一个很值得说的点。很多时候大家会以为 <code>Code Review</code> 是一定要读懂别人的代码，然后进行分析、审核。其实 <code>Code Review</code> 更多的是扮演了团队内经验传递的作用。</p><p>举个例子，代码规范这样的东西，就算是一个团队有了很详细的文档，但大家也不一定会去完整记下。对于新人，完成了 feature 后提 <code>Pull Request</code>，交由其他人 <code>Code Review</code> 时，由其他人审核代码规范，不合规要求继续修正，来回四五次，就再基本不会有问题了。</p><p>这也是我的亲身经历，我之前的一位 leader 对于 Work Flow 管理非常有经验，我在最初时提了几次 <code>Pull Request</code>，很快就熟悉了团队内的代码规范。</p><p>所以 <code>Code Review</code> 审核人应当检查的内容不是硬性的，但至少应当包括：</p><ol><li>代码规范</li><li>基本语法和基本逻辑错误</li><li>业务逻辑的一些经验</li><li>…</li></ol><p>在发现错误时，应当及时的添加 <code>comment</code>。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-15.png" alt="Milestones 页面"></p><p>当审核人全部审核完毕，添加完所有的 <code>comment</code> 之后需要在 <code>Discussion</code> 区域 <code>@提交人 review done</code>，通知提交人。</p><p>同样，提交人在按照 <code>comment</code> 修改完后，也应当在 <code>Discussion</code> 区域 <code>@相关审核人 修改完成，请重新审核</code>。</p><p>需要着重说明的是：提交人的<strong>所有修改，不允许新提交 <code>commit</code></strong>，应当在本地修改完成后，<code>ammend</code> 追加到最后 <code>commit</code>。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-16.png" alt="Milestones 页面"></p><p>但是这一点，只是我一直使用的方式，原因同样是遵循『<code>commit</code> 之间保持独立』，如果提交新的 <code>commit</code> 导致两个 <code>commit</code> 修改了同一个文件。</p><p>当然也有人认为新加 <code>commit</code> 可以更清晰的看到提交者的新变动，也更符合 <code>Github Flow</code>。关于这里，就没有什么强制了，更喜欢什么就什么。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后，希望大家都收获一个清爽如风的 Network。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_work-flow-04.png" alt="示例3"></p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;重要性&quot;&gt;&lt;a href=&quot;#重要性&quot; class=&quot;headerlink&quot; title=&quot;重要性&quot;&gt;&lt;/a&gt;重要性&lt;/h1&gt;&lt;p&gt;我们从重要性说起。&lt;/p&gt;
&lt;p&gt;团队开发中要重视有洁癖的人，这种人往往对糟糕的工作流不断提出意见、对 Git 的使用方式提出要求。如果你的团队中这种人正在不断的被忽视，那么你的团队一定出现了管理混乱、代码质量不高等等等等问题。&lt;/p&gt;
&lt;p&gt;统一的工作流程是至关重要的，不管对于哪一个行业的作业来说都一样。对于我们开发人员，工作流包含了开发时 Git 的使用规范、Repo 管理的规范、测试过程的规范、设计交互的管理规范等等。由于测试、交互等设计到更多的人员，本篇文章暂且不表，重点说 Git 的使用规范和 repo 管理的规范。&lt;/p&gt;
&lt;p&gt;本篇文章将讲述我在工作中一直使用的 Work Flow，希望对大家有帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://lottyzhou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://lottyzhou.com/tags/iOS/"/>
    
      <category term="git" scheme="http://lottyzhou.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>iOS——写一个快速定位问题的脚本</title>
    <link href="http://lottyzhou.com/2017/04/04/iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://lottyzhou.com/2017/04/04/iOS——写一个快速定位问题的脚本/</id>
    <published>2017-04-04T03:15:38.000Z</published>
    <updated>2021-10-11T09:40:59.395Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-12.png" alt=""></p><h1 id="你是否见过？"><a href="#你是否见过？" class="headerlink" title="你是否见过？"></a>你是否见过？</h1><ol><li>你是否见过测试人员或者自己在 CI 上 install 了一个版本，发现了 BUG 后，突然忘了自己下的是 CI 上的哪一个 commit 的包？</li><li>你是否见过下面这个东西：</li></ol><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-01.jpg" alt="blog_iOS——写一个快速定位问题的脚本-01"></p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-02.png" alt="blog_iOS——写一个快速定位问题的脚本-02"></p><span id="more"></span><h1 id="写一个这样一个脚本"><a href="#写一个这样一个脚本" class="headerlink" title="写一个这样一个脚本"></a>写一个这样一个脚本</h1><p>可以写这样一个脚本，它能做到：</p><ol><li>在 Build 的过程中在 App Icon 的表面覆盖上 Build 号、分支名、commit version 的 hash 值</li><li>不影响原本的 App Icon 图标源文件</li><li>区分 <code>Release</code> 和 <code>Debug</code>，只在 <code>Debug</code> 环境下 Build 项目时执行脚本</li></ol><h1 id="Do-it"><a href="#Do-it" class="headerlink" title="Do it"></a>Do it</h1><h2 id="ImageMagick"><a href="#ImageMagick" class="headerlink" title="ImageMagick"></a>ImageMagick</h2><p>做后端的同学们，大多知道 <a href="http://www.imagemagick.org/script/index.php">ImageMagick</a>。</p><blockquote><p>使用 ImageMagick 可以创建、编辑、合成或转换图片。它可以读和写各种格式的图像（超过 200 种格式）包括 PNG、JPEG、JPEG - 2000、GIF、TIFF、DPX、EXR、WebP、Postscript、PDF、SVG。ImageMagick 可以调整、翻转、镜像、旋转、扭曲、剪切和转换图像、图像色彩调整，适用于各种特殊效果,或绘制文本、线、多边形、椭圆和贝塞尔曲线。</p></blockquote><p>通过 shell command 就可以轻易使用以上功能。</p><hr><p>让我们来看一些基本的。这是我们准备好的 <code>120*120</code> 的原图：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-03.png" alt="blog_iOS——写一个快速定位问题的脚本-03"></p><p><code>cd</code> 到图片所在的目录，执行以下命令，给图片添加高斯模糊效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert original.png -blur 10x8 blurred.png</span><br></pre></td></tr></table></figure><p>完成图：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-04.png" alt="blog_iOS——写一个快速定位问题的脚本-04"></p><hr><p>继续，执行以下命令从 坐标 <code>(0,60)</code> 剪切成 <code>120*60</code> 的图片，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert blurred.png -crop 120x60+0+60 cropped-blurred.png</span><br></pre></td></tr></table></figure><p>完成图：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-05.png" alt="blog_iOS——写一个快速定位问题的脚本-05"></p><hr><p>继续，给图片添加文字水印『zhoulingyu』，参数包括：背景不填充颜色、白色字体、字体大小 12、居中显示文字、文字为『zhoulingyu』：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert -background none -fill white -pointsize 12 -gravity center caption:<span class="string">&quot;zhoulingyu&quot;</span> cropped-blurred.png +swap -composite label.png</span><br></pre></td></tr></table></figure><p>完成图：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-06.png" alt="blog_iOS——写一个快速定位问题的脚本-06"></p><hr><p>继续，将上面得到的剪切好的带水印的 <code>label.png</code> 和 原图 <code>original.png</code> 合成在一起：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composite label.png original.png finished-image.png</span><br></pre></td></tr></table></figure><p>完成图：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-07.png" alt="blog_iOS——写一个快速定位问题的脚本-07"></p><p>OK，我们得到了想要的效果图。</p><h2 id="参数参考"><a href="#参数参考" class="headerlink" title="参数参考"></a>参数参考</h2><p>给出一些 ImageMagic 的常用用法：</p><ol><li>查看图片信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">identify original.png </span><br><span class="line">original.png PNG 120x120 120x120+0+0 8-bit sRGB 46c 2.58KB 0.010u 0:00.000</span><br></pre></td></tr></table></figure><ol start="2"><li>格式转换</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert original.png original.jpg </span><br></pre></td></tr></table></figure><ol start="3"><li>编辑图片大小</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert original.png -resize 200x200 resize-image.png </span><br></pre></td></tr></table></figure><ol start="4"><li>裁剪</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从坐标 (0,0) 裁剪 100*100 的图像</span></span><br><span class="line">convert original.png -crop 100x100+0+0 crop.png  </span><br></pre></td></tr></table></figure><ol start="5"><li>旋转</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert original.png -rotate 45 rotate.png </span><br></pre></td></tr></table></figure><ol start="6"><li>合并图像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给图片添加水印</span></span><br><span class="line">convert original.png -compose over watermark.png -composite new-image.png  </span><br></pre></td></tr></table></figure><ol start="7"><li>高斯模糊</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert -blur 80x5 original.jpg blur.png</span><br></pre></td></tr></table></figure><p>-blur radiusxsigma，两个分别是高斯模糊需要的两个参数，具体可以查看 <a href="https://www.imagemagick.org/script/command-line-options.php#blur">blur 参数使用</a></p><p>ImageMagick 可以实现 N 多效果，像油画、噪声、散射、旋涡，都不在话下。</p><p>除了基本的效果，还有一些比较常用的参数：</p><table><thead><tr><th>参数名</th><th>使用规范</th><th>说明</th><th>用例</th></tr></thead><tbody><tr><td>-background</td><td>-background color</td><td>设置背景色</td><td>-background white</td></tr><tr><td>-pointsize</td><td>-pointsize value</td><td>设置字体等大小</td><td>-pointsize 12</td></tr><tr><td>-gravity</td><td>-gravity type</td><td>为其他命令附加 gravity，比如设置文字添加位置居中。</td><td>-gravity Center</td></tr><tr><td>-geometry</td><td>-geometry geometry</td><td>设置即将处理图像的坐标位置</td><td>-geometry +0+60 -geometry Center</td></tr></tbody></table><p>当然这些都可以在 <a href="https://www.imagemagick.org/script/command-line-options.php">官方文档</a> 找到。</p><h2 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h2><h3 id="1-基本设置"><a href="#1-基本设置" class="headerlink" title="1. 基本设置"></a>1. 基本设置</h3><p>知道 ImageMagic 如何使用，剩下来写脚本就思路清晰多了。</p><p>在工程 <code>Target</code> -&gt; <code>Build Phases</code> 中新建一个 Run Script，我们可以给它起名 <code>generate auxiliary icon</code>，这样稍后容易在 <code>Report Navigator</code> 观察。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-08.png" alt="blog_iOS——写一个快速定位问题的脚本-08"></p><p>现在我们可以开始编写我们的脚本 <code>auxiliary_icon.sh</code></p><h3 id="2-理思路"><a href="#2-理思路" class="headerlink" title="2. 理思路"></a>2. 理思路</h3><p>写伪代码通常能够帮助我自己更清晰的写代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 1. 判断执行 Build 的机器是否安装了 ImageMagic</span><br><span class="line">//    |- 如果没有安装：提示安装，退出脚本</span><br><span class="line">//    |- 如果安装：继续执行</span><br><span class="line">// 2. 获取 commit 号 hash 值、分支名、build 号，并将其拼接成一个字符串</span><br><span class="line">// 3. 判断编译环境</span><br><span class="line">//    |- 如果是 Release 环境：提示当前是 Release 环境，退出脚本</span><br><span class="line">//    |- 如果是非 Release 环境：继续执行</span><br><span class="line">// 4. 获取 Plist 中 CFBundleIconFiles 的数量</span><br><span class="line">// 5. 根据数量循环，执行调用『生成记号图方法』</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 『生成记号图方法』 </span><br><span class="line">// function generateIcon() &#123;</span><br><span class="line">// 1. 模糊图片</span><br><span class="line">// 2. 截取图片下半部分</span><br><span class="line">// 3. 添加 commit+brach+build 组成的字符串在截取图片上</span><br><span class="line">// 4. 合成截取图片和原图</span><br><span class="line">// 5. 清除多余图片</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>伪代码写好了，开始编写正式代码：</p><ol><li>判断执行 Build 的机器是否安装了 ImageMagic</li></ol><p>which 一下就知道</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">convertPath=`<span class="built_in">which</span> convert`</span><br><span class="line"><span class="comment"># 判断 convertPath 文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="variable">$&#123;convertPath&#125;</span>]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;==============</span></span><br><span class="line"><span class="string">WARNING: 你需要先安装 ImageMagick！！！！:</span></span><br><span class="line"><span class="string">brew install imagemagick</span></span><br><span class="line"><span class="string">==============&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ol start="2"><li>获取 commit 号 hash 值、分支名、build 号，并将其拼接成一个字符串</li></ol><p>PlistBuddy 可以用于读取 Plist 文件，通过描述路径就可以找到你想知道的 Key 对应的 Value。<br><code>$&#123;INFOPLIST_FILE&#125;</code> 是 xcodebuild 提供的变量（具体可以参考 <a href="http://help.apple.com/xcode/mac/8.0/#/itcaec37c2a6">Build settings reference</a>）提供了编译后 <code>info.plist</code> 的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commit=`git rev-parse --short HEAD`</span><br><span class="line">branch=`git rev-parse --abbrev-ref HEAD`</span><br><span class="line">buildNumber=`/usr/libexec/PlistBuddy -c <span class="string">&quot;Print CFBundleVersion&quot;</span> <span class="string">&quot;<span class="variable">$&#123;INFOPLIST_FILE&#125;</span>&quot;</span>`</span><br><span class="line">caption=<span class="string">&quot;<span class="variable">$&#123;buildNumber&#125;</span> \n<span class="variable">$&#123;branch&#125;</span>\n<span class="variable">$&#123;commit&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>判断编译环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Release 不执行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Configuration: <span class="variable">$CONFIGURATION</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;CONFIGURATION&#125;</span> = <span class="string">&quot;Release&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">exit</span> 0;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ol start="4"><li>获取 Plist 中 CFBundleIconFiles 的数量</li></ol><p>在编译后的 <code>info.plist</code> 中，可以找到如下结构：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-09.png" alt="blog_iOS——写一个快速定位问题的脚本-09"></p><p>这里记录了所有的 Icon files。查看 plist 的原格式，可以看到原始的 key 是什么。通过 PlistBuddy 和 路径 <code>CFBundleIcons:CFBundlePrimaryIcon:CFBundleIconFiles</code> 可以输出 value。</p><p><code>| wc -l</code> 可以统计输出行数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icon_count=`/usr/libexec/PlistBuddy -c <span class="string">&quot;Print CFBundleIcons:CFBundlePrimaryIcon:CFBundleIconFiles&quot;</span> <span class="string">&quot;<span class="variable">$&#123;CONFIGURATION_BUILD_DIR&#125;</span>/<span class="variable">$&#123;INFOPLIST_PATH&#125;</span>&quot;</span> | wc -l`</span><br></pre></td></tr></table></figure><p>要注意的是， <code>/usr/libexec/PlistBuddy -c &quot;Print CFBundleIcons:CFBundlePrimaryIcon:CFBundleIconFiles&quot; &quot;$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;INFOPLIST_PATH&#125;&quot;</code> 输出结果是这样的：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-10.png" alt="blog_iOS——写一个快速定位问题的脚本-10"></p><p>输出一共是 <strong>五行</strong>，所以获得的结果是 5。</p><p>那么真实的 CFBundleIconFiles count 其实是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">real_icon_index=$((<span class="variable">$&#123;icon_count&#125;</span> - <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>刚开始，我也没有注意。可想而知心情如何 =_=。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-11.JPG" alt="blog_iOS——写一个快速定位问题的脚本-11"></p><ol start="5"><li>根据数量循环，执行调用『生成记号图方法』</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=0; i&lt;<span class="variable">$real_icon_index</span>; i++)); <span class="keyword">do</span></span><br><span class="line"><span class="comment"># 找到 icon 名</span></span><br><span class="line">icon=`/usr/libexec/PlistBuddy -c <span class="string">&quot;Print CFBundleIcons:CFBundlePrimaryIcon:CFBundleIconFiles:<span class="variable">$i</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;CONFIGURATION_BUILD_DIR&#125;</span>/<span class="variable">$&#123;INFOPLIST_PATH&#125;</span>&quot;</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 generateIcon 方法，传入 icon 名</span></span><br><span class="line">generateIcon <span class="string">&quot;<span class="variable">$&#123;icon&#125;</span>@2x.png&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ol start="6"><li>generateIcon 方法</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">generateIcon</span></span>() &#123;</span><br><span class="line">    originalImg=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;CONFIGURATION_BUILD_DIR&#125;</span>/<span class="variable">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证存在性</span></span><br><span class="line">    <span class="keyword">if</span> [[ ! -f <span class="variable">$&#123;originalImg&#125;</span> || -z <span class="variable">$&#123;originalImg&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进入编译后的工程目录</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;CONFIGURATION_BUILD_DIR&#125;</span>/<span class="variable">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>/&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加高斯模糊</span></span><br><span class="line">    convert <span class="variable">$&#123;originalImg&#125;</span> -blur 10x8 blur-original.png</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 截取下部分</span></span><br><span class="line">    width=`identify -format %w <span class="variable">$&#123;originalImg&#125;</span>`</span><br><span class="line">    height=`identify -format %h <span class="variable">$&#123;originalImg&#125;</span>`</span><br><span class="line">    height_0=`expr <span class="variable">$&#123;height&#125;</span> / 2`</span><br><span class="line">    height_1=$((<span class="variable">$&#123;height&#125;</span> - <span class="variable">$&#123;height_0&#125;</span>))</span><br><span class="line">    convert blur-original.png -crop <span class="variable">$&#123;width&#125;</span>x<span class="variable">$&#123;height_0&#125;</span>+0+<span class="variable">$&#123;height_1&#125;</span> crop-blur-original.png</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加字</span></span><br><span class="line">    point_size=$(((<span class="number">8</span> * <span class="variable">$height</span>) / <span class="number">58</span>))</span><br><span class="line"></span><br><span class="line">    convert -background none -fill white -pointsize <span class="variable">$&#123;point_size&#125;</span> -gravity center caption:<span class="string">&quot;<span class="variable">$&#123;caption&#125;</span>&quot;</span> crop-blur-original.png +swap -composite label.png</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合成</span></span><br><span class="line">    composite -geometry +0+<span class="variable">$&#123;height_0&#125;</span> label.png <span class="variable">$&#123;originalImg&#125;</span> <span class="variable">$&#123;originalImg&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清除文件</span></span><br><span class="line">    rm blur-original.png</span><br><span class="line">    rm crop-blur-original.png</span><br><span class="line">    rm label.png</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码清单"><a href="#代码清单" class="headerlink" title="代码清单"></a>代码清单</h1><p>最终的代码清单放在了 Github 上：</p><blockquote><p><a href="https://github.com/summertian4/ZLYWatermarkIcon">ZLYWatermarkIcon</a></p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="http://www.imagemagick.org/script/convert.php">Command-line Tools:Convert</a><br><a href="http://blog.topspeedsnail.com/archives/7783">使用ImageMagick添加图片水印－Linux</a><br><a href="https://github.com/krzysztofzablocki/IconOverlaying">krzysztofzablocki/IconOverlaying</a><br><a href="http://merowing.info/2013/03/overlaying-application-version-on-top-of-your-icon/">Overlaying application version on top of your icon</a><br><a href="http://www.charry.org/docs/linux/ImageMagick/ImageMagick.html">我的ImageMagick使用心得</a><br><a href="http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html">高斯模糊的算法</a><br><a href="http://help.apple.com/xcode/mac/8.0/#/itcaec37c2a6">Build settings reference</a><br><a href="https://github.com/qinjx/30min_guides/blob/master/shell.md">Shell脚本编程30分钟入门</a></p></blockquote><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-12.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;你是否见过？&quot;&gt;&lt;a href=&quot;#你是否见过？&quot; class=&quot;headerlink&quot; title=&quot;你是否见过？&quot;&gt;&lt;/a&gt;你是否见过？&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;你是否见过测试人员或者自己在 CI 上 install 了一个版本，发现了 BUG 后，突然忘了自己下的是 CI 上的哪一个 commit 的包？&lt;/li&gt;
&lt;li&gt;你是否见过下面这个东西：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-01.jpg&quot; alt=&quot;blog_iOS——写一个快速定位问题的脚本-01&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC-02.png&quot; alt=&quot;blog_iOS——写一个快速定位问题的脚本-02&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://lottyzhou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://lottyzhou.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ssh-keygen 中生成的 randomart image 是什么</title>
    <link href="http://lottyzhou.com/2017/03/27/ssh-keygen-%E4%B8%AD%E7%94%9F%E6%88%90%E7%9A%84-randomart-image-%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://lottyzhou.com/2017/03/27/ssh-keygen-中生成的-randomart-image-是什么/</id>
    <published>2017-03-27T09:23:40.000Z</published>
    <updated>2021-10-11T09:40:59.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="randomart-image-出现在哪里"><a href="#randomart-image-出现在哪里" class="headerlink" title="randomart image 出现在哪里"></a>randomart image 出现在哪里</h1><p>通常我们在生成 SSH Key 的时候会用到 <code>ssh-keygen</code> 命令，在生成结束后，会输出类似如下的内容，这个 randomart image 是什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|       o=.       |</span><br><span class="line">|    o  o++E      |</span><br><span class="line">|   + . Ooo.      |</span><br><span class="line">|    + O B..      |</span><br><span class="line">|     = *S.       |</span><br><span class="line">|      o          |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="为什么会有-randomart-image"><a href="#为什么会有-randomart-image" class="headerlink" title="为什么会有 randomart image"></a>为什么会有 randomart image</h1><p>相比超长字符串，人们更容易接受图形。让我们对比两幅图片的差异比对比两个超长字符串也要容易的多。这就是为什么现在大家使用二维码，而不是复制粘贴 URL 的原因。</p><p>Randomart image 通过将 Key 转换成有规律的图片，让人可以更加容易的、快速的对比 Key 的异同。</p><h1 id="趣闻"><a href="#趣闻" class="headerlink" title="趣闻"></a>趣闻</h1><p>在<a href="http://aarontoponce.org/drunken_bishop.pdf">《The drunken bishop: An analysis of the OpenSSH<br>fingerprint visualization algorithm》</a>中，作者通过一段有趣的故事来表达 randomart image 生成的过程：</p><blockquote><p>Peter 主教发现自己在一个封闭的矩形房间内，四面都是墙壁，而地板上又铺满了黑白交替矩形的瓷砖。Peter 主教突然开始头疼——大概应为之前喝了太多的酒——于是开始随意的走动起来。准确的说，他是按照对角走位的方式，就好像国际象棋上的主教一样。当他遇到墙壁的时候，如果他踩着黑瓷砖，就走向白瓷砖，如果踩着白瓷砖就走向黑瓷砖。每次动作之后，他都会在瓷砖上放置一个硬币，记录他踩过这里一次。走了 64 步之后，用完了所有的硬币，Peter 突然醒了过来。多么奇怪的梦！</p></blockquote><h1 id="如何生成"><a href="#如何生成" class="headerlink" title="如何生成"></a>如何生成</h1><p>看了上面的故事，来说一说 randomart image 具体是如何生成的。</p><p>我们知道 OpenSSH Key 的指纹是一个 MD5 校验和，同事可以用 16 进制表示出来，类似这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc:94:b0:c1:e5:b0:98:7c:58:43:99:76:97:ee:9f:b7</span><br></pre></td></tr></table></figure><p>当然，也可以用二进制来表示。</p><p>于是按照 Peter 的走路方式，我们定义如下走位：</p><ol><li>“00” 表示向西北（左上）移动</li><li>“01” 表示向东北（右上）移动</li><li>“10” 表示向西南（右下）移动</li><li>“11” 表示向东南（坐下）移动</li></ol><p>就像这样：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ssh-keygen%20%E4%B8%AD%E7%94%9F%E6%88%90%E7%9A%84%20randomart%20image%20%E6%98%AF%E4%BB%80%E4%B9%88-01.jpg" alt=""></p><p>我们来画个图，用于表示黑白相间的瓷砖房，并每个格子上都编号，一开始的时候，Peter 在房间的中间：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ssh-keygen%20%E4%B8%AD%E7%94%9F%E6%88%90%E7%9A%84%20randomart%20image%20%E6%98%AF%E4%BB%80%E4%B9%88-02.jpg" alt=""></p><p>中间的 76 号就是 Peter 最初的位置。我们可以把 Peter 所在的格子表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 用坐标系表示</span><br><span class="line">P = x + 17y</span><br></pre></td></tr></table></figure><p>那么，从 76 号向四个方向移动 P 值变化：</p><ol><li>“00” 进入 58 号格子，数值 -18</li><li>“01” 进入 60 号格子，数值 -16</li><li>“10” 进入 92 号格子，数值 +16</li><li>“11” 进入 94 号格子，数值 +18</li></ol><p>对于碰墙的情况，做如下规则：</p><p>将房间的每个格子做分类，四个角分别为 a、b、c、d，靠着四面墙的分别为 T、R、B、L，其余部分为 M。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ssh-keygen%20%E4%B8%AD%E7%94%9F%E6%88%90%E7%9A%84%20randomart%20image%20%E6%98%AF%E4%BB%80%E4%B9%88-03.jpg" alt=""></p><p>对于每一种情况：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ssh-keygen%20%E4%B8%AD%E7%94%9F%E6%88%90%E7%9A%84%20randomart%20image%20%E6%98%AF%E4%BB%80%E4%B9%88-04.jpg" alt=""></p><p>解释一下上图，以 a 栏为例，如果下一步像左上移动，但是继续走就撞墙了，所以实际移动为 <code>不移动</code>；如果向右上移动，实际移动为 <code>向右移动</code>；如果向左下移动，实际移动为 <code>向下移动</code>；如果像右下移动，实际移动就是 <code>向下移动</code>。</p><p>那么 Peter 投掷硬币是怎样体现的？实际上，是做如下统计，每个格子，如果没有被踩过，则不做表示；如果被踩过一次，记录为 <code>.</code>；如果被踩了两次，记录为 <code>o</code>…具体如下：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ssh-keygen%20%E4%B8%AD%E7%94%9F%E6%88%90%E7%9A%84%20randomart%20image%20%E6%98%AF%E4%BB%80%E4%B9%88-05.jpg" alt=""></p><p>比较特别的是 <code>S</code> 和 <code>E</code>，<code>S</code> 和 <code>E</code> 分别标记起始和终止位置（所以 76 号格子永远是 S）。</p><p>实际操作一下，对于 <code>fc:94:b0:c1:e5:b0:98:7c:58:43:99:76:97:ee:9f:b7</code>，我们将其转换成二进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11010100:11010100:11111101:11001010:...:00111011:11100100:10111010:11101001</span><br></pre></td></tr></table></figure><p>将二进制二位一组，按照下表做好走路的顺序：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ssh-keygen%20%E4%B8%AD%E7%94%9F%E6%88%90%E7%9A%84%20randomart%20image%20%E6%98%AF%E4%BB%80%E4%B9%88-06.jpg" alt=""></p><p>按照上面的顺序，踩到格子的顺序如下。</p><p>76, 58, 76, 94, 112, 94, 78, 62, 78, 60, 42, 60, 76, 60, 42, 24, 42, 26, 10, 26, 44, 26, 8, 26, 42, 24, 40, 24, 40, 22, 40, 58, 42, 24, 40, 24, 8, 26, 8, 7, 8, 9, 25, 9, 25, 41, 25, 43, 27, 45, 29, 13, 29, 45, 63, 79, 97, 115, 133, 117, 133, 151, 135, 152, 151</p><p>最后做成统计，填好图，成品就如下。是不是就和我们平常在控制台得到的输出一致？</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_ssh-keygen%20%E4%B8%AD%E7%94%9F%E6%88%90%E7%9A%84%20randomart%20image%20%E6%98%AF%E4%BB%80%E4%B9%88-07.jpg" alt=""></p><h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><blockquote><p><a href="https://superuser.com/questions/22535/what-is-randomart-produced-by-ssh-keygen">What is randomart produced by ssh-keygen?</a><br><a href="https://pthree.org/2013/05/30/openssh-keys-and-the-drunken-bishop/">OpenSSH Keys and The Drunken Bishop</a><br><a href="http://aarontoponce.org/drunken_bishop.pdf">The drunken bishop: An analysis of the OpenSSH<br>fingerprint visualization algorithm</a></p></blockquote><p><em>最后一点说明：其主要原理都发表在 <a href="http://aarontoponce.org/drunken_bishop.pdf">The drunken bishop: An analysis of the OpenSSH<br>fingerprint visualization algorithm</a></em></p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;randomart-image-出现在哪里&quot;&gt;&lt;a href=&quot;#randomart-image-出现在哪里&quot; class=&quot;headerlink&quot; title=&quot;randomart image 出现在哪里&quot;&gt;&lt;/a&gt;randomart image 出现在哪里&lt;/h1&gt;&lt;p&gt;通常我们在生成 SSH Key 的时候会用到 &lt;code&gt;ssh-keygen&lt;/code&gt; 命令，在生成结束后，会输出类似如下的内容，这个 randomart image 是什么呢？&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;The key&amp;#x27;s randomart image is:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+--[ RSA 2048]----+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|       o=.       |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|    o  o++E      |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|   + . Ooo.      |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|    + O B..      |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|     = *S.       |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|      o          |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-----------------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="冷知识" scheme="http://lottyzhou.com/categories/%E5%86%B7%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Other" scheme="http://lottyzhou.com/categories/%E5%86%B7%E7%9F%A5%E8%AF%86/Other/"/>
    
    
      <category term="冷知识" scheme="http://lottyzhou.com/tags/%E5%86%B7%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Other" scheme="http://lottyzhou.com/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>iOS进阶——iOS（Objective-C）内存管理·二</title>
    <link href="http://lottyzhou.com/2017/02/15/Advanced-iOS-Study-objc-Memory-2/"/>
    <id>http://lottyzhou.com/2017/02/15/Advanced-iOS-Study-objc-Memory-2/</id>
    <published>2017-02-15T03:59:33.000Z</published>
    <updated>2021-10-11T09:40:59.391Z</updated>
    
    <content type="html"><![CDATA[<p>在写 『<a href="http://lottyzhou.com/2017/02/08/iOS进阶——iOS-Memory-Block/">iOS（Objective-C） 内存管理&amp;Block</a>』 一文时，我并没有发现 NSObject 的代码已经被开源了，所以分析的主要是 GNUStep 的源码，对 Apple 的部分只是通过猜测。</p><p>实质上，NSObject 的实现内容已经开源在 <a href="https://opensource.apple.com/tarballs/objc4/">objc4-706</a> 中。于是我便开始学习 objc4 中的内容。</p><p>下面就和大家扒一扒 Apple 的 NSObject 内存管理的一些内容。</p><h1 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h1><p>找到 NSObject.mm，首先来一些非常重要的信息，以便后面的理解。</p><p><strong>objc4-706 NSObject.mm SideTable:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SideTable &#123;</span><br><span class="line">    <span class="comment">// 保证原子操作的自旋锁</span></span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    <span class="comment">// 引用计数的 hash 表</span></span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="comment">// weak 引用全局 hash 表</span></span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p>SideTable 结构体重定了几个非常重要的变量。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The order of these bits is important.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  <span class="comment">// MSB-ward of weak bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  <span class="comment">// MSB-ward of deallocating bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_SHIFT 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1)</span></span><br></pre></td></tr></table></figure><p>以上定义的是几个重要偏移量。引用计数 retainCount 是保存在一个无符号整形中，也就是有 8 个字节。其结构可以用下图表示：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_Advanced-iOS-Study-objc-Memory-2-01.png" alt=""></p><ol><li><code>SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</code>（表示对象所在内存的第 1 位），标识该对象是否有过 weak 对象；</li><li><code>SIDE_TABLE_DEALLOCATING (1UL&lt;&lt;1)</code>（表示对象所在内存的第 2 位），标识该对象是否正在 dealloc（析构）。</li><li><code>SIDE_TABLE_RC_ONE (1UL&lt;&lt;2)</code> （表示对象所在内存的第 3 位），存放引用计数数值（其实第三位之后都用来存放引用计数数值）。</li></ol><h1 id="retainCount"><a href="#retainCount" class="headerlink" title="retainCount"></a>retainCount</h1><p>找到 retainCount 的实现，一层一层向下看。</p><p><strong>objc4 NSObject.mm retainCount:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4 objc-object.h rootRetainCount:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (uintptr_t)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4 NSObject.mm sidetable_retainCount:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    size_t refcnt_result = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">        <span class="comment">// this is valid for SIDE_TABLE_RC_PINNED too</span></span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    <span class="keyword">return</span> refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>it-&gt;second 指向的就是存放引用计数相关的那个 8 位的无符号整型。</p><p>上面介绍过 Sidetable 中的几个重要偏移量，通过位移 SIDE_TABLE_RC_SHIFT 可以获取真实的引用计数。</p><p>所以，<code>sidetable_retainCount()</code> 中的主要内容就是遍历引用计数表，查找对象获取引用计数 +1 并将结果返回。</p><h1 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h1><p>找到 retain 的实现。</p><p><strong>objc4 NSObject.mm retain:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRetain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4 objc-objc.h rootRetain:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base retain implementation, ignoring overrides.</span></span><br><span class="line"><span class="comment">// This does not check isa.fast_rr; if there is an RR override then </span></span><br><span class="line"><span class="comment">// it was already called and it chose to call [super retain].</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </span><br><span class="line">objc_object::rootRetain()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4 NSObject.mm sidetable_retain:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    size_t&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">    <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>refcntStorage += SIDE_TABLE_RC_ONE</code> 让人费解，实际是怎么回事呢？我们通过距离说明：</p><p>如果 obj 的引用计数数值为 1（二进制 00000100，因为第一位，第二位用来标识其他内容），现在如果进行 retain，需要对引用计数数值增加 1，那么需要由 00000100 =&gt; 00001000。所以实际上，从整型的角度，是 <code>retainCount + 4</code>，而不是我们理解的 +1。</p><p>SIDE_TABLE_RC_ONE 定义是的 1UL&lt;&lt;2，也就是4，所以这里 <code>refcntStorage += SIDE_TABLE_RC_ONE;</code>。</p><h1 id="release"><a href="#release" class="headerlink" title="release"></a>release</h1><p><strong>objc4-706 NSObject.mm release:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release &#123;</span><br><span class="line">    ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4-706 objc-object.h rootRelease:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootRelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> sidetable_release(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4-706 NSObject.mm sidetable_release:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rdar://20206767</span></span><br><span class="line"><span class="comment">// return uintptr_t instead of bool so that the various raw-isa </span></span><br><span class="line"><span class="comment">// -release paths all return zero in eax</span></span><br><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_release(<span class="keyword">bool</span> performDealloc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> do_dealloc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) &#123;</span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        table.refcnts[<span class="keyword">this</span>] = SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&#x27;t change it.</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看后面几个判断。</p><ol><li>如果对象记录在引用计数表的最后一个：<code>do_dealloc</code> 设置为 true，引用计数数值设置为 SIDE_TABLE_DEALLOCATING（二进制 00000010）。</li><li>如果 8 位的引用计数小于 SIDE_TABLE_DEALLOCATING（二进制 00000010），也就如果是 00000001 或 00000000：<code>do_dealloc</code> 设置为 true，并添加 deallocating 标识位。（但至于有什么用不太理解，希望哪位大神指点一下）。</li><li>如果已经 <code>8 位引用计数 &amp; SIDE_TABLE_RC_PINNED</code> ，即对象不在 deallocating，且没有被弱引用，且 8 位没有溢出：8 位引用计数减少 4，即真实引用计数数值 -1。</li><li>最后，如果 <code>do_dealloc</code> 和 <code>performDealloc</code>（传入时就已经为 true）都为 ture，执行 SEL_dealloc 释放对象。</li><li>方法返回 do_dealloc。</li></ol><hr><p>如果你只想知道 ARC 引用计数相关，那么只需要看上面的代码就可以了。alloc 和 dealloc 主要是对对象的一些内存分配。</p><hr><h1 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h1><p>查看 alloc 相关代码。</p><p><strong>objc4-706 NSObject.mm alloc:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)alloc &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4-706 NSObject.mm _objc_rootAlloc:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span></span><br><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4-706 NSObject.mm callAlloc:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span></span><br><span class="line">        <span class="comment">// fixme store hasCustomAWZ in the non-meta class and </span></span><br><span class="line">        <span class="comment">// add it to canAllocFast&#x27;s summary</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(cls-&gt;canAllocFast())) &#123;</span><br><span class="line">            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span></span><br><span class="line">            <span class="keyword">bool</span> dtor = cls-&gt;hasCxxDtor();</span><br><span class="line">            <span class="keyword">id</span> obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, cls-&gt;bits.fastInstanceSize());</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span></span><br><span class="line">            <span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> [cls alloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入方法后先进行 <code>if (slowpath(checkNil &amp;&amp; !cls)) return nil;</code> 判断。</p><p><strong>objc4-706 objc-os.h slowpath:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastpath(x) (__builtin_expect(bool(x), 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> slowpath(x) (__builtin_expect(bool(x), 0))</span></span><br></pre></td></tr></table></figure><p><code>__builtin_expect(exp, n)</code> 方法表示 exp 很有可能为 0，返回值为 exp。你可以将 <code>fastpath(x)</code> 理解成真值判断，<code>slowpath(x)</code> 理解成假值判断。</p><p>所以，根据传入值，<code>checkNil</code> 为 false，<code>checkNil &amp;&amp; !cls</code> 也为 false。那么这里不会返回 nil。继续向下阅读。</p><p>其后是一个 Objective-C 2.0 的条件编译指令。当然我们现在用的都属于 Objctive-C 2.0，会执行其中代码。首先进行一个判断 <code>if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ()))... else ...</code>，这是判断一个类是否有自定义的 <code>+allocWithZone</code> 实现。</p><p>如果没有自定义的 <code>+allocWithZone</code> 实现。进行下一步，又是一个判断：<code>if (fastpath(cls-&gt;canAllocFast()))... else ...</code>，这里只有对象不存在、没有 isa 等情况才会为真值。所以之间看 else 内容。</p><p>else 代码块中调用了 <code>id obj = class_createInstance(cls, 0);</code>。查看内容时注意查看 <code>objc-runtime-new.h</code> 中的内容而不是 <code>objc-runtime-old.mm</code> 中的内容（你可以注意到 <code>objc-runtime-new.h</code> 顶部的 Coptyright 是 Copyright (c) 2005-2007 Apple Inc.  All Rights Reserved.）</p><p>在 <code>objc-runtime-new.mm</code> 中 <code>canAllocFast()</code> 定义如下：</p><p><strong>objc4-706 objc-runtime-new.h canAllocFast:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FAST_ALLOC</span></span><br><span class="line">    <span class="keyword">bool</span> canAllocFast() &#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; FAST_ALLOC;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">bool</span> canAllocFast() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>再看 FAST_ALLOC 定义，观察下图：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_Advanced-iOS-Study-objc-Memory-2-02.png" alt="FAST_ALLOC"></p><p>发现，<code>#elif 1</code> 直接拦截了下面的 define，所以 <code>#if FAST_ALLOC</code> 不起作用（这里我也不是很确定，哪位大神指点一下）。所以，<code>canAllocFast()</code> 返回 false，<code>fastpath(cls-&gt;canAllocFast())</code> 判断为假。</p><p>执行</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Has ctor or raw isa or something. Use the slower path.</span></span><br><span class="line"><span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line"><span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure><p><strong>objc4 objc-runtime-new.mm class_createInstance:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> </span><br><span class="line">class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4 objc-runtime-new.mm _class_createInstanceFromZone:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> </span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *bytes;</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can&#x27;t create something for nothing</span></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate and initialize</span></span><br><span class="line">    size = cls-&gt;alignedInstanceSize() + extraBytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">        bytes = malloc_zone_calloc((malloc_zone_t *)zone, <span class="number">1</span>, size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bytes = calloc(<span class="number">1</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objc_constructInstance(cls, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的 <code>extraBytes</code> 为0，<code>zone</code> 为 nil，那么主要执行的语句是 <code>bytes = calloc(1, size);</code> 和 <code>return objc_constructInstance(cls, bytes);</code>。bytes 是对象所需内存空间。</p><blockquote><p><strong>FYI:</strong><br><code>calloc(size_t __count, size_t __size)</code> 是 C 语言中的方法，用来在内存的动态存储区中分配 n 个长度为size的连续空间，函数返回一个指向分配起始地址的指针。如果分配不成功，返回NULL。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">objc_constructInstance(Class cls, <span class="keyword">void</span> *bytes) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls  ||  !bytes) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> obj = (<span class="keyword">id</span>)bytes;</span><br><span class="line"></span><br><span class="line">    obj-&gt;initIsa(cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;hasCxxCtor()) &#123;</span><br><span class="line">        <span class="keyword">return</span> object_cxxConstructFromClass(obj, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_constructInstance</code> 方法中，将 <code>bytes</code>（指向分对象的指针）定义为 <code>obj</code>，并将 <code>obj</code> 的 isa 赋值为传入的 cls。最后返回 obj。</p><blockquote><p><strong>FYI:</strong><br>hasCxxCtor() 是判断当前 class 或者 superclass 是否有 .cxx_construct 构造方法的实现。<br>hasCxxDtor() 是判断判断当前 class 或者 superclass 是否有 .cxx_destruct 析构方法的实现。<br>参考：<a href="http://ios.jobbole.com/90310/">Objc 对象的今生今世</a></p></blockquote><h1 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h1><p>找到 dealloc 的实现。</p><p><strong>objc4 NSObject.mm dealloc:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4 NSObject.mm _objc_rootDealloc:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_objc_rootDealloc(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4 NSObject.mm _objc_rootDealloc:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line">    object_dispose((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>FYI:</strong><br><a href="http://blog.devtang.com/2014/05/30/understand-tagged-pointer/">深入理解Tagged Pointer</a></p></blockquote><p><strong>objc4 objc-runtime-new.mm object_dispose:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> </span><br><span class="line">object_dispose(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4 objc-runtime-new.mm objc_destructInstance:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_destructInstance</span></span><br><span class="line"><span class="comment">* Destroys an instance without freeing memory. </span></span><br><span class="line"><span class="comment">* Calls C++ destructors.</span></span><br><span class="line"><span class="comment">* Calls ARC ivar cleanup.</span></span><br><span class="line"><span class="comment">* Removes associative references.</span></span><br><span class="line"><span class="comment">* Returns `obj`. Does nothing if `obj` is nil.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> *objc_destructInstance(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>objc4 objc-object.h clearDeallocating:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    sidetable_clearDeallocating();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>objc4 NSObject.mm sidetable_clearDeallocating:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_object::sidetable_clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear any weak table items</span></span><br><span class="line">    <span class="comment">// clear extra retain count and deallocating bit</span></span><br><span class="line">    <span class="comment">// (fixme warn or abort if extra retain count == 0 ?)</span></span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123;</span><br><span class="line">            weak_clear_no_lock(&amp;table.weak_table, (<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        table.refcnts.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，<code>objc_destructInstance(obj);</code> 中进行了销毁实例但不释放内存，调用了 C++ 的析构函数（如果对象有），处理先关的对象（如果有），最后调用 <code>obj-&gt;clearDeallocating();</code> 清除 weak 引用、清除多余的 retain count。<code>objc_destructInstance(obj);</code> 之后是 <code>free(obj);</code> 释放 obj 占用的内存空间。</p><p>#Other</p><p>（在写这边文章的时候，我怎么感觉我最大的感触是，C++ 不懂。。）</p><p>写本篇博文时参考的所有资料：</p><blockquote><p><a href="http://blog.tracyone.com/2015/06/14/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAARC-%E4%B8%8A/">Tracy Wang-深入浅出ARC(上)</a></p><p><a href="http://www.jianshu.com/p/ff8a7c458c96">原来我非不快乐-我们的对象会经历什么</a></p><p><a href="http://www.desgard.com/weak/">desgard-weak 弱引用的实现方式</a></p><p><a href="http://ios.jobbole.com/90310/">Objc 对象的今生今世</a></p><p><a href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/">玉令天下-Objective-C 引用计数原理</a></p><p><a href="http://www.jianshu.com/p/9d649ce6d0b8">一缕殇流化隐半边冰霜-神经病院Objective-C Runtime入院第一天——isa和Class</a></p><p><a href="http://sindrilin.com/runtime/2016/12/23/闲聊内存管理">sindrilin-闲聊内存管理</a></p></blockquote><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写 『&lt;a href=&quot;http://lottyzhou.com/2017/02/08/iOS进阶——iOS-Memory-Block/&quot;&gt;iOS（Objective-C） 内存管理&amp;amp;Block&lt;/a&gt;』 一文时，我并没有发现 NSObject 的代码已经被开源了，所以分析的主要是 GNUStep 的源码，对 Apple 的部分只是通过猜测。&lt;/p&gt;
&lt;p&gt;实质上，NSObject 的实现内容已经开源在 &lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/&quot;&gt;objc4-706&lt;/a&gt; 中。于是我便开始学习 objc4 中的内容。&lt;/p&gt;
&lt;p&gt;下面就和大家扒一扒 Apple 的 NSObject 内存管理的一些内容。&lt;/p&gt;
&lt;h1 id=&quot;SideTable&quot;&gt;&lt;a href=&quot;#SideTable&quot; class=&quot;headerlink&quot; title=&quot;SideTable&quot;&gt;&lt;/a&gt;SideTable&lt;/h1&gt;&lt;p&gt;找到 NSObject.mm，首先来一些非常重要的信息，以便后面的理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;objc4-706 NSObject.mm SideTable:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; SideTable &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保证原子操作的自旋锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    spinlock_t slock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 引用计数的 hash 表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RefcountMap refcnts;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// weak 引用全局 hash 表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    weak_table_t weak_table;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://lottyzhou.com/categories/iOS/"/>
    
      <category term="iOS进阶" scheme="http://lottyzhou.com/categories/iOS/iOS%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="iOS" scheme="http://lottyzhou.com/tags/iOS/"/>
    
      <category term="iOS进阶" scheme="http://lottyzhou.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
      <category term="内存与引用" scheme="http://lottyzhou.com/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS进阶——iOS（Objective-C） 内存管理&amp;Block</title>
    <link href="http://lottyzhou.com/2017/02/08/iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS-Memory-Block/"/>
    <id>http://lottyzhou.com/2017/02/08/iOS进阶——iOS-Memory-Block/</id>
    <published>2017-02-08T07:33:40.000Z</published>
    <updated>2021-10-11T09:40:59.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一篇-iOS-内存管理"><a href="#第一篇-iOS-内存管理" class="headerlink" title="第一篇 iOS 内存管理"></a>第一篇 iOS 内存管理</h1><h2 id="1-似乎每个人在学习-iOS-过程中都考虑过的问题"><a href="#1-似乎每个人在学习-iOS-过程中都考虑过的问题" class="headerlink" title="1 似乎每个人在学习 iOS 过程中都考虑过的问题"></a>1 似乎每个人在学习 iOS 过程中都考虑过的问题</h2><ol><li>alloc retain release delloc 做了什么？</li><li>autoreleasepool 是怎样实现的？</li><li>__unsafe_unretained 是什么？</li><li>Block 是怎样实现的</li><li>什么时候会引起循环引用，什么时候不会引起循环引用？</li></ol><p>所以我将在本篇博文中详细的从 ARC 解释到 iOS 的内存管理，以及 Block 相关的原理、源码。</p><h2 id="2-从-ARC-说起"><a href="#2-从-ARC-说起" class="headerlink" title="2 从 ARC 说起"></a>2 从 ARC 说起</h2><p>说 iOS 的内存管理，就不得不从 ARC（Automatic Reference Counting / 自动引用计数） 说起， ARC 是 WWDC2011 和 iOS5 引入的变化。ARC 是 LLVM 3.0 编译器的特性，用来自动管理内存。</p><p>与 Java 中 GC 不同，ARC 是编译器特性，而不是基于运行时的，所以 ARC 其实是在编译阶段自动帮开发者插入了管理内存的代码，而不是实时监控与回收内存。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-01.png" alt="ARC 管理内存"></p><p>ARC 的内存管理规则可以简述为：</p><blockquote><ol><li>每个对象都有一个『被引用计数』</li><li>对象被持有，『被引用计数』+1</li><li>对象被放弃持有，『被引用计数』-1</li><li>『引用计数』=0，释放对象</li></ol></blockquote><h2 id="3-你需要知道"><a href="#3-你需要知道" class="headerlink" title="3 你需要知道"></a>3 你需要知道</h2><p><del>1. 包含 NSObject 类的 Foundation 框架并没有公开</del><br>（此处错误，感谢 <a href="http://www.jianshu.com/u/486bf26e8dce">酷酷的哀殿</a> 的指出）</p><ol><li>Foundation 框架是非开源的，但是 NSObject 被包含在 <a href="https://opensource.apple.com/source/objc4/objc4-706/runtime/NSObject.mm">obj4</a> 中，该库已开源。</li><li>Core Foundation 框架源代码，以及通过 NSObject 进行内存管理的部分源代码是公开的。</li><li>GNUstep 是 Foundation 框架的互换框架</li></ol><blockquote><p>GNUstep 也是 GNU 计划之一。将 Cocoa Objective-C 软件库以自由软件方式重新实现<br>某种意义上，GNUstep 和 Foundation 框架的实现是相似的<br>通过 GNUstep 的源码来分析 Foundation 的内存管理</p></blockquote><h2 id="4-alloc-retain-release-dealloc-的实现"><a href="#4-alloc-retain-release-dealloc-的实现" class="headerlink" title="4 alloc retain release dealloc 的实现"></a>4 alloc retain release dealloc 的实现</h2><h3 id="4-1-GNU-alloc"><a href="#4-1-GNU-alloc" class="headerlink" title="4.1 GNU - alloc"></a>4.1 GNU - alloc</h3><p>查看 GNUStep 中的 alloc 函数。</p><p><strong>GNUstep/modules/core/base/Source/NSObject.m alloc:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>) alloc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> allocWithZone: <span class="built_in">NSDefaultMallocZone</span>()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>) allocWithZone: (<span class="built_in">NSZone</span>*)z</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NSAllocateObject</span> (<span class="keyword">self</span>, <span class="number">0</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GNUstep/modules/core/base/Source/NSObject.m NSAllocateObject:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> obj_layout &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> retained;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSAllocateObject</span>(Class aClass, <span class="built_in">NSUInteger</span> extraBytes, <span class="built_in">NSZone</span> *zone)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>size = 计算容纳对象所需内存大小;</span><br><span class="line">    <span class="keyword">id</span>new = <span class="built_in">NSZoneCalloc</span>(zone, <span class="number">1</span>, size);</span><br><span class="line">    memset (new, <span class="number">0</span>, size);</span><br><span class="line">    new = (<span class="keyword">id</span>)&amp;((obj)new)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NSAllocateObject</code> 函数通过调用 <code>NSZoneCalloc</code> 函数来分配存放对象所需的空间，之后将该内存空间置为 nil，最后返回作为对象而使用的指针。</p><p>我们将上面的代码做简化整理：</p><p><strong>GNUstep/modules/core/base/Source/NSObject.m alloc 简化版本:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> obj_layout &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> retained;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>) alloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> obj_layout) + 对象大小;</span><br><span class="line">    <span class="keyword">struct</span> obj_layout *p = (<span class="keyword">struct</span> obj_layout *)calloc(<span class="number">1</span>, size);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)(p+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> allocWithZone: <span class="built_in">NSDefaultMallocZone</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>alloc 类方法用 struct obj_layout 中的 <code>retained</code> 整数来保存引用计数，并将其写入对象的内存头部，该对象内存块全部置为 0 后返回。</p><p>一个对象的表示便如下图：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-02.png" alt="GNU 中的对象存储空间"></p><h3 id="4-2-GNU-retain"><a href="#4-2-GNU-retain" class="headerlink" title="4.2 GNU - retain"></a>4.2 GNU - retain</h3><p><strong>GNUstep/modules/core/base/Source/NSObject.m retainCount:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>) retainCount</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">self</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">NSUInteger</span></span><br><span class="line"><span class="built_in">NSExtraRefCount</span>(<span class="keyword">id</span> anObject)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ((obj_layout)anObject)[<span class="number">-1</span>].retained;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GNUstep/modules/core/base/Source/NSObject.m retain:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) <span class="keyword">retain</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">self</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">id</span> anObject)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="built_in">UINT_MAX</span> - <span class="number">1</span>)</span><br><span class="line">    [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">      format: <span class="string">@&quot;NSIncrementExtraRefCount() asked to increment too far”];</span></span><br><span class="line"><span class="string">  ((obj_layout)anObject)[-1].retained++;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>以上代码中， <code>NSIncrementExtraRefCount</code> 方法首先写入了当 <code>retained</code> 变量超出最大值时发生异常的代码（因为 <code>retained</code> 是 NSUInteger 变量），然后进行 <code>retain ++</code> 代码。</p><h3 id="4-3-GNU-release"><a href="#4-3-GNU-release" class="headerlink" title="4.3 GNU - release"></a>4.3 GNU - release</h3><p>和 retain 相应的，release 方法做的就是 <code>retain --</code>。</p><p><strong>GNUstep/modules/core/base/Source/NSObject.m release</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>) release</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      [<span class="keyword">self</span> dealloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span></span><br><span class="line"><span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">id</span> anObject)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">  ((obj)anObject)[<span class="number">-1</span>].retained--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-GNU-dealloc"><a href="#4-4-GNU-dealloc" class="headerlink" title="4.4 GNU - dealloc"></a>4.4 GNU - dealloc</h3><p>dealloc 将会对对象进行释放。</p><p><strong>GNUstep/modules/core/base/Source/NSObject.m dealloc:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) dealloc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSDeallocateObject</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">NSDeallocateObject</span>(<span class="keyword">id</span> anObject)</span><br><span class="line">&#123;</span><br><span class="line">  obj_layout o = &amp;((obj_layout)anObject)[<span class="number">-1</span>];</span><br><span class="line">  free(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-Apple-实现"><a href="#4-5-Apple-实现" class="headerlink" title="4.5 Apple 实现"></a>4.5 Apple 实现</h3><p>在 Xcode 中 设置 <code>Debug</code> -&gt; <code>Debug Workflow</code> -&gt; <code>Always Show Disassenbly</code> 打开。这样在打断点后，可以看到更详细的方法调用。</p><p>通过在 NSObject 类的 alloc 等方法上设置断点追踪可以看到几个方法内部分别调用了：</p><p><strong>retainCount</strong></p><blockquote><p>__CFdoExternRefOperation<br>CFBasicHashGetCountOfKey</p></blockquote><p><strong>retain</strong></p><blockquote><p>__CFdoExternRefOperation<br>CFBasicHashAddValue</p></blockquote><p><strong>release</strong></p><blockquote><p>__CFdoExternRefOperation<br>CFBasicHashRemoveValue</p></blockquote><p>可以看到他们都调用了一个共同的 <code>__CFdoExternRefOperation</code> 方法。</p><p>该方法从前缀可以看到是包含在 Core Foundation，在 CFRuntime.c 中可以找到，做简化后列出源码：</p><p><strong>CFRuntime.c __CFDoExternRefOperation:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __CFDoExternRefOperation(uintptr_t op, <span class="keyword">id</span> obj) &#123;</span><br><span class="line">    <span class="built_in">CFBasicHashRef</span> table = 取得对象的散列表(obj);</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> OPERATION_retainCount:</span><br><span class="line">        count = <span class="built_in">CFBasicHashGetCountOfKey</span>(table, obj);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OPERATION_retain:</span><br><span class="line">        count = <span class="built_in">CFBasicHashAddValue</span>(table, obj);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">        <span class="keyword">case</span> OPERATION_release:</span><br><span class="line">        count = <span class="built_in">CFBasicHashRemoveValue</span>(table, obj);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> == count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>__CFDoExternRefOperation</code> 是针对不同的操作，进行具体的方法调用，如果 op 是 <code>OPERATION_retain</code>，就去掉用具体实现 retain 的方法。</p><p>从 <code>BasicHash</code> 这样的方法名可以看出，其实引用计数表就是散列表。</p><p>key 为 hash(对象的地址) value 为 引用计数。</p><p>下图是 Apple 和 GNU 的实现对比：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-03.png" alt="Apple 和 GNU 内存管理的实现对比"></p><h2 id="5-autorelease-和-autorelaesepool"><a href="#5-autorelease-和-autorelaesepool" class="headerlink" title="5 autorelease 和 autorelaesepool"></a>5 autorelease 和 autorelaesepool</h2><p>在苹果对于 NSAutoreleasePool 的<a href="https://developer.apple.com/reference/foundation/nsautoreleasepool">文档</a>中表示：</p><blockquote><p>每个线程（包括主线程），都维护了一个管理 NSAutoreleasePool 的栈。当创先新的 Pool 时，他们会被添加到栈顶。当 Pool 被销毁时，他们会被从栈中移除。<br>autorelease 的对象会被添加到当前线程的栈顶的 Pool 中。当 Pool 被销毁，其中的对象也会被释放。<br>当线程结束时，所有的 Pool 被销毁释放。</p></blockquote><p>对 NSAutoreleasePool 类方法和 autorelease 方法打断点，查看其运行过程，可以看到调用了以下函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="comment">// 等同于 objc_autoreleasePoolPush</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line"><span class="comment">//  等同于 objc_autorelease(obj)</span></span><br><span class="line">    </span><br><span class="line">[<span class="built_in">NSAutoreleasePool</span> showPools];</span><br><span class="line"><span class="comment">// 查看 NSAutoreleasePool 状况</span></span><br><span class="line">    </span><br><span class="line">[pool drain];</span><br><span class="line"><span class="comment">// 等同于 objc_autoreleasePoolPop(pool)</span></span><br></pre></td></tr></table></figure><p><code>[NSAutoreleasePool showPools]</code> 可以看到当前线程所有 pool 的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objc[21536]: ##############</span><br><span class="line">objc[21536]: AUTORELEASE POOLS for thread 0x10011e3c0</span><br><span class="line">objc[21536]: 2 releases pending.</span><br><span class="line">objc[21536]: [0x101802000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[21536]: [0x101802038]  ################  POOL 0x101802038</span><br><span class="line">objc[21536]: [0x101802040]       0x1003062e0  NSObject</span><br><span class="line">objc[21536]: ##############</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><p>在 <a href="https://github.com/opensource-apple/objc4">objc4</a> 中可以查看到 AutoreleasePoolPage：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">objc4/<span class="built_in">NSObject</span>.mm AutoreleasePoolPage</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AutoreleasePoolPage </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push() </span><br><span class="line">    &#123;</span><br><span class="line">        生成或者持有 <span class="built_in">NSAutoreleasePool</span> 类对象</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> pop(<span class="keyword">void</span> *token) </span><br><span class="line">    &#123;</span><br><span class="line">        废弃 <span class="built_in">NSAutoreleasePool</span> 类对象</span><br><span class="line">        releaseAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">    &#123;</span><br><span class="line">        相当于 <span class="built_in">NSAutoreleasePool</span> 类的 addObject 类方法</span><br><span class="line">        AutoreleasePoolPage *page = 取得正在使用的 AutoreleasePoolPage 实例;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br><span class="line">    &#123;</span><br><span class="line">        将对象追加到内部数组</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> releaseAll() </span><br><span class="line">    &#123;</span><br><span class="line">        调用内部数组中对象的 release 方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AutoreleasePoolPage 以双向链表的形式组合而成（分别对应结构中的 parent 指针和 child 指针）。<br>thread 指针指向当前线程。<br>每个 AutoreleasePoolPage 对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址。<br>next 指针指向下一个 add 进来的 autorelease 的对象即将存放的位置。<br>一个 Page 的空间被占满时，会新建一个 AutoreleasePoolPage 对象，连接链表。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-04.png" alt="AutoreleasePoolPage"></p><h2 id="6-unsafe-unretained"><a href="#6-unsafe-unretained" class="headerlink" title="6 __unsafe_unretained"></a>6 __unsafe_unretained</h2><p>有时候我们除了 <code>__weak</code> 和 <code>__strong</code> 之外也会用到 <code>__unsafe_unretained</code> 这个修饰符，那么我们对 <code>__unsafe_unretained</code> 了解多少？</p><p><code>__unsafe_unretained</code> 是不安全的所有权修饰符，尽管 ARC 的内存管理是编译器的工作，但附有 <code>__unsafe_unretained</code> 修饰符的变量不属于编译器的内存管理对象。<strong>赋值时即不获得强引用也不获得弱引用</strong>。</p><p>来运行一段代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> obj1 = <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">            </span><br><span class="line">    obj1 = obj0;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;A: %@&quot;</span>, obj1);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;B: %@&quot;</span>, obj1);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-01-12 19:24:47.245220 __unsafe_unretained[55726:4408416] A: &lt;NSObject: 0x100304800&gt;</span><br><span class="line">2017-01-12 19:24:47.246670 __unsafe_unretained[55726:4408416] B: &lt;NSObject: 0x100304800&gt;</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><p>对代码进行详细分析：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> obj1 = <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自己生成并持有对象</span></span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 因为 obj0 变量为强引用，</span></span><br><span class="line">    <span class="comment">// 所以自己持有对象</span></span><br><span class="line">    obj1 = obj0;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 虽然 obj0 变量赋值给 obj1</span></span><br><span class="line">    <span class="comment">// 但是 obj1 变量既不持有对象的强引用，也不持有对象的弱引用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;A: %@&quot;</span>, obj1);</span><br><span class="line">    <span class="comment">// 输出 obj1 变量所表示的对象</span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;B: %@&quot;</span>, obj1);</span><br><span class="line">    <span class="comment">// 输出 obj1 变量所表示的对象</span></span><br><span class="line">    <span class="comment">// obj1 变量表示的对象已经被废弃</span></span><br><span class="line">    <span class="comment">// 所以此时获得的是悬垂指针</span></span><br><span class="line">    <span class="comment">// 错误访问</span></span><br></pre></td></tr></table></figure><p>所以，最后的 NSLog 只是碰巧正常运行，如果错误访问，会造成 crash<br>在使用 <code>__unsafe_unretained</code> 修饰符时，赋值给附有 <code>__strong</code> 修饰符变量时，要确保对象确实存在</p><h1 id="第二篇-Block"><a href="#第二篇-Block" class="headerlink" title="第二篇 Block"></a>第二篇 Block</h1><p>花几分钟时间看下面三个小题目，写下你的答案。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-05.png" alt="Block 的三道测试题"></p><p>这个三个小题目，我在整理此片博文之前给了三位朋友去解答，最后的结果，除了一位朋友 3 题全部正确，其他两个朋友均只答中 1 题。</p><p>说明还是有很多 iOS 的朋友对于 Block 并没有透彻理解。本篇博文会对 Block 进行详细的解说。</p><h2 id="1-Block-使用的简单规则"><a href="#1-Block-使用的简单规则" class="headerlink" title="1 Block 使用的简单规则"></a>1 Block 使用的简单规则</h2><p>先了解简单规则，再去分析原理和实现：</p><blockquote><p>Block 中，Block <strong>表达式截获</strong>所使用的自动变量的值，即保存该自动变量的<strong>瞬间值</strong>。<br>修饰为 <code>__block</code> 的变量，在捕获时，获取的<strong>不再是瞬间值</strong>。</p></blockquote><p>至于 Why，后面将会继续说。</p><h2 id="2-Block-的实现"><a href="#2-Block-的实现" class="headerlink" title="2 Block 的实现"></a>2 Block 的实现</h2><p>Block 是带有自动变量（局部变量）的匿名函数。<br>Block 表达式很简单，总体可以描述为：『<code>^ 返回值类型 参数列表 表达式</code>』。<br>但是 Block 并不是 Objective-C 中才有的语法，这是怎么一回事？</p><p>clang 编译器提供给程序员了解 Objective-C 背后机制的方法，通过 clang 的转换可以看到 Block 的实现原理。</p><p>通过 <code>clang -rewrite-objc yourfile.m</code> clang 将会把 Objective-C 的代码转换成 C 语言的代码。</p><h3 id="2-1-Block-基本实现剖析"><a href="#2-1-Block-基本实现剖析" class="headerlink" title="2.1 Block 基本实现剖析"></a>2.1 Block 基本实现剖析</h3><p>用 Xcode 创建 Command Line 项目，写如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;Block&quot;</span>)&#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 clang 转换：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-06.png" alt=""></p><p>以上是转换后的代码，不要方，一段一段看。</p><p>可以看到，Block 的实现内容，<strong>被转换成了一个普通的静态函数 <code>__main_func_0</code></strong>。</p><p>再看其他部分：</p><p><strong>main.cpp __block_impl:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__block_impl</code> 结构体包括了一些标志、今后版本升级<strong>预留的变量</strong>、<strong>函数指针</strong>。</p><hr><p><strong>main.cpp __main_block_desc_0:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure><p><code>__main_block_desc_0</code> 结构体包括了今后版本升级预留的变量、block 大小。</p><hr><p><strong>main.cpp __main_block_impl_0:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line"></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__main_block_impl_0</code> 结构体含有两个成员变量，分别是 <code>__block_impl</code> 和 <code>__main_block_desc_0</code>实例变量。</p><p>此外，还含有一个构造方法。该构造方法在 main 函数中被如下调用：</p><p><strong>main.cpp __main_block_impl_0 构造函数的调用:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0,</span><br><span class="line">                                              &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure><p>去掉各种强制转换，做简化：</p><p><strong>main.cpp __main_block_impl_0 构造函数的调用 简化:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> <span class="title">tmp</span> =</span> __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> *<span class="title">blk</span> =</span> &amp;tmp;</span><br></pre></td></tr></table></figure><p>以上代码即：将 <code>__main_block_impl_0</code> 结构体实例的指针，赋值给 <code>__main_block_impl_0</code> 结构体指针类型的变量 <code>blk</code>。也就是我们最初的结构体定义：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;Block&quot;</span>);&#125;;</span><br></pre></td></tr></table></figure><p>另外，main 函数中还有另外一段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br></pre></td></tr></table></figure><p>去掉各种转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*blk-&gt;impl.FuncPtr)(blk);</span><br></pre></td></tr></table></figure><p>实际就是最初的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blk();</span><br></pre></td></tr></table></figure><blockquote><p>本节所有代码在 <a href="https://github.com/summertian4/iOS-ObjectiveC/tree/master/ObjcMemory/ObjcMemory-Test-Code/block_implementation">block_implementation</a> 中</p></blockquote><h3 id="2-2-Block-截获外部变量瞬间值的实现剖析"><a href="#2-2-Block-截获外部变量瞬间值的实现剖析" class="headerlink" title="2.2 Block 截获外部变量瞬间值的实现剖析"></a>2.2 Block 截获外部变量瞬间值的实现剖析</h3><p>2.1 中对最简单的 <em>无参数 Block 声明、调用</em> 进行了 clang 转换。接下来再看一段『截获自动变量』的代码(可以使用命令 <code>clang -rewrite-objc -fobjc-arc -fobjc-runtime=macosx-10.7 main.m</code>)：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">&quot;val = %d\n&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;printf(fmt, val);&#125;;</span><br><span class="line">    </span><br><span class="line">    val = <span class="number">2</span>;</span><br><span class="line">    fmt = <span class="string">&quot;These values were changed, val = %d\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clang 转换之后：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-07.png" alt=""></p><p>和 2.1 节中的转换代码对比，可以发现多了一些代码。</p><p>首先，<code>__main_block_impl_0</code> 多了一个变量 <code>val</code>，并在构造函数的参数中加入了 <code>val</code> 的赋值：</p><p><strong>main.cpp __main_block_impl_0:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _val, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), val(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而在 main 函数中，对 Block 的声明变为此句：</p><p><strong>main.cpp __main_block_impl_0 构造函数的调用:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val));</span><br></pre></td></tr></table></figure><p>去掉转换：</p><p><strong>main.cpp __main_block_impl_0 构造函数的调用 简化:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 tmp = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, val);</span><br><span class="line">    <span class="keyword">struct</span> __main_block_impl_0 *blk = &amp;tmp;</span><br></pre></td></tr></table></figure><p>_<strong>所以，在 Block 被声明时，Block 已经将 <code>val</code> 作为 <code>__main_block_impl_0</code> 的内部变量保存下来了。无论在在声明之后怎样更改 val 的值，都不会影响，Block 调用时访问的内部 val 值。这就是 Block 捕获变量瞬间值的原理。</strong>_</p><blockquote><p>本节所有代码在 <a href="https://github.com/summertian4/iOS-ObjectiveC/tree/master/ObjcMemory/ObjcMemory-Test-Code/EX05">EX05</a> 中</p></blockquote><h3 id="2-3-block-变量的访问实现剖析"><a href="#2-3-block-变量的访问实现剖析" class="headerlink" title="2.3 __block 变量的访问实现剖析"></a>2.3 __block 变量的访问实现剖析</h3><p>我们知道，Block 中能够读取，但是不能更改一个局部变量，如果去更改，Xcode 会提示你无法在 Block 内部更改变量。</p><p>Block 内部只是对局部变量只读，但是 Block 能读写以下几种变量：</p><ol><li>静态变量</li><li>静态全局变量</li><li>全局变量</li></ol><p>也就是说以下代码是没有问题的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int global_val = 1;</span><br><span class="line">static int static_global_val = 2;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    static int static_val = 3;</span><br><span class="line">    </span><br><span class="line">    void (^blk)(void) = ^ &#123;</span><br><span class="line">        global_val = 1 * 2;</span><br><span class="line">        static_global_val = 2 * 2;</span><br><span class="line">        static_val = 3 * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在 Block 内部写局部变量，需要对访问的局部变量增加 __block 修饰。</p><p>__block 修饰符其实类似于 C 语言中 static、auto、register 修饰符。用于指定将变量值设置到哪个存储域中。</p><p>具体 __block 之后究竟做了哪些变化我们可以写代码测试：</p><p><strong>EX07:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    __block int val = 10;</span><br><span class="line">    void (^blk)(void) = ^&#123;val = 1;&#125;;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clang 转换之后：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-08.png" alt=""></p><p>跟 2.2 对比，似乎又加了非常代码。发现多了两个结构体。</p><p><strong>main.cpp __Block_byref_val_0:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很惊奇的发现，<strong>block 类型的 <code>val</code> 变成了结构体 `</strong>Block_byref_val_0<code>的实例。这个实例内，包含了</code><strong>isa<code>指针、一个标志位</code></strong>flags<code>、一个记录大小的</code><strong>size<code>。最最重要的，多了一个</code></strong>forwarding<code>指针和</code>val` 变量。这是怎么回事？</p><p>在 main 函数部分，实例化了该结构体：</p><p><strong>main.cpp main.m 部分:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__Block_byref_val_0 val = &#123;(void*)0,</span><br><span class="line">                            (__Block_byref_val_0 *)&amp;val,</span><br><span class="line">                            0,</span><br><span class="line">                            sizeof(__Block_byref_val_0),</span><br><span class="line">                            10&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看出该结构体对象初始化时：</p><ol><li><strong>__forwarding 指向了结构体实例本身在内存中的地址</strong></li><li>val = 10</li></ol><p>而在 main 函数中，<code>val = 1</code> 这句赋值语句变成了：</p><p><strong>main.cpp <code>val = 1;</code> 对应的函数:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(val-&gt;__forwarding-&gt;val) = 1;</span><br></pre></td></tr></table></figure><p>这里就可以看出其精髓，val = 1，实际上更改的是 <code>__Block_byref_val_0</code> 结构体实例 val 中的 <code>__forwarding</code> 指针（也就是本身）指向的 <code>val</code> 变量。</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-12.png" alt="__Block_byref_val_0 实例示意图"></p><p>而对 <code>val</code> 访问也是如此。你可以理解为通过取地址改变变量的值，这和 C 语言中取地址改变变量类似。</p><p>所以，声明 <strong>block 的变量可以被改变。至于 `</strong>forwarding` 的其他巨大作用，会继续分析。</p><blockquote><p>本节代码在 <a href="https://github.com/summertian4/iOS-ObjectiveC/tree/master/ObjcMemory/ObjcMemory-Test-Code/EX07">EX05</a> 中</p></blockquote><h2 id="3-Block-的存储域"><a href="#3-Block-的存储域" class="headerlink" title="3 Block 的存储域"></a>3 Block 的存储域</h2><p>Block 有三种类型，分别是：</p><blockquote><ol><li>__NSConcreteStackBlock         ————————栈中</li><li>__NSConcreteGlobalBlock        ————————数据区域中</li><li>__NSConcreteMallocBlock        ————————堆中</li></ol></blockquote><p><strong>__NSConcreteGlobalBlock 出现的地方有：</strong></p><ol><li>设置全局变量的地方有 Block 语法时</li><li>Block 语法的表达式中不使用任何外部变量时</li></ol><p>设置在栈上的 Block，如果所属的变量作用域结束，Block 就会被废弃。如果其中用到了 <strong>block，</strong>block 所属的变量作用域结束也会被废弃。</p><p>为了解决这个问题，Block 在必要的时候就需要从栈中移到堆中。ARC 有效时，很多情况下，编译器会帮助完成 Block 的 copy，但很多情况下，我们需要手动 copy Block。</p><p>对不同存储域的 Block copy 时，影响如下：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-09.png" alt="对不同存储域的 Block copy 影响"></p><p>copy 时，对访问到的 __block 类型对象影响如下：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-10.png" alt="Block copy 时对 __block 对象的影响"></p><blockquote><p>此时可以看出 <code>__forwarding</code> 的巨大作用——无论 Block 此时在堆中还是在栈中，由于 <code>__forwarding</code> 指向局部变量转换成的结构体实例的真是地址，所以都能确保正确的访问。</p></blockquote><p>具体的来说：</p><ol><li>当 <strong>block 变量被一个 Block 使用时，Block 从栈复制到堆，</strong>block 变量也会被复制到，并被该 Block 持有。</li><li>在 <strong>block 变量被多个 Block 使用时，在任何一个 Block 从栈复制到堆时， </strong>block 变量也会被复制到堆，并被该 Block 持有。但由于 <code>__forwarding</code> 指针的存在，无论 <strong>block 变量和 Block 在不在同一个存储域，都可以正确的访问 </strong>block 变量。</li><li>如果堆上的 Block 被废弃，那么它所使用的 __block 变量也会被释放。</li></ol><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-11.png" alt=""></p><p>前面说到编译器会帮助完成一些 Block 的 copy，也有手动 copy Block。那么 Block 被复制到堆上的情况有（此段摘自于『Objective-C高级编程 iOS与OS X多线程和内存管理』）：</p><ol><li>调用 Block 的 copy 方法时</li><li>Block 作为返回值时</li><li>将 Block 赋值给附有 <code>__strong</code> 修饰符的成员变量时（id类型或 Block 类型）时</li><li>在方法名中含有 <code>usingBlock</code> 的 Cocoa 框架方法或 GCD 的 API 中传递 Block 时</li></ol><h2 id="4-Block-循环引用"><a href="#4-Block-循环引用" class="headerlink" title="4 Block 循环引用"></a>4 Block 循环引用</h2><p>Block 循环引用，是在编程中非常常见的问题，甚至很多时候，我们并不知道发生了循环引用，直到我们突然某一天发现『怎么这个对象没有调用 delloc』，才意识到有问题存在。</p><p>在『Block 存储域』中也说明了 Block 在 copy 后对 __block 对象会 retain 一次。</p><p>那么对于如下情况就会发生循环引用：</p><p><strong>block_retain_cycle:</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) blk_t blk;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    _blk = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;self = %@&quot;</span>, <span class="keyword">self</span>);&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ dealloc&quot;</span>, <span class="keyword">self</span>.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">id</span> myobj = [[MyObject alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, myobj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 self -&gt; blk，blk -&gt; self，双方都无法释放。</p><p>但要注意的是，对于以下情况，同样会发生循环引用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">block_retain_cycle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) blk_t blk;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是多加的一句</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面是多加的一句</span></span><br><span class="line">    _blk = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@&quot;self = %@&quot;</span>, _obj);&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ dealloc&quot;</span>, <span class="keyword">self</span>.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">id</span> myobj = [[MyObject alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, myobj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是由于 self -&gt; obj，self -&gt; blk，blk -&gt; obj。这种情况是非常容易被忽视的。</p><h2 id="5-重审问题"><a href="#5-重审问题" class="headerlink" title="5 重审问题"></a>5 重审问题</h2><p>我们再来看看最初的几个小题目：</p><p><img src="https://raw.githubusercontent.com/summertian4/Images/master/blog/blog_iOS%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%26Block-05.png" alt="Block 的三道测试题"></p><ol><li><p>第一题：</p><p>由于 Block 捕获瞬间值，所以输出为 <code>in block val = 0</code></p></li><li><p>第二题：</p><p>由于 <code>val</code> 为 __block，外部更改会影响到内部访问，所以输出为 <code>in block val = 1</code></p></li><li><p>第三题：</p><p>和第二题类似，<code>val = 1</code> 能影响到 Block 内部访问，所以先输出 <code>in block val = 1</code>，之后在     Block 内部更改 <code>val</code> 值，再次访问时输出 <code>after block val = 2</code>。</p></li></ol><h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><p>我写这篇文章是在我阅读了『Objective-C高级编程 iOS与OS X多线程和内存管理』一书之后，博文中也有很内容源于『Objective-C高级编程 iOS与OS X多线程和内存管理』。</p><p>非常向大家推荐此书。这本书里记录了关于 iOS 内存管理的深入内容。但要注意的是，此书中的多处知识点并不是很详细，需要你以拓展的心态去学习。在有解释不详细的地方，自己主动去探索，去拓展，找更多的资料，最后，你会发现你对 iOS 内存管理有了更多的深入的理解。</p><p>对于文章中的测试代码，全部在<a href="https://github.com/summertian4/iOS-ObjectiveC/tree/master/ObjcMemory">这里</a>。</p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">LottyLotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一篇-iOS-内存管理&quot;&gt;&lt;a href=&quot;#第一篇-iOS-内存管理&quot; class=&quot;headerlink&quot; title=&quot;第一篇 iOS 内存管理&quot;&gt;&lt;/a&gt;第一篇 iOS 内存管理&lt;/h1&gt;&lt;h2 id=&quot;1-似乎每个人在学习-iOS-过程中都考虑过的问题&quot;&gt;&lt;a href=&quot;#1-似乎每个人在学习-iOS-过程中都考虑过的问题&quot; class=&quot;headerlink&quot; title=&quot;1 似乎每个人在学习 iOS 过程中都考虑过的问题&quot;&gt;&lt;/a&gt;1 似乎每个人在学习 iOS 过程中都考虑过的问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;alloc retain release delloc 做了什么？&lt;/li&gt;
&lt;li&gt;autoreleasepool 是怎样实现的？&lt;/li&gt;
&lt;li&gt;__unsafe_unretained 是什么？&lt;/li&gt;
&lt;li&gt;Block 是怎样实现的&lt;/li&gt;
&lt;li&gt;什么时候会引起循环引用，什么时候不会引起循环引用？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以我将在本篇博文中详细的从 ARC 解释到 iOS 的内存管理，以及 Block 相关的原理、源码。&lt;/p&gt;
&lt;h2 id=&quot;2-从-ARC-说起&quot;&gt;&lt;a href=&quot;#2-从-ARC-说起&quot; class=&quot;headerlink&quot; title=&quot;2 从 ARC 说起&quot;&gt;&lt;/a&gt;2 从 ARC 说起&lt;/h2&gt;&lt;p&gt;说 iOS 的内存管理，就不得不从 ARC（Automatic Reference Counting / 自动引用计数） 说起， ARC 是 WWDC2011 和 iOS5 引入的变化。ARC 是 LLVM 3.0 编译器的特性，用来自动管理内存。&lt;/p&gt;
&lt;p&gt;与 Java 中 GC 不同，ARC 是编译器特性，而不是基于运行时的，所以 ARC 其实是在编译阶段自动帮开发者插入了管理内存的代码，而不是实时监控与回收内存。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://lottyzhou.com/categories/iOS/"/>
    
      <category term="iOS进阶" scheme="http://lottyzhou.com/categories/iOS/iOS%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="iOS" scheme="http://lottyzhou.com/tags/iOS/"/>
    
      <category term="iOS进阶" scheme="http://lottyzhou.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
      <category term="内存与引用" scheme="http://lottyzhou.com/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>找回丢失的 Github（谨慎保管 2FA 验证）</title>
    <link href="http://lottyzhou.com/2017/02/07/%E6%89%BE%E5%9B%9E%E4%B8%A2%E5%A4%B1%E7%9A%84-Github-%E8%A1%80%E6%B3%AA%E5%8F%B2%EF%BC%88%E8%B0%A8%E6%85%8E%E4%BF%9D%E7%AE%A1-2FA-%E9%AA%8C%E8%AF%81%EF%BC%89/"/>
    <id>http://lottyzhou.com/2017/02/07/找回丢失的-Github-血泪史（谨慎保管-2FA-验证）/</id>
    <published>2017-02-07T06:53:14.000Z</published>
    <updated>2021-10-11T09:40:59.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why-我丢失了-Github-账号"><a href="#Why-我丢失了-Github-账号" class="headerlink" title="Why 我丢失了 Github 账号"></a>Why 我丢失了 Github 账号</h1><p>从前天，经过了两天时间与 Github 客服对话，终于找回了我的 Github。</p><p>朋友在问我为什么登陆不了 Github 的时候表示不太理解。</p><p>原因很简单，因为我丢失了两步验证的 app，也丢失了 recovery code。</p><span id="more"></span><h1 id="2FA-和基于时间戳的实时验证码"><a href="#2FA-和基于时间戳的实时验证码" class="headerlink" title="2FA 和基于时间戳的实时验证码"></a>2FA 和基于时间戳的实时验证码</h1><p>其实，是这样的。Github 也有两步验证（2FA），提供了两种可选方式：</p><ol><li>使用手机接收短信</li><li>使用由时间戳生成的 2FA 实时验证码生成</li></ol><p>由于方法 1 无法支持国内的手机号，所以只能使用方法 2。</p><p>方法二的原理是，Github 会提供一个秘钥，通常以二维码的方式显示，用三方软件比如 Autenticator、1password（当时我不知道 1password 也可以） 在扫码之后，将秘钥保存到客户端。</p><p>在用户登陆的时候，app 会以秘钥和时间戳为参数，通过固定算法生成一个 6 位数字的一次验证码。</p><p>服务端通过同样的算法也会生成一个同样的一次性验证码，两者对比一致，则通过验证。和手机短信接收验证码很类似。</p><p>Github 在开启 2FA 的同时，会提供给你一份 recovery code，如果你无法拿到一次验证码，就使用 recovery code 暂时通过验证。recovery code 只能使用一次，使用过一次以后，就会被更新，你需要保存新的 recovery code。</p><p>当时我选择验证码生成 app 是 Google 的 Autenticator。就是这个 app 坑了我。这个 app 不需要登陆，我直接扫码就记录了，但是我当时用的 iPhone 6，在更换了 iPhone 7 之后，iPhone 6 借给他人使用前做了抹除，So，我没有了 app，只能通过 recovery code 恢复，但是奇怪的事，我使用三个月内我印象里最新的 recovery code 去验证，但是失败了。</p><p>在彻底折腾一番发现没办法后，去联系了 Github 客服。</p><h1 id="Github-客服"><a href="#Github-客服" class="headerlink" title="Github 客服"></a>Github 客服</h1><p>当你没有 2FA app，也丢失了 recovery code 之后，你必须去联系客服，请求帮助你关闭 2FA。</p><p>这时候客服会要求你运行一段 command，以证明的电脑使用过此账号的公钥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com verify</span><br></pre></td></tr></table></figure><p>但是我怎样也得不到结果，要么提示 DNS 劫持（和公司的网络翻墙了有关），要么其他的种种问题。</p><p>在和 Github 客服一番对话后，对方表示验证的 ssh 公钥是应由 Github Destop 软件生成了。当时很懵逼，问对方『难道我自己生成的秘钥就不是秘钥了？难道不能证明我电脑生成的这个公钥？』。然后客服就说『你 2015 年用一台 Macbook Pro 生成了一个公钥，这是你的电脑吗？』，然后 run 一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.ssh/github_rsa -T git@github.com verify</span><br></pre></td></tr></table></figure><p>然后 run 之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase for key &#x27;/Users/zhoulingyu/.ssh/github_rsa&#x27;:</span><br></pre></td></tr></table></figure><p>当时我想了一下，傻傻的输入了 Github 密码，然而不对。然后我让几个朋友 run 了一下，均是直接显示出了 verification token。我很奇怪，于是想了一下，发现这里要求输入的密码应该是当初生成公钥的时候设置的密码，通常很多人都会选择不设置密码，但是我显然当初设置了，然而我记不起来。</p><p>一番搜索之后，得到了一个 happy 的结果，如果你是 windows，那洗洗睡吧，如果是 Mac，这个密码可以在 keychain 中找到，具体方法在<a href="https://help.github.com/articles/recovering-your-ssh-key-passphrase/">这里</a>。</p><p>我从 keychain 中粘出密码后我就惊呆了，是一个 40 多位的密码。显然是自动生成的高复杂度密码。我当时一定是忘了保存。</p><p>SO，拿到 verification token 之后，Github 客服就帮我关掉了 2FA。</p><p>随后，我发现 1password 是可以生成一次性验证码的，于是使用 1password 保存，不在使用 Google 的 app。</p><h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><p>这篇文章就是做一个记录，自己弄了两天，都去按照客服意见新建了 Gihub 账号 Fork 了原来所有的项目。最终找到的时候也是喜出望外。</p><p>也希望这篇记录能帮到其他人。</p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Why-我丢失了-Github-账号&quot;&gt;&lt;a href=&quot;#Why-我丢失了-Github-账号&quot; class=&quot;headerlink&quot; title=&quot;Why 我丢失了 Github 账号&quot;&gt;&lt;/a&gt;Why 我丢失了 Github 账号&lt;/h1&gt;&lt;p&gt;从前天，经过了两天时间与 Github 客服对话，终于找回了我的 Github。&lt;/p&gt;
&lt;p&gt;朋友在问我为什么登陆不了 Github 的时候表示不太理解。&lt;/p&gt;
&lt;p&gt;原因很简单，因为我丢失了两步验证的 app，也丢失了 recovery code。&lt;/p&gt;
    
    </summary>
    
      <category term="Other" scheme="http://lottyzhou.com/categories/Other/"/>
    
      <category term="Github" scheme="http://lottyzhou.com/categories/Other/Github/"/>
    
    
      <category term="Other" scheme="http://lottyzhou.com/tags/Other/"/>
    
      <category term="Github" scheme="http://lottyzhou.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>iOS——关于-Taptic-Engine-震动反馈</title>
    <link href="http://lottyzhou.com/2017/01/16/iOS%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E-Taptic-Engine-%E9%9C%87%E5%8A%A8%E5%8F%8D%E9%A6%88/"/>
    <id>http://lottyzhou.com/2017/01/16/iOS——关于-Taptic-Engine-震动反馈/</id>
    <published>2017-01-16T02:30:17.000Z</published>
    <updated>2021-10-11T09:40:59.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-has-Happened？"><a href="#What-has-Happened？" class="headerlink" title="What has Happened？"></a>What has Happened？</h1><p>上周，leader 拿着 iPhone 7 打开了网易新闻，问我：『你看，你这里的下拉刷新是<code>短震动</code>，我们的手机数周遥控电视的时候只有<code>长震动</code>，产品那边问能不能用短震动』。</p><p>然后博主就去查看了一下关于短震动的方式，整个过程可以描述为——『资料真少！』。</p><p>不过最后通过一下午的搜集，最终还是总结整理出来了这份文档，也补充了自己对 iPhone 6s 之后对 Taptic Engine 的了解。</p><span id="more"></span><h1 id="Taptic-Engine"><a href="#Taptic-Engine" class="headerlink" title="Taptic Engine"></a>Taptic Engine</h1><p>先了解一个概念——Taptic Engine</p><p>Taptic Engine 是苹果产品上推出的全新震动模块，该元件最早出现在 Apple Watch 中。iPhone 6s 和 iPhone 6s Plus 中，也同样内置了Taptic Engine，在设计上有所升级。</p><p>Taptic Engine 振动模块为 Apple Watch 以及 iPhone 6s、iPhone 7 提供了 Force Touch 以及 3D Touch，不同的屏幕操作，可以感受到不同的振动触觉效果，带来更好的用户体验。</p><h1 id="短震方法一-AudioServicesPlaySystemSound"><a href="#短震方法一-AudioServicesPlaySystemSound" class="headerlink" title="短震方法一 AudioServicesPlaySystemSound"></a>短震方法一 AudioServicesPlaySystemSound</h1><p>常用调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);</span><br></pre></td></tr></table></figure><p>以上代码在各个型号手机中反应为长震</p><p>API 系统版本支持：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_2_0);</span><br></pre></td></tr></table></figure><p>APPLE 公开的 <code>SystemSoundID</code> 有：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CF_ENUM</span>(SystemSoundID)</span><br><span class="line">&#123;</span><br><span class="line">    kSystemSoundID_UserPreferredAlert   = <span class="number">0x00001000</span>,</span><br><span class="line">    kSystemSoundID_FlashScreen          = <span class="number">0x00000FFE</span>,</span><br><span class="line">        <span class="comment">// this has been renamed to be consistent</span></span><br><span class="line">    kUserPreferredAlert     = kSystemSoundID_UserPreferredAlert</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CF_ENUM</span>(SystemSoundID)</span><br><span class="line">&#123;</span><br><span class="line">    kSystemSoundID_Vibrate              = <span class="number">0x00000FFF</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上类型 <em><strong>没有短震动</strong></em> 。</p><p>但通过以下代码，可以得到更多类型的震动：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通短震，3D Touch 中 Peek 震动反馈</span></span><br><span class="line">AudioServicesPlaySystemSound(<span class="number">1519</span>);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通短震，3D Touch 中 Pop 震动反馈</span></span><br><span class="line">AudioServicesPlaySystemSound(<span class="number">1520</span>);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连续三次短震</span></span><br><span class="line">AudioServicesPlaySystemSound(<span class="number">1521</span>);</span><br></pre></td></tr></table></figure><p>但以上 ID 均未在 Apple 的 Documents 中描述。显然，<em><strong>这是调用了一些私有一些属性 </strong></em> 。</p><p>关于是否调用了私有 API，也有一些讨论，可以查看<a href="https://forums.developer.apple.com/thread/45628">这里</a>。</p><h1 id="短震方法二-获取-tapticEngine"><a href="#短震方法二-获取-tapticEngine" class="headerlink" title="短震方法二 获取 _tapticEngine"></a>短震方法二 获取 _tapticEngine</h1><p>这种方法是从<a href="https://unifiedsense.com/development/using-taptic-engine-on-ios.html">这里</a>搜集到的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> tapticEngine = [[<span class="built_in">UIDevice</span> currentDevice] performSelector: <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;_tapticEngine&quot;</span>)</span><br><span class="line">                                                     withObject:<span class="literal">nil</span>];</span><br><span class="line">[tapticEngine performSelector: <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;actuateFeedback:&quot;</span>)</span><br><span class="line">                       withObject:@(<span class="number">0</span>)];</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> tapticEngine = [[<span class="built_in">UIDevice</span> currentDevice] performSelector: <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;_tapticEngine&quot;</span>)</span><br><span class="line">                                                     withObject:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;actuateFeedback:&quot;</span>);</span><br><span class="line">int32_t arg = <span class="number">1001</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSInvocation</span> *inv = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:[tapticEngine methodSignatureForSelector:selector]];</span><br><span class="line">[inv setTarget:tapticEngine];</span><br><span class="line">[inv setSelector:selector];</span><br><span class="line">[inv setArgument:&amp;arg atIndex:<span class="number">2</span>];</span><br><span class="line">[inv invoke];</span><br></pre></td></tr></table></figure><p>显然， <em><strong>这是调用了私有 API</strong></em> 。</p><p>这些方法，在实际测试的时候发现，在 iPhone 7 上调用没有震动反馈，在 iPhone 6S Plus 上调用有震动反馈，在 iPhone 6 上调用 无反馈。</p><h1 id="短震方法三-UIImpactFeedbackGenerator"><a href="#短震方法三-UIImpactFeedbackGenerator" class="headerlink" title="短震方法三 UIImpactFeedbackGenerator"></a>短震方法三 UIImpactFeedbackGenerator</h1><p>iOS10 引入了一种新的、产生触觉反馈的方式， <em><strong>帮助用户认识到不同的震动反馈有不同的含义</strong></em> 。这个功能的核心就是由 <code>UIFeedbackGenerator</code> 提供。Apple 对于 <code>UIImpactFeedbackGenerator</code> 有一篇<a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator#2555399">介绍文档</a>。</p><p>UIFeedbackGenerator 可以帮助你实现 haptic feedback。它的要求是：</p><ol><li>支持 Taptic Engine 机型 (iPhone 7 以及 iPhone 7 Plus).</li><li>app 需要在前台运行</li><li>系统 Haptics setting 需要开启</li></ol><p>Apple 曾表示公开了 Taptic Engine 的 API，但是鲜有文档。在搜罗了各种资料后，可以认为 <code>UIImpactFeedbackGenerator</code> 即 Taptic Engine 的 公开 API。</p><p>它的调用方式是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImpactFeedbackGenerator</span> *generator = [[<span class="built_in">UIImpactFeedbackGenerator</span> alloc] initWithStyle: <span class="built_in">UIImpactFeedbackStyleLight</span>];</span><br><span class="line">[generator prepare];</span><br><span class="line">[generator impactOccurred];</span><br></pre></td></tr></table></figure><h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><p>观察 <code>UIImpactFeedbackGenerator</code> 你会发现它继承于 <code>UIFeedbackGenerator</code>。除了 <code>UIImpactFeedbackGenerator</code> 还有三种 FeedbackGenerator：</p><ol><li>UIImpactFeedbackGenerator</li><li>UISelectionFeedbackGenerator</li><li>UINotificationFeedbackGenerator</li></ol><p>详情可参考 Apple 的 <a href="https://developer.apple.com/reference/uikit/uifeedbackgenerator?language=objc">这篇 Reference</a> 。</p><p>对于震动反馈的应用，Apple 也给出了示例场景：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)gestureHandler:(<span class="built_in">UIPanGestureRecognizer</span> *)sender &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (sender.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Instantiate a new generator.</span></span><br><span class="line">            <span class="keyword">self</span>.feedbackGenerator = [[<span class="built_in">UISelectionFeedbackGenerator</span> alloc] init];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Prepare the generator when the gesture begins.</span></span><br><span class="line">            [<span class="keyword">self</span>.feedbackGenerator prepare];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Check to see if the selection has changed...</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> myCustomHasSelectionChangedMethodWithTranslation:[sender translationInView: <span class="keyword">self</span>.view]]) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Trigger selection feedback.</span></span><br><span class="line">                [<span class="keyword">self</span>.feedbackGenerator selectionChanged];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Keep the generator in a prepared state.</span></span><br><span class="line">                [<span class="keyword">self</span>.feedbackGenerator prepare];</span><br><span class="line">    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateCancelled</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateFailed</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Release the current generator.</span></span><br><span class="line">            <span class="keyword">self</span>.feedbackGenerator = <span class="literal">nil</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Do nothing.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三种方法在测试机上不同的反馈结果"><a href="#三种方法在测试机上不同的反馈结果" class="headerlink" title="三种方法在测试机上不同的反馈结果"></a>三种方法在测试机上不同的反馈结果</h1><table><thead><tr><th>AudioServicesPlaySystemSound</th><th>1519</th><th>1520</th><th>1521</th></tr></thead><tbody><tr><td>iPhone 7（iOS 10）</td><td>peek 触感</td><td>pop 触感</td><td>三次连续短振</td></tr><tr><td>iPhone 6s Puls（iOS 9）</td><td>peek 触感</td><td>pop 触感</td><td>三次连续短振</td></tr><tr><td>iPhone 6（iOS 10）</td><td>无振动</td><td>无振动</td><td>无振动</td></tr></tbody></table><table><thead><tr><th>获取 _tapticEngine</th><th></th></tr></thead><tbody><tr><td>iPhone 7（iOS 10）</td><td>无振动</td></tr><tr><td>iPhone 6s Puls（iOS 9）</td><td>长振</td></tr><tr><td>iPhone 6（iOS 10）</td><td>无振动</td></tr></tbody></table><table><thead><tr><th>UIImpactFeedbackGenerator</th><th>.Light</th><th>.Medium</th><th>.Heavy</th></tr></thead><tbody><tr><td>iPhone 7（iOS 10）</td><td>微弱短振</td><td>中等短振</td><td>明显短振</td></tr><tr><td>iPhone 6s Puls（iOS 9）</td><td>长振</td><td>长振</td><td>长振</td></tr><tr><td>iPhone 6（iOS 10）</td><td>无振动</td><td>无振动</td><td>无振动</td></tr></tbody></table><p>总结一下，希望同样的代码能在更多的机型上实现短振，建议使用 AudioServicesPlaySystemSound(1519)。不过可能会涉及到调用私有 API。安全起见，可以使用 <code>UIImpactFeedbackGenerator</code>。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>测试代码在<a href="https://github.com/summertian4/iOS-ObjectiveC/tree/master/iPhoneShakeDemo">这里</a>。</p><hr><p>有什么问题都可以在博文后面留言，或者微博上私信我。</p><p>博主是 iOS 妹子一枚。</p><p>希望大家一起进步。</p><p>我的微博：<a href="http://weibo.com/coderfish/">Lotty周小鱼</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;What-has-Happened？&quot;&gt;&lt;a href=&quot;#What-has-Happened？&quot; class=&quot;headerlink&quot; title=&quot;What has Happened？&quot;&gt;&lt;/a&gt;What has Happened？&lt;/h1&gt;&lt;p&gt;上周，leader 拿着 iPhone 7 打开了网易新闻，问我：『你看，你这里的下拉刷新是&lt;code&gt;短震动&lt;/code&gt;，我们的手机数周遥控电视的时候只有&lt;code&gt;长震动&lt;/code&gt;，产品那边问能不能用短震动』。&lt;/p&gt;
&lt;p&gt;然后博主就去查看了一下关于短震动的方式，整个过程可以描述为——『资料真少！』。&lt;/p&gt;
&lt;p&gt;不过最后通过一下午的搜集，最终还是总结整理出来了这份文档，也补充了自己对 iPhone 6s 之后对 Taptic Engine 的了解。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://lottyzhou.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://lottyzhou.com/tags/iOS/"/>
    
  </entry>
  
</feed>
